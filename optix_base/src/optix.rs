/* automatically generated by rust-bindgen 0.59.2 */

pub const OPTIX_SBT_RECORD_ALIGNMENT: u32 = 16;
pub const OPTIX_ACCEL_BUFFER_BYTE_ALIGNMENT: u32 = 128;
pub const OPTIX_INSTANCE_BYTE_ALIGNMENT: u32 = 16;
pub const OPTIX_AABB_BUFFER_BYTE_ALIGNMENT: u32 = 8;
pub const OPTIX_GEOMETRY_TRANSFORM_BYTE_ALIGNMENT: u32 = 16;
pub const OPTIX_TRANSFORM_BYTE_ALIGNMENT: u32 = 64;
pub const OPTIX_COMPILE_DEFAULT_MAX_REGISTER_COUNT: u32 = 0;
pub const OPTIX_COMPILE_DEFAULT_MAX_PAYLOAD_TYPE_COUNT: u32 = 8;
pub const OPTIX_COMPILE_DEFAULT_MAX_PAYLOAD_VALUE_COUNT: u32 = 32;
pub const OPTIX_ABI_VERSION: u32 = 55;
#[doc = " CUDA device pointer"]
pub type CUdeviceptr = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixDeviceContext_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a device context"]
pub type OptixDeviceContext = *mut OptixDeviceContext_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixModule_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a module"]
pub type OptixModule = *mut OptixModule_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixProgramGroup_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a program group"]
pub type OptixProgramGroup = *mut OptixProgramGroup_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixPipeline_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a pipeline"]
pub type OptixPipeline = *mut OptixPipeline_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixDenoiser_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a denoiser instance"]
pub type OptixDenoiser = *mut OptixDenoiser_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixTask_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a work task"]
pub type OptixTask = *mut OptixTask_t;
#[doc = " Traversable handle"]
pub type OptixTraversableHandle = ::std::os::raw::c_ulonglong;
#[doc = " Visibility mask"]
pub type OptixVisibilityMask = ::std::os::raw::c_uint;
impl OptixResult {
    pub const OPTIX_SUCCESS: OptixResult = OptixResult(0);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_VALUE: OptixResult = OptixResult(7001);
}
impl OptixResult {
    pub const OPTIX_ERROR_HOST_OUT_OF_MEMORY: OptixResult = OptixResult(7002);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_OPERATION: OptixResult = OptixResult(7003);
}
impl OptixResult {
    pub const OPTIX_ERROR_FILE_IO_ERROR: OptixResult = OptixResult(7004);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_FILE_FORMAT: OptixResult = OptixResult(7005);
}
impl OptixResult {
    pub const OPTIX_ERROR_DISK_CACHE_INVALID_PATH: OptixResult = OptixResult(7010);
}
impl OptixResult {
    pub const OPTIX_ERROR_DISK_CACHE_PERMISSION_ERROR: OptixResult = OptixResult(7011);
}
impl OptixResult {
    pub const OPTIX_ERROR_DISK_CACHE_DATABASE_ERROR: OptixResult = OptixResult(7012);
}
impl OptixResult {
    pub const OPTIX_ERROR_DISK_CACHE_INVALID_DATA: OptixResult = OptixResult(7013);
}
impl OptixResult {
    pub const OPTIX_ERROR_LAUNCH_FAILURE: OptixResult = OptixResult(7050);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_DEVICE_CONTEXT: OptixResult = OptixResult(7051);
}
impl OptixResult {
    pub const OPTIX_ERROR_CUDA_NOT_INITIALIZED: OptixResult = OptixResult(7052);
}
impl OptixResult {
    pub const OPTIX_ERROR_VALIDATION_FAILURE: OptixResult = OptixResult(7053);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_PTX: OptixResult = OptixResult(7200);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_LAUNCH_PARAMETER: OptixResult = OptixResult(7201);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_PAYLOAD_ACCESS: OptixResult = OptixResult(7202);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_ATTRIBUTE_ACCESS: OptixResult = OptixResult(7203);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_FUNCTION_USE: OptixResult = OptixResult(7204);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_FUNCTION_ARGUMENTS: OptixResult = OptixResult(7205);
}
impl OptixResult {
    pub const OPTIX_ERROR_PIPELINE_OUT_OF_CONSTANT_MEMORY: OptixResult = OptixResult(7250);
}
impl OptixResult {
    pub const OPTIX_ERROR_PIPELINE_LINK_ERROR: OptixResult = OptixResult(7251);
}
impl OptixResult {
    pub const OPTIX_ERROR_ILLEGAL_DURING_TASK_EXECUTE: OptixResult = OptixResult(7270);
}
impl OptixResult {
    pub const OPTIX_ERROR_INTERNAL_COMPILER_ERROR: OptixResult = OptixResult(7299);
}
impl OptixResult {
    pub const OPTIX_ERROR_DENOISER_MODEL_NOT_SET: OptixResult = OptixResult(7300);
}
impl OptixResult {
    pub const OPTIX_ERROR_DENOISER_NOT_INITIALIZED: OptixResult = OptixResult(7301);
}
impl OptixResult {
    pub const OPTIX_ERROR_ACCEL_NOT_COMPATIBLE: OptixResult = OptixResult(7400);
}
impl OptixResult {
    pub const OPTIX_ERROR_PAYLOAD_TYPE_MISMATCH: OptixResult = OptixResult(7500);
}
impl OptixResult {
    pub const OPTIX_ERROR_PAYLOAD_TYPE_RESOLUTION_FAILED: OptixResult = OptixResult(7501);
}
impl OptixResult {
    pub const OPTIX_ERROR_PAYLOAD_TYPE_ID_INVALID: OptixResult = OptixResult(7502);
}
impl OptixResult {
    pub const OPTIX_ERROR_NOT_SUPPORTED: OptixResult = OptixResult(7800);
}
impl OptixResult {
    pub const OPTIX_ERROR_UNSUPPORTED_ABI_VERSION: OptixResult = OptixResult(7801);
}
impl OptixResult {
    pub const OPTIX_ERROR_FUNCTION_TABLE_SIZE_MISMATCH: OptixResult = OptixResult(7802);
}
impl OptixResult {
    pub const OPTIX_ERROR_INVALID_ENTRY_FUNCTION_OPTIONS: OptixResult = OptixResult(7803);
}
impl OptixResult {
    pub const OPTIX_ERROR_LIBRARY_NOT_FOUND: OptixResult = OptixResult(7804);
}
impl OptixResult {
    pub const OPTIX_ERROR_ENTRY_SYMBOL_NOT_FOUND: OptixResult = OptixResult(7805);
}
impl OptixResult {
    pub const OPTIX_ERROR_LIBRARY_UNLOAD_FAILURE: OptixResult = OptixResult(7806);
}
impl OptixResult {
    pub const OPTIX_ERROR_CUDA_ERROR: OptixResult = OptixResult(7900);
}
impl OptixResult {
    pub const OPTIX_ERROR_INTERNAL_ERROR: OptixResult = OptixResult(7990);
}
impl OptixResult {
    pub const OPTIX_ERROR_UNKNOWN: OptixResult = OptixResult(7999);
}
#[repr(transparent)]
#[doc = " Result codes returned from API functions"]
#[doc = ""]
#[doc = " All host side API functions return OptixResult with the exception of optixGetErrorName"]
#[doc = " and optixGetErrorString.  When successful OPTIX_SUCCESS is returned.  All return codes"]
#[doc = " except for OPTIX_SUCCESS should be assumed to be errors as opposed to a warning."]
#[doc = ""]
#[doc = " \\see #optixGetErrorName(), #optixGetErrorString()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixResult(pub ::std::os::raw::c_uint);
impl OptixDeviceProperty {
    #[doc = " Maximum value for OptixPipelineLinkOptions::maxTraceDepth. sizeof( unsigned int )"]
    pub const OPTIX_DEVICE_PROPERTY_LIMIT_MAX_TRACE_DEPTH: OptixDeviceProperty =
        OptixDeviceProperty(8193);
}
impl OptixDeviceProperty {
    #[doc = " Maximum value to pass into optixPipelineSetStackSize for parameter"]
    #[doc = " maxTraversableGraphDepth.v sizeof( unsigned int )"]
    pub const OPTIX_DEVICE_PROPERTY_LIMIT_MAX_TRAVERSABLE_GRAPH_DEPTH: OptixDeviceProperty =
        OptixDeviceProperty(8194);
}
impl OptixDeviceProperty {
    #[doc = " The maximum number of primitives (over all build inputs) as input to a single"]
    #[doc = " Geometry Acceleration Structure (GAS). sizeof( unsigned int )"]
    pub const OPTIX_DEVICE_PROPERTY_LIMIT_MAX_PRIMITIVES_PER_GAS: OptixDeviceProperty =
        OptixDeviceProperty(8195);
}
impl OptixDeviceProperty {
    #[doc = " The maximum number of instances (over all build inputs) as input to a single"]
    #[doc = " Instance Acceleration Structure (IAS). sizeof( unsigned int )"]
    pub const OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCES_PER_IAS: OptixDeviceProperty =
        OptixDeviceProperty(8196);
}
impl OptixDeviceProperty {
    #[doc = " The RT core version supported by the device (0 for no support, 10 for version"]
    #[doc = " 1.0). sizeof( unsigned int )"]
    pub const OPTIX_DEVICE_PROPERTY_RTCORE_VERSION: OptixDeviceProperty = OptixDeviceProperty(8197);
}
impl OptixDeviceProperty {
    #[doc = " The maximum value for #OptixInstance::instanceId. sizeof( unsigned int )"]
    pub const OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCE_ID: OptixDeviceProperty =
        OptixDeviceProperty(8198);
}
impl OptixDeviceProperty {
    #[doc = " The number of bits available for the #OptixInstance::visibilityMask."]
    #[doc = " Higher bits must be set to zero. sizeof( unsigned int )"]
    pub const OPTIX_DEVICE_PROPERTY_LIMIT_NUM_BITS_INSTANCE_VISIBILITY_MASK: OptixDeviceProperty =
        OptixDeviceProperty(8199);
}
impl OptixDeviceProperty {
    #[doc = " The maximum number of instances that can be added to a single Instance"]
    #[doc = " Acceleration Structure (IAS). sizeof( unsigned int )"]
    pub const OPTIX_DEVICE_PROPERTY_LIMIT_MAX_SBT_RECORDS_PER_GAS: OptixDeviceProperty =
        OptixDeviceProperty(8200);
}
impl OptixDeviceProperty {
    #[doc = " The maximum value for #OptixInstance::sbtOffset. sizeof( unsigned int )"]
    pub const OPTIX_DEVICE_PROPERTY_LIMIT_MAX_SBT_OFFSET: OptixDeviceProperty =
        OptixDeviceProperty(8201);
}
#[repr(transparent)]
#[doc = " Parameters used for #optixDeviceContextGetProperty()"]
#[doc = ""]
#[doc = " \\see #optixDeviceContextGetProperty()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixDeviceProperty(pub ::std::os::raw::c_uint);
#[doc = " Type of the callback function used for log messages."]
#[doc = ""]
#[doc = " \\param[in] level      The log level indicates the severity of the message. See below for"]
#[doc = "                       possible values."]
#[doc = " \\param[in] tag        A terse message category description (e.g., 'SCENE STAT')."]
#[doc = " \\param[in] message    Null terminated log message (without newline at the end)."]
#[doc = " \\param[in] cbdata     Callback data that was provided with the callback pointer."]
#[doc = ""]
#[doc = " It is the users responsibility to ensure thread safety within this function."]
#[doc = ""]
#[doc = " The following log levels are defined."]
#[doc = ""]
#[doc = "   0   disable   Setting the callback level will disable all messages.  The callback"]
#[doc = "                 function will not be called in this case."]
#[doc = "   1   fatal     A non-recoverable error. The context and/or OptiX itself might no longer"]
#[doc = "                 be in a usable state."]
#[doc = "   2   error     A recoverable error, e.g., when passing invalid call parameters."]
#[doc = "   3   warning   Hints that OptiX might not behave exactly as requested by the user or"]
#[doc = "                 may perform slower than expected."]
#[doc = "   4   print     Status or progress messages."]
#[doc = ""]
#[doc = " Higher levels might occur."]
#[doc = ""]
#[doc = " \\see #optixDeviceContextSetLogCallback(), #OptixDeviceContextOptions"]
pub type OptixLogCallback = ::std::option::Option<
    unsafe extern "C" fn(
        level: ::std::os::raw::c_uint,
        tag: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
impl OptixDeviceContextValidationMode {
    pub const OPTIX_DEVICE_CONTEXT_VALIDATION_MODE_OFF: OptixDeviceContextValidationMode =
        OptixDeviceContextValidationMode(0);
}
impl OptixDeviceContextValidationMode {
    pub const OPTIX_DEVICE_CONTEXT_VALIDATION_MODE_ALL: OptixDeviceContextValidationMode =
        OptixDeviceContextValidationMode(4294967295);
}
#[repr(transparent)]
#[doc = " Validation mode settings."]
#[doc = ""]
#[doc = " When enabled, certain device code utilities will be enabled to provide as good debug and"]
#[doc = " error checking facilities as possible."]
#[doc = ""]
#[doc = ""]
#[doc = " \\see #optixDeviceContextCreate()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixDeviceContextValidationMode(pub ::std::os::raw::c_uint);
#[doc = " Parameters used for #optixDeviceContextCreate()"]
#[doc = ""]
#[doc = " \\see #optixDeviceContextCreate()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixDeviceContextOptions {
    #[doc = " Function pointer used when OptiX wishes to generate messages"]
    pub logCallbackFunction: OptixLogCallback,
    #[doc = " Pointer stored and passed to logCallbackFunction when a message is generated"]
    pub logCallbackData: *mut ::std::os::raw::c_void,
    #[doc = " Maximum callback level to generate message for (see #OptixLogCallback)"]
    pub logCallbackLevel: ::std::os::raw::c_int,
    #[doc = " Validation mode of context."]
    pub validationMode: OptixDeviceContextValidationMode,
}
impl OptixGeometryFlags {
    #[doc = " No flags set"]
    pub const OPTIX_GEOMETRY_FLAG_NONE: OptixGeometryFlags = OptixGeometryFlags(0);
}
impl OptixGeometryFlags {
    #[doc = " Disables the invocation of the anyhit program."]
    #[doc = " Can be overridden by OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT and OPTIX_RAY_FLAG_ENFORCE_ANYHIT."]
    pub const OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT: OptixGeometryFlags = OptixGeometryFlags(1);
}
impl OptixGeometryFlags {
    #[doc = " If set, an intersection with the primitive will trigger one and only one"]
    #[doc = " invocation of the anyhit program.  Otherwise, the anyhit program may be invoked"]
    #[doc = " more than once."]
    pub const OPTIX_GEOMETRY_FLAG_REQUIRE_SINGLE_ANYHIT_CALL: OptixGeometryFlags =
        OptixGeometryFlags(2);
}
#[repr(transparent)]
#[doc = " Flags used by #OptixBuildInputTriangleArray::flags"]
#[doc = " and #OptixBuildInput::flag"]
#[doc = " and #OptixBuildInputCustomPrimitiveArray::flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixGeometryFlags(pub ::std::os::raw::c_uint);
impl OptixHitKind {
    #[doc = " Ray hit the triangle on the front face"]
    pub const OPTIX_HIT_KIND_TRIANGLE_FRONT_FACE: OptixHitKind = OptixHitKind(254);
}
impl OptixHitKind {
    #[doc = " Ray hit the triangle on the back face"]
    pub const OPTIX_HIT_KIND_TRIANGLE_BACK_FACE: OptixHitKind = OptixHitKind(255);
}
#[repr(transparent)]
#[doc = " Legacy type: A subset of the hit kinds for built-in primitive intersections."]
#[doc = " It is preferred to use optixGetPrimitiveType(), together with"]
#[doc = " optixIsFrontFaceHit() or optixIsBackFaceHit()."]
#[doc = ""]
#[doc = " \\see #optixGetHitKind()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixHitKind(pub ::std::os::raw::c_uint);
impl OptixIndicesFormat {
    #[doc = " No indices, this format must only be used in combination with triangle soups, i.e., numIndexTriplets must be zero"]
    pub const OPTIX_INDICES_FORMAT_NONE: OptixIndicesFormat = OptixIndicesFormat(0);
}
impl OptixIndicesFormat {
    #[doc = " Three shorts"]
    pub const OPTIX_INDICES_FORMAT_UNSIGNED_SHORT3: OptixIndicesFormat = OptixIndicesFormat(8450);
}
impl OptixIndicesFormat {
    #[doc = " Three ints"]
    pub const OPTIX_INDICES_FORMAT_UNSIGNED_INT3: OptixIndicesFormat = OptixIndicesFormat(8451);
}
#[repr(transparent)]
#[doc = " Format of indices used int #OptixBuildInputTriangleArray::indexFormat."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixIndicesFormat(pub ::std::os::raw::c_uint);
impl OptixVertexFormat {
    #[doc = "< No vertices"]
    pub const OPTIX_VERTEX_FORMAT_NONE: OptixVertexFormat = OptixVertexFormat(0);
}
impl OptixVertexFormat {
    #[doc = "< Vertices are represented by three floats"]
    pub const OPTIX_VERTEX_FORMAT_FLOAT3: OptixVertexFormat = OptixVertexFormat(8481);
}
impl OptixVertexFormat {
    #[doc = "< Vertices are represented by two floats"]
    pub const OPTIX_VERTEX_FORMAT_FLOAT2: OptixVertexFormat = OptixVertexFormat(8482);
}
impl OptixVertexFormat {
    #[doc = "< Vertices are represented by three halves"]
    pub const OPTIX_VERTEX_FORMAT_HALF3: OptixVertexFormat = OptixVertexFormat(8483);
}
impl OptixVertexFormat {
    #[doc = "< Vertices are represented by two halves"]
    pub const OPTIX_VERTEX_FORMAT_HALF2: OptixVertexFormat = OptixVertexFormat(8484);
}
impl OptixVertexFormat {
    pub const OPTIX_VERTEX_FORMAT_SNORM16_3: OptixVertexFormat = OptixVertexFormat(8485);
}
impl OptixVertexFormat {
    pub const OPTIX_VERTEX_FORMAT_SNORM16_2: OptixVertexFormat = OptixVertexFormat(8486);
}
#[repr(transparent)]
#[doc = " Format of vertices used in #OptixBuildInputTriangleArray::vertexFormat."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixVertexFormat(pub ::std::os::raw::c_uint);
impl OptixTransformFormat {
    #[doc = "< no transform, default for zero initialization"]
    pub const OPTIX_TRANSFORM_FORMAT_NONE: OptixTransformFormat = OptixTransformFormat(0);
}
impl OptixTransformFormat {
    #[doc = "< 3x4 row major affine matrix"]
    pub const OPTIX_TRANSFORM_FORMAT_MATRIX_FLOAT12: OptixTransformFormat =
        OptixTransformFormat(8673);
}
#[repr(transparent)]
#[doc = " Format of transform used in #OptixBuildInputTriangleArray::transformFormat."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixTransformFormat(pub ::std::os::raw::c_uint);
#[doc = " Triangle inputs"]
#[doc = ""]
#[doc = " \\see #OptixBuildInput::triangleArray"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixBuildInputTriangleArray {
    #[doc = " Points to host array of device pointers, one per motion step. Host array size must match the number of"]
    #[doc = " motion keys as set in #OptixMotionOptions (or an array of size 1 if OptixMotionOptions::numKeys is set"]
    #[doc = " to 0 or 1). Each per motion key device pointer must point to an array of vertices of the"]
    #[doc = " triangles in the format as described by vertexFormat. The minimum alignment must match the natural"]
    #[doc = " alignment of the type as specified in the vertexFormat, i.e., for OPTIX_VERTEX_FORMAT_FLOATX 4-byte,"]
    #[doc = " for all others a 2-byte alignment. However, an 16-byte stride (and buffer alignment) is recommended for"]
    #[doc = " vertices of format OPTIX_VERTEX_FORMAT_FLOAT3 for GAS build performance."]
    pub vertexBuffers: *const CUdeviceptr,
    #[doc = " Number of vertices in each of buffer in OptixBuildInputTriangleArray::vertexBuffers."]
    pub numVertices: ::std::os::raw::c_uint,
    #[doc = " \\see #OptixVertexFormat"]
    pub vertexFormat: OptixVertexFormat,
    #[doc = " Stride between vertices. If set to zero, vertices are assumed to be tightly"]
    #[doc = " packed and stride is inferred from vertexFormat."]
    pub vertexStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Optional pointer to array of 16 or 32-bit int triplets, one triplet per triangle."]
    #[doc = " The minimum alignment must match the natural alignment of the type as specified in the indexFormat, i.e.,"]
    #[doc = " for OPTIX_INDICES_FORMAT_UNSIGNED_INT3 4-byte and for OPTIX_INDICES_FORMAT_UNSIGNED_SHORT3 a 2-byte alignment."]
    pub indexBuffer: CUdeviceptr,
    #[doc = " Size of array in OptixBuildInputTriangleArray::indexBuffer. For build, needs to be zero if indexBuffer is \\c nullptr."]
    pub numIndexTriplets: ::std::os::raw::c_uint,
    #[doc = " \\see #OptixIndicesFormat"]
    pub indexFormat: OptixIndicesFormat,
    #[doc = " Stride between triplets of indices. If set to zero, indices are assumed to be tightly"]
    #[doc = " packed and stride is inferred from indexFormat."]
    pub indexStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Optional pointer to array of floats"]
    #[doc = " representing a 3x4 row major affine"]
    #[doc = " transformation matrix. This pointer must be a multiple of OPTIX_GEOMETRY_TRANSFORM_BYTE_ALIGNMENT"]
    pub preTransform: CUdeviceptr,
    #[doc = " Array of flags, to specify flags per sbt record,"]
    #[doc = " combinations of OptixGeometryFlags describing the"]
    #[doc = " primitive behavior, size must match numSbtRecords"]
    pub flags: *const ::std::os::raw::c_uint,
    #[doc = " Number of sbt records available to the sbt index offset override."]
    pub numSbtRecords: ::std::os::raw::c_uint,
    #[doc = " Device pointer to per-primitive local sbt index offset buffer. May be NULL."]
    #[doc = " Every entry must be in range [0,numSbtRecords-1]."]
    #[doc = " Size needs to be the number of primitives."]
    pub sbtIndexOffsetBuffer: CUdeviceptr,
    #[doc = " Size of type of the sbt index offset. Needs to be 0, 1, 2 or 4 (8, 16 or 32 bit)."]
    pub sbtIndexOffsetSizeInBytes: ::std::os::raw::c_uint,
    #[doc = " Stride between the index offsets. If set to zero, the offsets are assumed to be tightly"]
    #[doc = " packed and the stride matches the size of the type (sbtIndexOffsetSizeInBytes)."]
    pub sbtIndexOffsetStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Primitive index bias, applied in optixGetPrimitiveIndex()."]
    #[doc = " Sum of primitiveIndexOffset and number of triangles must not overflow 32bits."]
    pub primitiveIndexOffset: ::std::os::raw::c_uint,
    #[doc = " \\see #OptixTransformFormat"]
    pub transformFormat: OptixTransformFormat,
}
impl OptixPrimitiveType {
    #[doc = " Custom primitive."]
    pub const OPTIX_PRIMITIVE_TYPE_CUSTOM: OptixPrimitiveType = OptixPrimitiveType(9472);
}
impl OptixPrimitiveType {
    #[doc = " B-spline curve of degree 2 with circular cross-section."]
    pub const OPTIX_PRIMITIVE_TYPE_ROUND_QUADRATIC_BSPLINE: OptixPrimitiveType =
        OptixPrimitiveType(9473);
}
impl OptixPrimitiveType {
    #[doc = " B-spline curve of degree 3 with circular cross-section."]
    pub const OPTIX_PRIMITIVE_TYPE_ROUND_CUBIC_BSPLINE: OptixPrimitiveType =
        OptixPrimitiveType(9474);
}
impl OptixPrimitiveType {
    #[doc = " Piecewise linear curve with circular cross-section."]
    pub const OPTIX_PRIMITIVE_TYPE_ROUND_LINEAR: OptixPrimitiveType = OptixPrimitiveType(9475);
}
impl OptixPrimitiveType {
    #[doc = " CatmullRom curve with circular cross-section."]
    pub const OPTIX_PRIMITIVE_TYPE_ROUND_CATMULLROM: OptixPrimitiveType = OptixPrimitiveType(9476);
}
impl OptixPrimitiveType {
    #[doc = " Triangle."]
    pub const OPTIX_PRIMITIVE_TYPE_TRIANGLE: OptixPrimitiveType = OptixPrimitiveType(9521);
}
#[repr(transparent)]
#[doc = " Builtin primitive types"]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixPrimitiveType(pub ::std::os::raw::c_uint);
impl OptixPrimitiveTypeFlags {
    #[doc = " Custom primitive."]
    pub const OPTIX_PRIMITIVE_TYPE_FLAGS_CUSTOM: OptixPrimitiveTypeFlags =
        OptixPrimitiveTypeFlags(1);
}
impl OptixPrimitiveTypeFlags {
    #[doc = " B-spline curve of degree 2 with circular cross-section."]
    pub const OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_QUADRATIC_BSPLINE: OptixPrimitiveTypeFlags =
        OptixPrimitiveTypeFlags(2);
}
impl OptixPrimitiveTypeFlags {
    #[doc = " B-spline curve of degree 3 with circular cross-section."]
    pub const OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_CUBIC_BSPLINE: OptixPrimitiveTypeFlags =
        OptixPrimitiveTypeFlags(4);
}
impl OptixPrimitiveTypeFlags {
    #[doc = " Piecewise linear curve with circular cross-section."]
    pub const OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_LINEAR: OptixPrimitiveTypeFlags =
        OptixPrimitiveTypeFlags(8);
}
impl OptixPrimitiveTypeFlags {
    #[doc = " CatmullRom curve with circular cross-section."]
    pub const OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_CATMULLROM: OptixPrimitiveTypeFlags =
        OptixPrimitiveTypeFlags(16);
}
impl OptixPrimitiveTypeFlags {
    #[doc = " Triangle."]
    pub const OPTIX_PRIMITIVE_TYPE_FLAGS_TRIANGLE: OptixPrimitiveTypeFlags =
        OptixPrimitiveTypeFlags(-2147483648);
}
#[repr(transparent)]
#[doc = " Builtin flags may be bitwise combined."]
#[doc = ""]
#[doc = " \\see #OptixPipelineCompileOptions::usesPrimitiveTypeFlags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixPrimitiveTypeFlags(pub ::std::os::raw::c_int);
impl OptixCurveEndcapFlags {
    #[doc = " Default end caps. Round end caps for linear, no end caps for quadratic/cubic."]
    pub const OPTIX_CURVE_ENDCAP_DEFAULT: OptixCurveEndcapFlags = OptixCurveEndcapFlags(0);
}
impl OptixCurveEndcapFlags {
    #[doc = " Flat end caps at both ends of quadratic/cubic curve segments. Not valid for linear."]
    pub const OPTIX_CURVE_ENDCAP_ON: OptixCurveEndcapFlags = OptixCurveEndcapFlags(1);
}
#[repr(transparent)]
#[doc = " Curve end cap types, for non-linear curves"]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixCurveEndcapFlags(pub ::std::os::raw::c_uint);
#[doc = " Curve inputs"]
#[doc = ""]
#[doc = " A curve is a swept surface defined by a 3D spline curve and a varying width (radius). A curve (or \"strand\") of"]
#[doc = " degree d (3=cubic, 2=quadratic, 1=linear) is represented by N > d vertices and N width values, and comprises N - d segments."]
#[doc = " Each segment is defined by d+1 consecutive vertices. Each curve may have a different number of vertices."]
#[doc = ""]
#[doc = " OptiX describes the curve array as a list of curve segments. The primitive id is the segment number."]
#[doc = " It is the user's responsibility to maintain a mapping between curves and curve segments."]
#[doc = " Each index buffer entry i = indexBuffer[primid] specifies the start of a curve segment,"]
#[doc = " represented by d+1 consecutive vertices in the vertex buffer,"]
#[doc = " and d+1 consecutive widths in the width buffer. Width is interpolated the same"]
#[doc = " way vertices are interpolated, that is, using the curve basis."]
#[doc = ""]
#[doc = " Each curves build input has only one SBT record."]
#[doc = " To create curves with different materials in the same BVH, use multiple build inputs."]
#[doc = ""]
#[doc = " \\see #OptixBuildInput::curveArray"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixBuildInputCurveArray {
    #[doc = " Curve degree and basis"]
    #[doc = " \\see #OptixPrimitiveType"]
    pub curveType: OptixPrimitiveType,
    #[doc = " Number of primitives. Each primitive is a polynomial curve segment."]
    pub numPrimitives: ::std::os::raw::c_uint,
    #[doc = " Pointer to host array of device pointers, one per motion step. Host array size must match number of"]
    #[doc = " motion keys as set in #OptixMotionOptions (or an array of size 1 if OptixMotionOptions::numKeys is set"]
    #[doc = " to 1). Each per-motion-key device pointer must point to an array of floats (the vertices of the"]
    #[doc = " curves)."]
    pub vertexBuffers: *const CUdeviceptr,
    #[doc = " Number of vertices in each buffer in vertexBuffers."]
    pub numVertices: ::std::os::raw::c_uint,
    #[doc = " Stride between vertices. If set to zero, vertices are assumed to be tightly"]
    #[doc = " packed and stride is sizeof( float3 )."]
    pub vertexStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Parallel to vertexBuffers: a device pointer per motion step, each with numVertices float values,"]
    #[doc = " specifying the curve width (radius) corresponding to each vertex."]
    pub widthBuffers: *const CUdeviceptr,
    #[doc = " Stride between widths. If set to zero, widths are assumed to be tightly"]
    #[doc = " packed and stride is sizeof( float )."]
    pub widthStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Reserved for future use."]
    pub normalBuffers: *const CUdeviceptr,
    #[doc = " Reserved for future use."]
    pub normalStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Device pointer to array of unsigned ints, one per curve segment."]
    #[doc = " This buffer is required (unlike for OptixBuildInputTriangleArray)."]
    #[doc = " Each index is the start of degree+1 consecutive vertices in vertexBuffers,"]
    #[doc = " and corresponding widths in widthBuffers and normals in normalBuffers."]
    #[doc = " These define a single segment. Size of array is numPrimitives."]
    pub indexBuffer: CUdeviceptr,
    #[doc = " Stride between indices. If set to zero, indices are assumed to be tightly"]
    #[doc = " packed and stride is sizeof( unsigned int )."]
    pub indexStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Combination of OptixGeometryFlags describing the"]
    #[doc = " primitive behavior."]
    pub flag: ::std::os::raw::c_uint,
    #[doc = " Primitive index bias, applied in optixGetPrimitiveIndex()."]
    #[doc = " Sum of primitiveIndexOffset and number of primitives must not overflow 32bits."]
    pub primitiveIndexOffset: ::std::os::raw::c_uint,
    #[doc = " End cap flags, see OptixCurveEndcapFlags"]
    pub endcapFlags: ::std::os::raw::c_uint,
}
#[doc = " AABB inputs"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixAabb {
    #[doc = "< Lower extent in X direction."]
    pub minX: f32,
    #[doc = "< Lower extent in Y direction."]
    pub minY: f32,
    #[doc = "< Lower extent in Z direction."]
    pub minZ: f32,
    #[doc = "< Upper extent in X direction."]
    pub maxX: f32,
    #[doc = "< Upper extent in Y direction."]
    pub maxY: f32,
    #[doc = "< Upper extent in Z direction."]
    pub maxZ: f32,
}
#[doc = " Custom primitive inputs"]
#[doc = ""]
#[doc = " \\see #OptixBuildInput::customPrimitiveArray"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixBuildInputCustomPrimitiveArray {
    #[doc = " Points to host array of device pointers to AABBs (type OptixAabb), one per motion step."]
    #[doc = " Host array size must match number of motion keys as set in OptixMotionOptions (or an array of size 1"]
    #[doc = " if OptixMotionOptions::numKeys is set to 1)."]
    #[doc = " Each device pointer must be a multiple of OPTIX_AABB_BUFFER_BYTE_ALIGNMENT."]
    pub aabbBuffers: *const CUdeviceptr,
    #[doc = " Number of primitives in each buffer (i.e., per motion step) in"]
    #[doc = " #OptixBuildInputCustomPrimitiveArray::aabbBuffers."]
    pub numPrimitives: ::std::os::raw::c_uint,
    #[doc = " Stride between AABBs (per motion key). If set to zero, the aabbs are assumed to be tightly"]
    #[doc = " packed and the stride is assumed to be sizeof( OptixAabb )."]
    #[doc = " If non-zero, the value must be a multiple of OPTIX_AABB_BUFFER_BYTE_ALIGNMENT."]
    pub strideInBytes: ::std::os::raw::c_uint,
    #[doc = " Array of flags, to specify flags per sbt record,"]
    #[doc = " combinations of OptixGeometryFlags describing the"]
    #[doc = " primitive behavior, size must match numSbtRecords"]
    pub flags: *const ::std::os::raw::c_uint,
    #[doc = " Number of sbt records available to the sbt index offset override."]
    pub numSbtRecords: ::std::os::raw::c_uint,
    #[doc = " Device pointer to per-primitive local sbt index offset buffer. May be NULL."]
    #[doc = " Every entry must be in range [0,numSbtRecords-1]."]
    #[doc = " Size needs to be the number of primitives."]
    pub sbtIndexOffsetBuffer: CUdeviceptr,
    #[doc = " Size of type of the sbt index offset. Needs to be 0, 1, 2 or 4 (8, 16 or 32 bit)."]
    pub sbtIndexOffsetSizeInBytes: ::std::os::raw::c_uint,
    #[doc = " Stride between the index offsets. If set to zero, the offsets are assumed to be tightly"]
    #[doc = " packed and the stride matches the size of the type (sbtIndexOffsetSizeInBytes)."]
    pub sbtIndexOffsetStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Primitive index bias, applied in optixGetPrimitiveIndex()."]
    #[doc = " Sum of primitiveIndexOffset and number of primitive must not overflow 32bits."]
    pub primitiveIndexOffset: ::std::os::raw::c_uint,
}
#[doc = " Instance and instance pointer inputs"]
#[doc = ""]
#[doc = " \\see #OptixBuildInput::instanceArray"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixBuildInputInstanceArray {
    #[doc = " If OptixBuildInput::type is OPTIX_BUILD_INPUT_TYPE_INSTANCE_POINTERS instances and"]
    #[doc = " aabbs should be interpreted as arrays of pointers instead of arrays of structs."]
    #[doc = ""]
    #[doc = " This pointer must be a multiple of OPTIX_INSTANCE_BYTE_ALIGNMENT if"]
    #[doc = " OptixBuildInput::type is OPTIX_BUILD_INPUT_TYPE_INSTANCES. The array elements must"]
    #[doc = " be a multiple of OPTIX_INSTANCE_BYTE_ALIGNMENT if OptixBuildInput::type is"]
    #[doc = " OPTIX_BUILD_INPUT_TYPE_INSTANCE_POINTERS."]
    pub instances: CUdeviceptr,
    #[doc = " Number of elements in #OptixBuildInputInstanceArray::instances."]
    pub numInstances: ::std::os::raw::c_uint,
}
impl OptixBuildInputType {
    #[doc = " Triangle inputs. \\see #OptixBuildInputTriangleArray"]
    pub const OPTIX_BUILD_INPUT_TYPE_TRIANGLES: OptixBuildInputType = OptixBuildInputType(8513);
}
impl OptixBuildInputType {
    #[doc = " Custom primitive inputs. \\see #OptixBuildInputCustomPrimitiveArray"]
    pub const OPTIX_BUILD_INPUT_TYPE_CUSTOM_PRIMITIVES: OptixBuildInputType =
        OptixBuildInputType(8514);
}
impl OptixBuildInputType {
    #[doc = " Instance inputs. \\see #OptixBuildInputInstanceArray"]
    pub const OPTIX_BUILD_INPUT_TYPE_INSTANCES: OptixBuildInputType = OptixBuildInputType(8515);
}
impl OptixBuildInputType {
    #[doc = " Instance pointer inputs. \\see #OptixBuildInputInstanceArray"]
    pub const OPTIX_BUILD_INPUT_TYPE_INSTANCE_POINTERS: OptixBuildInputType =
        OptixBuildInputType(8516);
}
impl OptixBuildInputType {
    #[doc = " Curve inputs. \\see #OptixBuildInputCurveArray"]
    pub const OPTIX_BUILD_INPUT_TYPE_CURVES: OptixBuildInputType = OptixBuildInputType(8517);
}
#[repr(transparent)]
#[doc = " Enum to distinguish the different build input types."]
#[doc = ""]
#[doc = " \\see #OptixBuildInput::type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixBuildInputType(pub ::std::os::raw::c_uint);
#[doc = " Build inputs."]
#[doc = ""]
#[doc = " All of them support motion and the size of the data arrays needs to match the number of motion steps"]
#[doc = ""]
#[doc = " \\see #optixAccelComputeMemoryUsage(), #optixAccelBuild()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixBuildInput {
    #[doc = " The type of the build input."]
    pub type_: OptixBuildInputType,
    pub __bindgen_anon_1: OptixBuildInput__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OptixBuildInput__bindgen_ty_1 {
    #[doc = " Triangle inputs."]
    pub triangleArray: OptixBuildInputTriangleArray,
    #[doc = " Curve inputs."]
    pub curveArray: OptixBuildInputCurveArray,
    #[doc = " Custom primitive inputs."]
    pub customPrimitiveArray: OptixBuildInputCustomPrimitiveArray,
    #[doc = " Instance and instance pointer inputs."]
    pub instanceArray: OptixBuildInputInstanceArray,
    pub pad: [::std::os::raw::c_char; 1024usize],
}
impl OptixInstanceFlags {
    #[doc = " No special flag set"]
    pub const OPTIX_INSTANCE_FLAG_NONE: OptixInstanceFlags = OptixInstanceFlags(0);
}
impl OptixInstanceFlags {
    #[doc = " Prevent triangles from getting culled due to their orientation."]
    #[doc = " Effectively ignores ray flags"]
    #[doc = " OPTIX_RAY_FLAG_CULL_BACK_FACING_TRIANGLES and OPTIX_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES."]
    pub const OPTIX_INSTANCE_FLAG_DISABLE_TRIANGLE_FACE_CULLING: OptixInstanceFlags =
        OptixInstanceFlags(1);
}
impl OptixInstanceFlags {
    #[doc = " Flip triangle orientation."]
    #[doc = " This affects front/backface culling as well as the reported face in case of a hit."]
    pub const OPTIX_INSTANCE_FLAG_FLIP_TRIANGLE_FACING: OptixInstanceFlags = OptixInstanceFlags(2);
}
impl OptixInstanceFlags {
    #[doc = " Disable anyhit programs for all geometries of the instance."]
    #[doc = " Can be overridden by OPTIX_RAY_FLAG_ENFORCE_ANYHIT."]
    #[doc = " This flag is mutually exclusive with OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT."]
    pub const OPTIX_INSTANCE_FLAG_DISABLE_ANYHIT: OptixInstanceFlags = OptixInstanceFlags(4);
}
impl OptixInstanceFlags {
    #[doc = " Enables anyhit programs for all geometries of the instance."]
    #[doc = " Overrides OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT"]
    #[doc = " Can be overridden by OPTIX_RAY_FLAG_DISABLE_ANYHIT."]
    #[doc = " This flag is mutually exclusive with OPTIX_INSTANCE_FLAG_DISABLE_ANYHIT."]
    pub const OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT: OptixInstanceFlags = OptixInstanceFlags(8);
}
#[repr(transparent)]
#[doc = " Flags set on the #OptixInstance::flags."]
#[doc = ""]
#[doc = " These can be or'ed together to combine multiple flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixInstanceFlags(pub ::std::os::raw::c_uint);
#[doc = " Instances"]
#[doc = ""]
#[doc = " \\see #OptixBuildInputInstanceArray::instances"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixInstance {
    #[doc = " affine object-to-world transformation as 3x4 matrix in row-major layout"]
    pub transform: [f32; 12usize],
    #[doc = " Application supplied ID. The maximal ID can be queried using OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCE_ID."]
    pub instanceId: ::std::os::raw::c_uint,
    #[doc = " SBT record offset.  Will only be used for instances of geometry acceleration structure (GAS) objects."]
    #[doc = " Needs to be set to 0 for instances of instance acceleration structure (IAS) objects. The maximal SBT offset"]
    #[doc = " can be queried using OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCE_SBT_OFFSET."]
    pub sbtOffset: ::std::os::raw::c_uint,
    #[doc = " Visibility mask. If rayMask & instanceMask == 0 the instance is culled. The number of available bits can be"]
    #[doc = " queried using OPTIX_DEVICE_PROPERTY_LIMIT_NUM_BITS_INSTANCE_VISIBILITY_MASK."]
    pub visibilityMask: ::std::os::raw::c_uint,
    #[doc = " Any combination of OptixInstanceFlags is allowed."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = " Set with an OptixTraversableHandle."]
    pub traversableHandle: OptixTraversableHandle,
    #[doc = " round up to 80-byte, to ensure 16-byte alignment"]
    pub pad: [::std::os::raw::c_uint; 2usize],
}
impl OptixBuildFlags {
    #[doc = " No special flags set."]
    pub const OPTIX_BUILD_FLAG_NONE: OptixBuildFlags = OptixBuildFlags(0);
}
impl OptixBuildFlags {
    #[doc = " Allow updating the build with new vertex positions with subsequent calls to"]
    #[doc = " optixAccelBuild."]
    pub const OPTIX_BUILD_FLAG_ALLOW_UPDATE: OptixBuildFlags = OptixBuildFlags(1);
}
impl OptixBuildFlags {
    #[doc = " Allow updating the build with new vertex positions with subsequent calls to"]
    #[doc = " optixAccelBuild."]
    pub const OPTIX_BUILD_FLAG_ALLOW_COMPACTION: OptixBuildFlags = OptixBuildFlags(2);
}
impl OptixBuildFlags {
    #[doc = " Allow updating the build with new vertex positions with subsequent calls to"]
    #[doc = " optixAccelBuild."]
    pub const OPTIX_BUILD_FLAG_PREFER_FAST_TRACE: OptixBuildFlags = OptixBuildFlags(4);
}
impl OptixBuildFlags {
    #[doc = " Allow updating the build with new vertex positions with subsequent calls to"]
    #[doc = " optixAccelBuild."]
    pub const OPTIX_BUILD_FLAG_PREFER_FAST_BUILD: OptixBuildFlags = OptixBuildFlags(8);
}
impl OptixBuildFlags {
    #[doc = " Allow random access to build input vertices"]
    #[doc = " See optixGetTriangleVertexData"]
    #[doc = "     optixGetLinearCurveVertexData"]
    #[doc = "     optixGetQuadraticBSplineVertexData"]
    #[doc = "     optixGetCubicBSplineVertexData"]
    #[doc = "     optixGetCatmullRomVertexData"]
    pub const OPTIX_BUILD_FLAG_ALLOW_RANDOM_VERTEX_ACCESS: OptixBuildFlags = OptixBuildFlags(16);
}
impl OptixBuildFlags {
    #[doc = " Allow random access to instances"]
    #[doc = " See optixGetInstanceTraversableFromIAS"]
    pub const OPTIX_BUILD_FLAG_ALLOW_RANDOM_INSTANCE_ACCESS: OptixBuildFlags = OptixBuildFlags(32);
}
#[repr(transparent)]
#[doc = " Builder Options"]
#[doc = ""]
#[doc = " Used for #OptixAccelBuildOptions::buildFlags. Can be or'ed together."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixBuildFlags(pub ::std::os::raw::c_uint);
impl OptixBuildOperation {
    #[doc = " Perform a full build operation"]
    pub const OPTIX_BUILD_OPERATION_BUILD: OptixBuildOperation = OptixBuildOperation(8545);
}
impl OptixBuildOperation {
    #[doc = " Perform an update using new bounds"]
    pub const OPTIX_BUILD_OPERATION_UPDATE: OptixBuildOperation = OptixBuildOperation(8546);
}
#[repr(transparent)]
#[doc = " Enum to specify the acceleration build operation."]
#[doc = ""]
#[doc = " Used in OptixAccelBuildOptions, which is then passed to optixAccelBuild and"]
#[doc = " optixAccelComputeMemoryUsage, this enum indicates whether to do a build or an update"]
#[doc = " of the acceleration structure."]
#[doc = ""]
#[doc = " Acceleration structure updates utilize the same acceleration structure, but with"]
#[doc = " updated bounds.  Updates are typically much faster than builds, however, large"]
#[doc = " perturbations can degrade the quality of the acceleration structure."]
#[doc = ""]
#[doc = " \\see #optixAccelComputeMemoryUsage(), #optixAccelBuild(), #OptixAccelBuildOptions"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixBuildOperation(pub ::std::os::raw::c_uint);
impl OptixMotionFlags {
    pub const OPTIX_MOTION_FLAG_NONE: OptixMotionFlags = OptixMotionFlags(0);
}
impl OptixMotionFlags {
    pub const OPTIX_MOTION_FLAG_START_VANISH: OptixMotionFlags = OptixMotionFlags(1);
}
impl OptixMotionFlags {
    pub const OPTIX_MOTION_FLAG_END_VANISH: OptixMotionFlags = OptixMotionFlags(2);
}
#[repr(transparent)]
#[doc = " Enum to specify motion flags."]
#[doc = ""]
#[doc = " \\see #OptixMotionOptions::flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixMotionFlags(pub ::std::os::raw::c_uint);
#[doc = " Motion options"]
#[doc = ""]
#[doc = " \\see #OptixAccelBuildOptions::motionOptions, #OptixMatrixMotionTransform::motionOptions,"]
#[doc = "      #OptixSRTMotionTransform::motionOptions"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixMotionOptions {
    #[doc = " If numKeys > 1, motion is enabled. timeBegin,"]
    #[doc = " timeEnd and flags are all ignored when motion is disabled."]
    pub numKeys: ::std::os::raw::c_ushort,
    #[doc = " Combinations of #OptixMotionFlags"]
    pub flags: ::std::os::raw::c_ushort,
    #[doc = " Point in time where motion starts."]
    pub timeBegin: f32,
    #[doc = " Point in time where motion ends."]
    pub timeEnd: f32,
}
#[doc = " Build options for acceleration structures."]
#[doc = ""]
#[doc = " \\see #optixAccelComputeMemoryUsage(), #optixAccelBuild()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixAccelBuildOptions {
    #[doc = " Combinations of OptixBuildFlags"]
    pub buildFlags: ::std::os::raw::c_uint,
    #[doc = " If OPTIX_BUILD_OPERATION_UPDATE the output buffer is assumed to contain the result"]
    #[doc = " of a full build with OPTIX_BUILD_FLAG_ALLOW_UPDATE set and using the same number of"]
    #[doc = " primitives.  It is updated incrementally to reflect the current position of the"]
    #[doc = " primitives."]
    pub operation: OptixBuildOperation,
    #[doc = " Options for motion."]
    pub motionOptions: OptixMotionOptions,
}
#[doc = " Struct for querying builder allocation requirements."]
#[doc = ""]
#[doc = " Once queried the sizes should be used to allocate device memory of at least these sizes."]
#[doc = ""]
#[doc = " \\see #optixAccelComputeMemoryUsage()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixAccelBufferSizes {
    #[doc = " The size in bytes required for the outputBuffer parameter to optixAccelBuild when"]
    #[doc = " doing a build (OPTIX_BUILD_OPERATION_BUILD)."]
    pub outputSizeInBytes: usize,
    #[doc = " The size in bytes required for the tempBuffer parameter to optixAccelBuild when"]
    #[doc = " doing a build (OPTIX_BUILD_OPERATION_BUILD)."]
    pub tempSizeInBytes: usize,
    #[doc = " The size in bytes required for the tempBuffer parameter to optixAccelBuild"]
    #[doc = " when doing an update (OPTIX_BUILD_OPERATION_UPDATE).  This value can be different"]
    #[doc = " than tempSizeInBytes used for a full build.  Only non-zero if"]
    #[doc = " OPTIX_BUILD_FLAG_ALLOW_UPDATE flag is set in OptixAccelBuildOptions."]
    pub tempUpdateSizeInBytes: usize,
}
impl OptixAccelPropertyType {
    #[doc = " Size of a compacted acceleration structure. The device pointer points to a uint64."]
    pub const OPTIX_PROPERTY_TYPE_COMPACTED_SIZE: OptixAccelPropertyType =
        OptixAccelPropertyType(8577);
}
impl OptixAccelPropertyType {
    #[doc = " OptixAabb * numMotionSteps"]
    pub const OPTIX_PROPERTY_TYPE_AABBS: OptixAccelPropertyType = OptixAccelPropertyType(8578);
}
#[repr(transparent)]
#[doc = " Properties which can be emitted during acceleration structure build."]
#[doc = ""]
#[doc = " \\see #OptixAccelEmitDesc::type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixAccelPropertyType(pub ::std::os::raw::c_uint);
#[doc = " Specifies a type and output destination for emitted post-build properties."]
#[doc = ""]
#[doc = " \\see #optixAccelBuild()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixAccelEmitDesc {
    #[doc = " Output buffer for the properties"]
    pub result: CUdeviceptr,
    #[doc = " Requested property"]
    pub type_: OptixAccelPropertyType,
}
#[doc = " Used to store information related to relocation of acceleration structures."]
#[doc = ""]
#[doc = " \\see #optixAccelGetRelocationInfo(), #optixAccelCheckRelocationCompatibility(), #optixAccelRelocate()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixAccelRelocationInfo {
    #[doc = " Opaque data, used internally, should not be modified"]
    pub info: [::std::os::raw::c_ulonglong; 4usize],
}
#[doc = " Static transform"]
#[doc = ""]
#[doc = " The device address of instances of this type must be a multiple of OPTIX_TRANSFORM_BYTE_ALIGNMENT."]
#[doc = ""]
#[doc = " \\see #optixConvertPointerToTraversableHandle()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixStaticTransform {
    #[doc = " The traversable transformed by this transformation"]
    pub child: OptixTraversableHandle,
    #[doc = " Padding to make the transformations 16 byte aligned"]
    pub pad: [::std::os::raw::c_uint; 2usize],
    #[doc = " Affine object-to-world transformation as 3x4 matrix in row-major layout"]
    pub transform: [f32; 12usize],
    #[doc = " Affine world-to-object transformation as 3x4 matrix in row-major layout"]
    #[doc = " Must be the inverse of the transform matrix"]
    pub invTransform: [f32; 12usize],
}
#[doc = " Represents a matrix motion transformation."]
#[doc = ""]
#[doc = " The device address of instances of this type must be a multiple of OPTIX_TRANSFORM_BYTE_ALIGNMENT."]
#[doc = ""]
#[doc = " This struct, as defined here, handles only N=2 motion keys due to the fixed array length of its transform member."]
#[doc = " The following example shows how to create instances for an arbitrary number N of motion keys:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " float matrixData[N][12];"]
#[doc = " ... // setup matrixData"]
#[doc = ""]
#[doc = " size_t transformSizeInBytes = sizeof( OptixMatrixMotionTransform ) + ( N-2 ) * 12 * sizeof( float );"]
#[doc = " OptixMatrixMotionTransform* matrixMoptionTransform = (OptixMatrixMotionTransform*) malloc( transformSizeInBytes );"]
#[doc = " memset( matrixMoptionTransform, 0, transformSizeInBytes );"]
#[doc = ""]
#[doc = " ... // setup other members of matrixMoptionTransform"]
#[doc = " matrixMoptionTransform->motionOptions.numKeys/// = N;"]
#[doc = " memcpy( matrixMoptionTransform->transform, matrixData, N * 12 * sizeof( float ) );"]
#[doc = ""]
#[doc = " ... // copy matrixMoptionTransform to device memory"]
#[doc = " free( matrixMoptionTransform )"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\see #optixConvertPointerToTraversableHandle()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixMatrixMotionTransform {
    #[doc = " The traversable that is transformed by this transformation"]
    pub child: OptixTraversableHandle,
    #[doc = " The motion options for this transformation"]
    pub motionOptions: OptixMotionOptions,
    #[doc = " Padding to make the transformation 16 byte aligned"]
    pub pad: [::std::os::raw::c_uint; 3usize],
    #[doc = " Affine object-to-world transformation as 3x4 matrix in row-major layout"]
    pub transform: [[f32; 12usize]; 2usize],
}
#[doc = " defines another translation that is applied after the rotation. Typically, this translation includes"]
#[doc = " the inverse translation from the matrix S to reverse the translation for the pivot point for R."]
#[doc = ""]
#[doc = " To obtain the effective transformation at time t, the elements of the components of S, R, and T will be interpolated"]
#[doc = " linearly. The components are then multiplied to obtain the combined transformation C = T * R * S. The transformation"]
#[doc = " C is the effective object-to-world transformations at time t, and C^(-1) is the effective world-to-object"]
#[doc = " transformation at time t."]
#[doc = ""]
#[doc = " \\see #OptixSRTMotionTransform::srtData, #optixConvertPointerToTraversableHandle()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixSRTData {
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub sx: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub a: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub b: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub pvx: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub sy: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub c: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub pvy: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub sz: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub pvz: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub qx: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub qy: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub qz: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub qw: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub tx: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub ty: f32,
    #[doc = " \\name Parameters describing the SRT transformation"]
    #[doc = " @{"]
    pub tz: f32,
}
#[doc = " Represents an SRT motion transformation."]
#[doc = ""]
#[doc = " The device address of instances of this type must be a multiple of OPTIX_TRANSFORM_BYTE_ALIGNMENT."]
#[doc = ""]
#[doc = " This struct, as defined here, handles only N=2 motion keys due to the fixed array length of its srtData member."]
#[doc = " The following example shows how to create instances for an arbitrary number N of motion keys:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " OptixSRTData srtData[N];"]
#[doc = " ... // setup srtData"]
#[doc = ""]
#[doc = " size_t transformSizeInBytes = sizeof( OptixSRTMotionTransform ) + ( N-2 ) * sizeof( OptixSRTData );"]
#[doc = " OptixSRTMotionTransform* srtMotionTransform = (OptixSRTMotionTransform*) malloc( transformSizeInBytes );"]
#[doc = " memset( srtMotionTransform, 0, transformSizeInBytes );"]
#[doc = ""]
#[doc = " ... // setup other members of srtMotionTransform"]
#[doc = " srtMotionTransform->motionOptions.numKeys   = N;"]
#[doc = " memcpy( srtMotionTransform->srtData, srtData, N * sizeof( OptixSRTData ) );"]
#[doc = ""]
#[doc = " ... // copy srtMotionTransform to device memory"]
#[doc = " free( srtMotionTransform )"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\see #optixConvertPointerToTraversableHandle()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixSRTMotionTransform {
    #[doc = " The traversable transformed by this transformation"]
    pub child: OptixTraversableHandle,
    #[doc = " The motion options for this transformation"]
    pub motionOptions: OptixMotionOptions,
    #[doc = " Padding to make the SRT data 16 byte aligned"]
    pub pad: [::std::os::raw::c_uint; 3usize],
    #[doc = " The actual SRT data describing the transformation"]
    pub srtData: [OptixSRTData; 2usize],
}
impl OptixTraversableType {
    #[doc = " Static transforms. \\see #OptixStaticTransform"]
    pub const OPTIX_TRAVERSABLE_TYPE_STATIC_TRANSFORM: OptixTraversableType =
        OptixTraversableType(8641);
}
impl OptixTraversableType {
    #[doc = " Matrix motion transform. \\see #OptixMatrixMotionTransform"]
    pub const OPTIX_TRAVERSABLE_TYPE_MATRIX_MOTION_TRANSFORM: OptixTraversableType =
        OptixTraversableType(8642);
}
impl OptixTraversableType {
    #[doc = " SRT motion transform. \\see #OptixSRTMotionTransform"]
    pub const OPTIX_TRAVERSABLE_TYPE_SRT_MOTION_TRANSFORM: OptixTraversableType =
        OptixTraversableType(8643);
}
#[repr(transparent)]
#[doc = " Traversable Handles"]
#[doc = ""]
#[doc = " \\see #optixConvertPointerToTraversableHandle()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixTraversableType(pub ::std::os::raw::c_uint);
impl OptixPixelFormat {
    #[doc = "< two halves, XY"]
    pub const OPTIX_PIXEL_FORMAT_HALF2: OptixPixelFormat = OptixPixelFormat(8711);
}
impl OptixPixelFormat {
    #[doc = "< three halves, RGB"]
    pub const OPTIX_PIXEL_FORMAT_HALF3: OptixPixelFormat = OptixPixelFormat(8705);
}
impl OptixPixelFormat {
    #[doc = "< four halves, RGBA"]
    pub const OPTIX_PIXEL_FORMAT_HALF4: OptixPixelFormat = OptixPixelFormat(8706);
}
impl OptixPixelFormat {
    #[doc = "< two floats, XY"]
    pub const OPTIX_PIXEL_FORMAT_FLOAT2: OptixPixelFormat = OptixPixelFormat(8712);
}
impl OptixPixelFormat {
    #[doc = "< three floats, RGB"]
    pub const OPTIX_PIXEL_FORMAT_FLOAT3: OptixPixelFormat = OptixPixelFormat(8707);
}
impl OptixPixelFormat {
    #[doc = "< four floats, RGBA"]
    pub const OPTIX_PIXEL_FORMAT_FLOAT4: OptixPixelFormat = OptixPixelFormat(8708);
}
impl OptixPixelFormat {
    #[doc = "< three unsigned chars, RGB"]
    pub const OPTIX_PIXEL_FORMAT_UCHAR3: OptixPixelFormat = OptixPixelFormat(8709);
}
impl OptixPixelFormat {
    #[doc = "< four unsigned chars, RGBA"]
    pub const OPTIX_PIXEL_FORMAT_UCHAR4: OptixPixelFormat = OptixPixelFormat(8710);
}
#[repr(transparent)]
#[doc = " Pixel formats used by the denoiser."]
#[doc = ""]
#[doc = " \\see #OptixImage2D::format"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixPixelFormat(pub ::std::os::raw::c_uint);
#[doc = " Image descriptor used by the denoiser."]
#[doc = ""]
#[doc = " \\see #optixDenoiserInvoke(), #optixDenoiserComputeIntensity()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixImage2D {
    #[doc = " Pointer to the actual pixel data."]
    pub data: CUdeviceptr,
    #[doc = " Width of the image (in pixels)"]
    pub width: ::std::os::raw::c_uint,
    #[doc = " Height of the image (in pixels)"]
    pub height: ::std::os::raw::c_uint,
    #[doc = " Stride between subsequent rows of the image (in bytes)."]
    pub rowStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Stride between subsequent pixels of the image (in bytes)."]
    #[doc = " For now, only 0 or the value that corresponds to a dense packing of pixels (no gaps) is supported."]
    pub pixelStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Pixel format."]
    pub format: OptixPixelFormat,
}
impl OptixDenoiserModelKind {
    #[doc = " Use the built-in model appropriate for low dynamic range input."]
    pub const OPTIX_DENOISER_MODEL_KIND_LDR: OptixDenoiserModelKind = OptixDenoiserModelKind(8994);
}
impl OptixDenoiserModelKind {
    #[doc = " Use the built-in model appropriate for high dynamic range input."]
    pub const OPTIX_DENOISER_MODEL_KIND_HDR: OptixDenoiserModelKind = OptixDenoiserModelKind(8995);
}
impl OptixDenoiserModelKind {
    #[doc = " Use the built-in model appropriate for high dynamic range input and support for AOVs"]
    pub const OPTIX_DENOISER_MODEL_KIND_AOV: OptixDenoiserModelKind = OptixDenoiserModelKind(8996);
}
impl OptixDenoiserModelKind {
    #[doc = " Use the built-in model appropriate for high dynamic range input, temporally stable"]
    pub const OPTIX_DENOISER_MODEL_KIND_TEMPORAL: OptixDenoiserModelKind =
        OptixDenoiserModelKind(8997);
}
impl OptixDenoiserModelKind {
    #[doc = " Use the built-in model appropriate for high dynamic range input and support for AOVs, temporally stable"]
    pub const OPTIX_DENOISER_MODEL_KIND_TEMPORAL_AOV: OptixDenoiserModelKind =
        OptixDenoiserModelKind(8998);
}
#[repr(transparent)]
#[doc = " Model kind used by the denoiser."]
#[doc = ""]
#[doc = " \\see #optixDenoiserCreate"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixDenoiserModelKind(pub ::std::os::raw::c_uint);
#[doc = " Options used by the denoiser"]
#[doc = ""]
#[doc = " \\see #optixDenoiserCreate()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixDenoiserOptions {
    pub guideAlbedo: ::std::os::raw::c_uint,
    pub guideNormal: ::std::os::raw::c_uint,
}
#[doc = " Guide layer for the denoiser"]
#[doc = ""]
#[doc = " \\see #optixDenoiserInvoke()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixDenoiserGuideLayer {
    pub albedo: OptixImage2D,
    pub normal: OptixImage2D,
    pub flow: OptixImage2D,
}
#[doc = " Input/Output layers for the denoiser"]
#[doc = ""]
#[doc = " \\see #optixDenoiserInvoke()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixDenoiserLayer {
    pub input: OptixImage2D,
    pub previousOutput: OptixImage2D,
    pub output: OptixImage2D,
}
#[doc = " Various parameters used by the denoiser"]
#[doc = ""]
#[doc = " \\see #optixDenoiserInvoke()"]
#[doc = " \\see #optixDenoiserComputeIntensity()"]
#[doc = " \\see #optixDenoiserComputeAverageColor()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixDenoiserParams {
    #[doc = " alpha denoise mode:"]
    #[doc = " 0 Copy alpha (if present) from input layer, no denoising."]
    #[doc = " 1 Denoise alpha separately. In AOV model kinds, treat alpha like an AOV."]
    #[doc = " 2 In AOV model kinds, full denoise pass with alpha (slower than mode 1)."]
    pub denoiseAlpha: ::std::os::raw::c_uint,
    #[doc = " average log intensity of input image (default null pointer). points to a single float."]
    #[doc = " with the default (null pointer) denoised results will not be optimal for very dark or"]
    #[doc = " bright input images."]
    pub hdrIntensity: CUdeviceptr,
    #[doc = " blend factor."]
    #[doc = " If set to 0 the output is 100% of the denoised input. If set to 1, the output is 100% of"]
    #[doc = " the unmodified input. Values between 0 and 1 will linearly interpolate between the denoised"]
    #[doc = " and unmodified input."]
    pub blendFactor: f32,
    #[doc = " this parameter is used when the OPTIX_DENOISER_MODEL_KIND_AOV model kind is set."]
    #[doc = " average log color of input image, separate for RGB channels (default null pointer)."]
    #[doc = " points to three floats. with the default (null pointer) denoised results will not be"]
    #[doc = " optimal."]
    pub hdrAverageColor: CUdeviceptr,
}
#[doc = " Various sizes related to the denoiser."]
#[doc = ""]
#[doc = " \\see #optixDenoiserComputeMemoryResources()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixDenoiserSizes {
    pub stateSizeInBytes: usize,
    pub withOverlapScratchSizeInBytes: usize,
    pub withoutOverlapScratchSizeInBytes: usize,
    pub overlapWindowSizeInPixels: ::std::os::raw::c_uint,
}
impl OptixRayFlags {
    #[doc = " No change from the behavior configured for the individual AS."]
    pub const OPTIX_RAY_FLAG_NONE: OptixRayFlags = OptixRayFlags(0);
}
impl OptixRayFlags {
    #[doc = " Disables anyhit programs for the ray."]
    #[doc = " Overrides OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT."]
    #[doc = " This flag is mutually exclusive with OPTIX_RAY_FLAG_ENFORCE_ANYHIT,"]
    #[doc = " OPTIX_RAY_FLAG_CULL_DISABLED_ANYHIT, OPTIX_RAY_FLAG_CULL_ENFORCED_ANYHIT."]
    pub const OPTIX_RAY_FLAG_DISABLE_ANYHIT: OptixRayFlags = OptixRayFlags(1);
}
impl OptixRayFlags {
    #[doc = " Forces anyhit program execution for the ray."]
    #[doc = " Overrides OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT as well as OPTIX_INSTANCE_FLAG_DISABLE_ANYHIT."]
    #[doc = " This flag is mutually exclusive with OPTIX_RAY_FLAG_DISABLE_ANYHIT,"]
    #[doc = " OPTIX_RAY_FLAG_CULL_DISABLED_ANYHIT, OPTIX_RAY_FLAG_CULL_ENFORCED_ANYHIT."]
    pub const OPTIX_RAY_FLAG_ENFORCE_ANYHIT: OptixRayFlags = OptixRayFlags(2);
}
impl OptixRayFlags {
    #[doc = " Terminates the ray after the first hit and executes"]
    #[doc = " the closesthit program of that hit."]
    pub const OPTIX_RAY_FLAG_TERMINATE_ON_FIRST_HIT: OptixRayFlags = OptixRayFlags(4);
}
impl OptixRayFlags {
    #[doc = " Disables closesthit programs for the ray, but still executes miss program in case of a miss."]
    pub const OPTIX_RAY_FLAG_DISABLE_CLOSESTHIT: OptixRayFlags = OptixRayFlags(8);
}
impl OptixRayFlags {
    #[doc = " Do not intersect triangle back faces"]
    #[doc = " (respects a possible face change due to instance flag"]
    #[doc = " OPTIX_INSTANCE_FLAG_FLIP_TRIANGLE_FACING)."]
    #[doc = " This flag is mutually exclusive with OPTIX_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES."]
    pub const OPTIX_RAY_FLAG_CULL_BACK_FACING_TRIANGLES: OptixRayFlags = OptixRayFlags(16);
}
impl OptixRayFlags {
    #[doc = " Do not intersect triangle front faces"]
    #[doc = " (respects a possible face change due to instance flag"]
    #[doc = " OPTIX_INSTANCE_FLAG_FLIP_TRIANGLE_FACING)."]
    #[doc = " This flag is mutually exclusive with OPTIX_RAY_FLAG_CULL_BACK_FACING_TRIANGLES."]
    pub const OPTIX_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES: OptixRayFlags = OptixRayFlags(32);
}
impl OptixRayFlags {
    #[doc = " Do not intersect geometry which disables anyhit programs"]
    #[doc = " (due to setting geometry flag OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT or"]
    #[doc = " instance flag OPTIX_INSTANCE_FLAG_DISABLE_ANYHIT)."]
    #[doc = " This flag is mutually exclusive with OPTIX_RAY_FLAG_CULL_ENFORCED_ANYHIT,"]
    #[doc = " OPTIX_RAY_FLAG_ENFORCE_ANYHIT, OPTIX_RAY_FLAG_DISABLE_ANYHIT."]
    pub const OPTIX_RAY_FLAG_CULL_DISABLED_ANYHIT: OptixRayFlags = OptixRayFlags(64);
}
impl OptixRayFlags {
    #[doc = " Do not intersect geometry which have an enabled anyhit program"]
    #[doc = " (due to not setting geometry flag OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT or"]
    #[doc = " setting instance flag OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT)."]
    #[doc = " This flag is mutually exclusive with OPTIX_RAY_FLAG_CULL_DISABLED_ANYHIT,"]
    #[doc = " OPTIX_RAY_FLAG_ENFORCE_ANYHIT, OPTIX_RAY_FLAG_DISABLE_ANYHIT."]
    pub const OPTIX_RAY_FLAG_CULL_ENFORCED_ANYHIT: OptixRayFlags = OptixRayFlags(128);
}
#[repr(transparent)]
#[doc = " Ray flags passed to the device function #optixTrace().  These affect the behavior of"]
#[doc = " traversal per invocation."]
#[doc = ""]
#[doc = " \\see #optixTrace()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixRayFlags(pub ::std::os::raw::c_uint);
impl OptixTransformType {
    #[doc = "< Not a transformation"]
    pub const OPTIX_TRANSFORM_TYPE_NONE: OptixTransformType = OptixTransformType(0);
}
impl OptixTransformType {
    #[doc = "< \\see #OptixStaticTransform"]
    pub const OPTIX_TRANSFORM_TYPE_STATIC_TRANSFORM: OptixTransformType = OptixTransformType(1);
}
impl OptixTransformType {
    #[doc = "< \\see #OptixMatrixMotionTransform"]
    pub const OPTIX_TRANSFORM_TYPE_MATRIX_MOTION_TRANSFORM: OptixTransformType =
        OptixTransformType(2);
}
impl OptixTransformType {
    #[doc = "< \\see #OptixSRTMotionTransform"]
    pub const OPTIX_TRANSFORM_TYPE_SRT_MOTION_TRANSFORM: OptixTransformType = OptixTransformType(3);
}
impl OptixTransformType {
    #[doc = "< \\see #OptixInstance"]
    pub const OPTIX_TRANSFORM_TYPE_INSTANCE: OptixTransformType = OptixTransformType(4);
}
#[repr(transparent)]
#[doc = " Transform"]
#[doc = ""]
#[doc = " OptixTransformType is used by the device function #optixGetTransformTypeFromHandle() to"]
#[doc = " determine the type of the OptixTraversableHandle returned from"]
#[doc = " optixGetTransformListHandle()."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixTransformType(pub ::std::os::raw::c_uint);
impl OptixTraversableGraphFlags {
    #[doc = "  Used to signal that any traversable graphs is valid."]
    #[doc = "  This flag is mutually exclusive with all other flags."]
    pub const OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_ANY: OptixTraversableGraphFlags =
        OptixTraversableGraphFlags(0);
}
impl OptixTraversableGraphFlags {
    #[doc = "  Used to signal that a traversable graph of a single Geometry Acceleration"]
    #[doc = "  Structure (GAS) without any transforms is valid. This flag may be combined with"]
    #[doc = "  other flags except for OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_ANY."]
    pub const OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_GAS: OptixTraversableGraphFlags =
        OptixTraversableGraphFlags(1);
}
impl OptixTraversableGraphFlags {
    #[doc = "  Used to signal that a traversable graph of a single Instance Acceleration"]
    #[doc = "  Structure (IAS) directly connected to Geometry Acceleration Structure (GAS)"]
    #[doc = "  traversables without transform traversables in between is valid.  This flag may"]
    #[doc = "  be combined with other flags except for OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_ANY."]
    pub const OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_LEVEL_INSTANCING:
        OptixTraversableGraphFlags = OptixTraversableGraphFlags(2);
}
#[repr(transparent)]
#[doc = " Specifies the set of valid traversable graphs that may be"]
#[doc = " passed to invocation of #optixTrace(). Flags may be bitwise combined."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixTraversableGraphFlags(pub ::std::os::raw::c_uint);
impl OptixCompileOptimizationLevel {
    #[doc = " Default is to run all optimizations"]
    pub const OPTIX_COMPILE_OPTIMIZATION_DEFAULT: OptixCompileOptimizationLevel =
        OptixCompileOptimizationLevel(0);
}
impl OptixCompileOptimizationLevel {
    #[doc = " No optimizations"]
    pub const OPTIX_COMPILE_OPTIMIZATION_LEVEL_0: OptixCompileOptimizationLevel =
        OptixCompileOptimizationLevel(9024);
}
impl OptixCompileOptimizationLevel {
    #[doc = " Some optimizations"]
    pub const OPTIX_COMPILE_OPTIMIZATION_LEVEL_1: OptixCompileOptimizationLevel =
        OptixCompileOptimizationLevel(9025);
}
impl OptixCompileOptimizationLevel {
    #[doc = " Most optimizations"]
    pub const OPTIX_COMPILE_OPTIMIZATION_LEVEL_2: OptixCompileOptimizationLevel =
        OptixCompileOptimizationLevel(9026);
}
impl OptixCompileOptimizationLevel {
    #[doc = " All optimizations"]
    pub const OPTIX_COMPILE_OPTIMIZATION_LEVEL_3: OptixCompileOptimizationLevel =
        OptixCompileOptimizationLevel(9027);
}
#[repr(transparent)]
#[doc = " Optimization levels"]
#[doc = ""]
#[doc = " \\see #OptixModuleCompileOptions::optLevel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixCompileOptimizationLevel(pub ::std::os::raw::c_uint);
impl OptixCompileDebugLevel {
    #[doc = " Default currently is minimal"]
    pub const OPTIX_COMPILE_DEBUG_LEVEL_DEFAULT: OptixCompileDebugLevel = OptixCompileDebugLevel(0);
}
impl OptixCompileDebugLevel {
    #[doc = " No debug information"]
    pub const OPTIX_COMPILE_DEBUG_LEVEL_NONE: OptixCompileDebugLevel = OptixCompileDebugLevel(9040);
}
impl OptixCompileDebugLevel {
    #[doc = " Generate information that does not impact performance."]
    #[doc = " Note this replaces OPTIX_COMPILE_DEBUG_LEVEL_LINEINFO."]
    pub const OPTIX_COMPILE_DEBUG_LEVEL_MINIMAL: OptixCompileDebugLevel =
        OptixCompileDebugLevel(9041);
}
impl OptixCompileDebugLevel {
    #[doc = " Generate some debug information with slight performance cost"]
    pub const OPTIX_COMPILE_DEBUG_LEVEL_MODERATE: OptixCompileDebugLevel =
        OptixCompileDebugLevel(9043);
}
impl OptixCompileDebugLevel {
    #[doc = " Generate full debug information"]
    pub const OPTIX_COMPILE_DEBUG_LEVEL_FULL: OptixCompileDebugLevel = OptixCompileDebugLevel(9042);
}
#[repr(transparent)]
#[doc = " Debug levels"]
#[doc = ""]
#[doc = " \\see #OptixModuleCompileOptions::debugLevel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixCompileDebugLevel(pub ::std::os::raw::c_uint);
impl OptixModuleCompileState {
    #[doc = " No OptixTask objects have started"]
    pub const OPTIX_MODULE_COMPILE_STATE_NOT_STARTED: OptixModuleCompileState =
        OptixModuleCompileState(9056);
}
impl OptixModuleCompileState {
    #[doc = " Started, but not all OptixTask objects have completed. No detected failures."]
    pub const OPTIX_MODULE_COMPILE_STATE_STARTED: OptixModuleCompileState =
        OptixModuleCompileState(9057);
}
impl OptixModuleCompileState {
    #[doc = " Not all OptixTask objects have completed, but at least one has failed."]
    pub const OPTIX_MODULE_COMPILE_STATE_IMPENDING_FAILURE: OptixModuleCompileState =
        OptixModuleCompileState(9058);
}
impl OptixModuleCompileState {
    #[doc = " All OptixTask objects have completed, and at least one has failed"]
    pub const OPTIX_MODULE_COMPILE_STATE_FAILED: OptixModuleCompileState =
        OptixModuleCompileState(9059);
}
impl OptixModuleCompileState {
    #[doc = " All OptixTask objects have completed. The OptixModule is ready to be used."]
    pub const OPTIX_MODULE_COMPILE_STATE_COMPLETED: OptixModuleCompileState =
        OptixModuleCompileState(9060);
}
#[repr(transparent)]
#[doc = " Module compilation state."]
#[doc = ""]
#[doc = " \\see #optixModuleGetCompilationState(), #optixModuleCreateFromPTXWithTasks()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixModuleCompileState(pub ::std::os::raw::c_uint);
#[doc = " Struct for specifying specializations for pipelineParams as specified in"]
#[doc = " OptixPipelineCompileOptions::pipelineLaunchParamsVariableName."]
#[doc = ""]
#[doc = " The bound values are supposed to represent a constant value in the"]
#[doc = " pipelineParams. OptiX will attempt to locate all loads from the pipelineParams and"]
#[doc = " correlate them to the appropriate bound value, but there are cases where OptiX cannot"]
#[doc = " safely or reliably do this. For example if the pointer to the pipelineParams is passed"]
#[doc = " as an argument to a non-inline function or the offset of the load to the"]
#[doc = " pipelineParams cannot be statically determined (e.g. accessed in a loop). No module"]
#[doc = " should rely on the value being specialized in order to work correctly.  The values in"]
#[doc = " the pipelineParams specified on optixLaunch should match the bound value. If"]
#[doc = " validation mode is enabled on the context, OptiX will verify that the bound values"]
#[doc = " specified matches the values in pipelineParams specified to optixLaunch."]
#[doc = ""]
#[doc = " These values are compiled in to the module as constants. Once the constants are"]
#[doc = " inserted into the code, an optimization pass will be run that will attempt to"]
#[doc = " propagate the constants and remove unreachable code."]
#[doc = ""]
#[doc = " If caching is enabled, changes in these values will result in newly compiled modules."]
#[doc = ""]
#[doc = " The pipelineParamOffset and sizeInBytes must be within the bounds of the"]
#[doc = " pipelineParams variable. OPTIX_ERROR_INVALID_VALUE will be returned from"]
#[doc = " optixModuleCreateFromPTX otherwise."]
#[doc = ""]
#[doc = " If more than one bound value overlaps or the size of a bound value is equal to 0,"]
#[doc = " an OPTIX_ERROR_INVALID_VALUE will be returned from optixModuleCreateFromPTX."]
#[doc = ""]
#[doc = " The same set of bound values do not need to be used for all modules in a pipeline, but"]
#[doc = " overlapping values between modules must have the same value."]
#[doc = " OPTIX_ERROR_INVALID_VALUE will be returned from optixPipelineCreate otherwise."]
#[doc = ""]
#[doc = " \\see #OptixModuleCompileOptions"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixModuleCompileBoundValueEntry {
    pub pipelineParamOffsetInBytes: usize,
    pub sizeInBytes: usize,
    pub boundValuePtr: *const ::std::os::raw::c_void,
    pub annotation: *const ::std::os::raw::c_char,
}
impl OptixPayloadTypeID {
    pub const OPTIX_PAYLOAD_TYPE_DEFAULT: OptixPayloadTypeID = OptixPayloadTypeID(0);
}
impl OptixPayloadTypeID {
    pub const OPTIX_PAYLOAD_TYPE_ID_0: OptixPayloadTypeID = OptixPayloadTypeID(1);
}
impl OptixPayloadTypeID {
    pub const OPTIX_PAYLOAD_TYPE_ID_1: OptixPayloadTypeID = OptixPayloadTypeID(2);
}
impl OptixPayloadTypeID {
    pub const OPTIX_PAYLOAD_TYPE_ID_2: OptixPayloadTypeID = OptixPayloadTypeID(4);
}
impl OptixPayloadTypeID {
    pub const OPTIX_PAYLOAD_TYPE_ID_3: OptixPayloadTypeID = OptixPayloadTypeID(8);
}
impl OptixPayloadTypeID {
    pub const OPTIX_PAYLOAD_TYPE_ID_4: OptixPayloadTypeID = OptixPayloadTypeID(16);
}
impl OptixPayloadTypeID {
    pub const OPTIX_PAYLOAD_TYPE_ID_5: OptixPayloadTypeID = OptixPayloadTypeID(32);
}
impl OptixPayloadTypeID {
    pub const OPTIX_PAYLOAD_TYPE_ID_6: OptixPayloadTypeID = OptixPayloadTypeID(64);
}
impl OptixPayloadTypeID {
    pub const OPTIX_PAYLOAD_TYPE_ID_7: OptixPayloadTypeID = OptixPayloadTypeID(128);
}
#[repr(transparent)]
#[doc = " Payload type identifiers."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixPayloadTypeID(pub ::std::os::raw::c_uint);
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_NONE: OptixPayloadSemantics =
        OptixPayloadSemantics(0);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_READ: OptixPayloadSemantics =
        OptixPayloadSemantics(1);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_WRITE: OptixPayloadSemantics =
        OptixPayloadSemantics(2);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_READ_WRITE: OptixPayloadSemantics =
        OptixPayloadSemantics(3);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_CH_NONE: OptixPayloadSemantics = OptixPayloadSemantics(0);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_CH_READ: OptixPayloadSemantics = OptixPayloadSemantics(4);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_CH_WRITE: OptixPayloadSemantics = OptixPayloadSemantics(8);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_CH_READ_WRITE: OptixPayloadSemantics =
        OptixPayloadSemantics(12);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_MS_NONE: OptixPayloadSemantics = OptixPayloadSemantics(0);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_MS_READ: OptixPayloadSemantics = OptixPayloadSemantics(16);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_MS_WRITE: OptixPayloadSemantics = OptixPayloadSemantics(32);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_MS_READ_WRITE: OptixPayloadSemantics =
        OptixPayloadSemantics(48);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_AH_NONE: OptixPayloadSemantics = OptixPayloadSemantics(0);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_AH_READ: OptixPayloadSemantics = OptixPayloadSemantics(64);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_AH_WRITE: OptixPayloadSemantics = OptixPayloadSemantics(128);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_AH_READ_WRITE: OptixPayloadSemantics =
        OptixPayloadSemantics(192);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_IS_NONE: OptixPayloadSemantics = OptixPayloadSemantics(0);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_IS_READ: OptixPayloadSemantics = OptixPayloadSemantics(256);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_IS_WRITE: OptixPayloadSemantics = OptixPayloadSemantics(512);
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_IS_READ_WRITE: OptixPayloadSemantics =
        OptixPayloadSemantics(768);
}
#[repr(transparent)]
#[doc = " Semantic flags for a single payload word."]
#[doc = ""]
#[doc = " Used to specify the semantics of a payload word per shader type."]
#[doc = " \"read\":  Shader of this type may read the payload word."]
#[doc = " \"write\": Shader of this type may write the payload word."]
#[doc = ""]
#[doc = " \"trace_caller_write\": Shaders may consume the value of the payload word passed to optixTrace by the caller."]
#[doc = " \"trace_caller_read\": The caller to optixTrace may read the payload word after the call to optixTrace."]
#[doc = ""]
#[doc = " Semantics can be bitwise combined."]
#[doc = " Combining \"read\" and \"write\" is equivalent to specifying \"read_write\"."]
#[doc = " A payload needs to be writable by the caller or at least one shader type."]
#[doc = " A payload needs to be readable by the caller or at least one shader type after a being writable."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixPayloadSemantics(pub ::std::os::raw::c_uint);
#[doc = " Specifies a single payload type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixPayloadType {
    #[doc = " The number of 32b words the payload of this type holds"]
    pub numPayloadValues: ::std::os::raw::c_uint,
    #[doc = " Points to host array of payload word semantics, size must match numPayloadValues"]
    pub payloadSemantics: *const ::std::os::raw::c_uint,
}
#[doc = " Compilation options for module"]
#[doc = ""]
#[doc = " \\see #optixModuleCreateFromPTX()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixModuleCompileOptions {
    #[doc = " Maximum number of registers allowed when compiling to SASS."]
    #[doc = " Set to 0 for no explicit limit. May vary within a pipeline."]
    pub maxRegisterCount: ::std::os::raw::c_int,
    #[doc = " Optimization level. May vary within a pipeline."]
    pub optLevel: OptixCompileOptimizationLevel,
    #[doc = " Generate debug information."]
    pub debugLevel: OptixCompileDebugLevel,
    #[doc = " Ignored if numBoundValues is set to 0"]
    pub boundValues: *const OptixModuleCompileBoundValueEntry,
    #[doc = " set to 0 if unused"]
    pub numBoundValues: ::std::os::raw::c_uint,
    #[doc = " The number of different payload types available for compilation."]
    #[doc = " Must be zero if OptixPipelineCompileOptions::numPayloadValues is not zero."]
    pub numPayloadTypes: ::std::os::raw::c_uint,
    #[doc = " Points to host array of payload type definitions, size must match numPayloadTypes"]
    pub payloadTypes: *mut OptixPayloadType,
}
impl OptixProgramGroupKind {
    #[doc = " Program group containing a raygen (RG) program"]
    #[doc = " \\see #OptixProgramGroupSingleModule, #OptixProgramGroupDesc::raygen"]
    pub const OPTIX_PROGRAM_GROUP_KIND_RAYGEN: OptixProgramGroupKind = OptixProgramGroupKind(9249);
}
impl OptixProgramGroupKind {
    #[doc = " Program group containing a miss (MS) program"]
    #[doc = " \\see #OptixProgramGroupSingleModule, #OptixProgramGroupDesc::miss"]
    pub const OPTIX_PROGRAM_GROUP_KIND_MISS: OptixProgramGroupKind = OptixProgramGroupKind(9250);
}
impl OptixProgramGroupKind {
    #[doc = " Program group containing an exception (EX) program"]
    #[doc = " \\see OptixProgramGroupHitgroup, #OptixProgramGroupDesc::exception"]
    pub const OPTIX_PROGRAM_GROUP_KIND_EXCEPTION: OptixProgramGroupKind =
        OptixProgramGroupKind(9251);
}
impl OptixProgramGroupKind {
    #[doc = " Program group containing an intersection (IS), any hit (AH), and/or closest hit (CH) program"]
    #[doc = " \\see #OptixProgramGroupSingleModule, #OptixProgramGroupDesc::hitgroup"]
    pub const OPTIX_PROGRAM_GROUP_KIND_HITGROUP: OptixProgramGroupKind =
        OptixProgramGroupKind(9252);
}
impl OptixProgramGroupKind {
    #[doc = " Program group containing a direct (DC) or continuation (CC) callable program"]
    #[doc = " \\see OptixProgramGroupCallables, #OptixProgramGroupDesc::callables"]
    pub const OPTIX_PROGRAM_GROUP_KIND_CALLABLES: OptixProgramGroupKind =
        OptixProgramGroupKind(9253);
}
#[repr(transparent)]
#[doc = " Distinguishes different kinds of program groups."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixProgramGroupKind(pub ::std::os::raw::c_uint);
impl OptixProgramGroupFlags {
    #[doc = " Currently there are no flags"]
    pub const OPTIX_PROGRAM_GROUP_FLAGS_NONE: OptixProgramGroupFlags = OptixProgramGroupFlags(0);
}
#[repr(transparent)]
#[doc = " Flags for program groups"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixProgramGroupFlags(pub ::std::os::raw::c_uint);
#[doc = " Program group representing a single module."]
#[doc = ""]
#[doc = " Used for raygen, miss, and exception programs. In case of raygen and exception programs, module and entry"]
#[doc = " function name need to be valid. For miss programs, module and entry function name might both be \\c nullptr."]
#[doc = ""]
#[doc = " \\see #OptixProgramGroupDesc::raygen, #OptixProgramGroupDesc::miss, #OptixProgramGroupDesc::exception"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixProgramGroupSingleModule {
    #[doc = " Module holding single program."]
    pub module: OptixModule,
    #[doc = " Entry function name of the single program."]
    pub entryFunctionName: *const ::std::os::raw::c_char,
}
#[doc = " Program group representing the hitgroup."]
#[doc = ""]
#[doc = " For each of the three program types, module and entry function name might both be \\c nullptr."]
#[doc = ""]
#[doc = " \\see #OptixProgramGroupDesc::hitgroup"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixProgramGroupHitgroup {
    #[doc = " Module holding the closest hit (CH) program."]
    pub moduleCH: OptixModule,
    #[doc = " Entry function name of the closest hit (CH) program."]
    pub entryFunctionNameCH: *const ::std::os::raw::c_char,
    #[doc = " Module holding the any hit (AH) program."]
    pub moduleAH: OptixModule,
    #[doc = " Entry function name of the any hit (AH) program."]
    pub entryFunctionNameAH: *const ::std::os::raw::c_char,
    #[doc = " Module holding the intersection (Is) program."]
    pub moduleIS: OptixModule,
    #[doc = " Entry function name of the intersection (IS) program."]
    pub entryFunctionNameIS: *const ::std::os::raw::c_char,
}
#[doc = " Program group representing callables."]
#[doc = ""]
#[doc = " Module and entry function name need to be valid for at least one of the two callables."]
#[doc = ""]
#[doc = " \\see ##OptixProgramGroupDesc::callables"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixProgramGroupCallables {
    #[doc = " Module holding the direct callable (DC) program."]
    pub moduleDC: OptixModule,
    #[doc = " Entry function name of the direct callable (DC) program."]
    pub entryFunctionNameDC: *const ::std::os::raw::c_char,
    #[doc = " Module holding the continuation callable (CC) program."]
    pub moduleCC: OptixModule,
    #[doc = " Entry function name of the continuation callable (CC) program."]
    pub entryFunctionNameCC: *const ::std::os::raw::c_char,
}
#[doc = " Descriptor for program groups."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixProgramGroupDesc {
    #[doc = " The kind of program group."]
    pub kind: OptixProgramGroupKind,
    #[doc = " See #OptixProgramGroupFlags"]
    pub flags: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: OptixProgramGroupDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OptixProgramGroupDesc__bindgen_ty_1 {
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_RAYGEN"]
    pub raygen: OptixProgramGroupSingleModule,
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_MISS"]
    pub miss: OptixProgramGroupSingleModule,
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_EXCEPTION"]
    pub exception: OptixProgramGroupSingleModule,
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_CALLABLES"]
    pub callables: OptixProgramGroupCallables,
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_HITGROUP"]
    pub hitgroup: OptixProgramGroupHitgroup,
}
#[doc = " Program group options"]
#[doc = ""]
#[doc = " \\see #optixProgramGroupCreate()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixProgramGroupOptions {
    #[doc = " Specifies the payload type of this program group."]
    #[doc = " All programs in the group must support the payload type"]
    #[doc = " (Program support for a type is specified by calling"]
    #[doc = " \\see #optixSetPayloadTypes or otherwise all types specified in"]
    #[doc = " \\see #OptixModuleCompileOptions are supported)."]
    #[doc = " If a program is not available for the requested payload type,"]
    #[doc = " optixProgramGroupCreate returns OPTIX_ERROR_PAYLOAD_TYPE_MISMATCH."]
    #[doc = " If the payloadType is left zero, a unique type is deduced."]
    #[doc = " The payload type can be uniquely deduced if there is exactly one payload type"]
    #[doc = " for which all programs in the group are available."]
    #[doc = " If the payload type could not be deduced uniquely"]
    #[doc = " optixProgramGroupCreate returns OPTIX_ERROR_PAYLOAD_TYPE_RESOLUTION_FAILED."]
    pub payloadType: *mut OptixPayloadType,
}
impl OptixExceptionCodes {
    #[doc = " Stack overflow of the continuation stack."]
    #[doc = " no exception details."]
    pub const OPTIX_EXCEPTION_CODE_STACK_OVERFLOW: OptixExceptionCodes = OptixExceptionCodes(-1);
}
impl OptixExceptionCodes {
    #[doc = " The trace depth is exceeded."]
    #[doc = " no exception details."]
    pub const OPTIX_EXCEPTION_CODE_TRACE_DEPTH_EXCEEDED: OptixExceptionCodes =
        OptixExceptionCodes(-2);
}
impl OptixExceptionCodes {
    #[doc = " The traversal depth is exceeded."]
    #[doc = " Exception details:"]
    #[doc = "     optixGetTransformListSize()"]
    #[doc = "     optixGetTransformListHandle()"]
    pub const OPTIX_EXCEPTION_CODE_TRAVERSAL_DEPTH_EXCEEDED: OptixExceptionCodes =
        OptixExceptionCodes(-3);
}
impl OptixExceptionCodes {
    #[doc = " Traversal encountered an invalid traversable type."]
    #[doc = " Exception details:"]
    #[doc = "     optixGetTransformListSize()"]
    #[doc = "     optixGetTransformListHandle()"]
    #[doc = "     optixGetExceptionInvalidTraversable()"]
    pub const OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_TRAVERSABLE: OptixExceptionCodes =
        OptixExceptionCodes(-5);
}
impl OptixExceptionCodes {
    #[doc = " The miss SBT record index is out of bounds"]
    #[doc = " A miss SBT record index is valid within the range [0, OptixShaderBindingTable::missRecordCount) (See optixLaunch)"]
    #[doc = " Exception details:"]
    #[doc = "     optixGetExceptionInvalidSbtOffset()"]
    pub const OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_MISS_SBT: OptixExceptionCodes =
        OptixExceptionCodes(-6);
}
impl OptixExceptionCodes {
    #[doc = "     sbt-geometry-acceleration-structure-index (See optixGetSbtGASIndex),"]
    #[doc = "     sbt-stride-from-trace-call and sbt-offset-from-trace-call (See optixTrace)"]
    #[doc = ""]
    #[doc = " sbt-index = sbt-instance-offset + (sbt-geometry-acceleration-structure-index * sbt-stride-from-trace-call) + sbt-offset-from-trace-call"]
    #[doc = ""]
    #[doc = " Exception details:"]
    #[doc = "     optixGetTransformListSize()"]
    #[doc = "     optixGetTransformListHandle()"]
    #[doc = "     optixGetExceptionInvalidSbtOffset()"]
    #[doc = "     optixGetSbtGASIndex()"]
    pub const OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_HIT_SBT: OptixExceptionCodes =
        OptixExceptionCodes(-7);
}
impl OptixExceptionCodes {
    #[doc = " The shader encountered an unsupported primitive type (See OptixPipelineCompileOptions::usesPrimitiveTypeFlags)."]
    #[doc = " no exception details."]
    pub const OPTIX_EXCEPTION_CODE_UNSUPPORTED_PRIMITIVE_TYPE: OptixExceptionCodes =
        OptixExceptionCodes(-8);
}
impl OptixExceptionCodes {
    #[doc = " The shader encountered a call to optixTrace with at least"]
    #[doc = " one of the float arguments being inf or nan."]
    #[doc = " Exception details:"]
    #[doc = "     optixGetExceptionInvalidRay()"]
    pub const OPTIX_EXCEPTION_CODE_INVALID_RAY: OptixExceptionCodes = OptixExceptionCodes(-9);
}
impl OptixExceptionCodes {
    #[doc = " The shader encountered a call to either optixDirectCall or optixCallableCall"]
    #[doc = " where the argument count does not match the parameter count of the callable"]
    #[doc = " program which is called."]
    #[doc = " Exception details:"]
    #[doc = "     optixGetExceptionParameterMismatch"]
    pub const OPTIX_EXCEPTION_CODE_CALLABLE_PARAMETER_MISMATCH: OptixExceptionCodes =
        OptixExceptionCodes(-10);
}
impl OptixExceptionCodes {
    #[doc = " The invoked builtin IS does not match the current GAS"]
    pub const OPTIX_EXCEPTION_CODE_BUILTIN_IS_MISMATCH: OptixExceptionCodes =
        OptixExceptionCodes(-11);
}
impl OptixExceptionCodes {
    #[doc = " Tried to call a callable program using an SBT offset that is larger"]
    #[doc = " than the number of passed in callable SBT records."]
    #[doc = " Exception details:"]
    #[doc = "     optixGetExceptionInvalidSbtOffset()"]
    pub const OPTIX_EXCEPTION_CODE_CALLABLE_INVALID_SBT: OptixExceptionCodes =
        OptixExceptionCodes(-12);
}
impl OptixExceptionCodes {
    #[doc = " Tried to call a direct callable using an SBT offset of a record that"]
    #[doc = " was built from a program group that did not include a direct callable."]
    pub const OPTIX_EXCEPTION_CODE_CALLABLE_NO_DC_SBT_RECORD: OptixExceptionCodes =
        OptixExceptionCodes(-13);
}
impl OptixExceptionCodes {
    #[doc = " Tried to call a continuation callable using an SBT offset of a record"]
    #[doc = " that was built from a program group that did not include a continuation callable."]
    pub const OPTIX_EXCEPTION_CODE_CALLABLE_NO_CC_SBT_RECORD: OptixExceptionCodes =
        OptixExceptionCodes(-14);
}
impl OptixExceptionCodes {
    #[doc = " Tried to directly traverse a single gas while single gas traversable graphs are not enabled"]
    #[doc = "   (see OptixTraversableGraphFlags::OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_GAS)."]
    #[doc = " Exception details:"]
    #[doc = "     optixGetTransformListSize()"]
    #[doc = "     optixGetTransformListHandle()"]
    #[doc = "     optixGetExceptionInvalidTraversable()"]
    pub const OPTIX_EXCEPTION_CODE_UNSUPPORTED_SINGLE_LEVEL_GAS: OptixExceptionCodes =
        OptixExceptionCodes(-15);
}
impl OptixExceptionCodes {
    #[doc = " argument passed to an optix call is"]
    #[doc = " not within an acceptable range of values."]
    pub const OPTIX_EXCEPTION_CODE_INVALID_VALUE_ARGUMENT_0: OptixExceptionCodes =
        OptixExceptionCodes(-16);
}
impl OptixExceptionCodes {
    #[doc = " argument passed to an optix call is"]
    #[doc = " not within an acceptable range of values."]
    pub const OPTIX_EXCEPTION_CODE_INVALID_VALUE_ARGUMENT_1: OptixExceptionCodes =
        OptixExceptionCodes(-17);
}
impl OptixExceptionCodes {
    #[doc = " argument passed to an optix call is"]
    #[doc = " not within an acceptable range of values."]
    pub const OPTIX_EXCEPTION_CODE_INVALID_VALUE_ARGUMENT_2: OptixExceptionCodes =
        OptixExceptionCodes(-18);
}
impl OptixExceptionCodes {
    #[doc = " Tried to access data on an AS without random data access support (See OptixBuildFlags)."]
    pub const OPTIX_EXCEPTION_CODE_UNSUPPORTED_DATA_ACCESS: OptixExceptionCodes =
        OptixExceptionCodes(-32);
}
impl OptixExceptionCodes {
    #[doc = " The program payload type doesn't match the trace payload type."]
    pub const OPTIX_EXCEPTION_CODE_PAYLOAD_TYPE_MISMATCH: OptixExceptionCodes =
        OptixExceptionCodes(-33);
}
#[repr(transparent)]
#[doc = " The following values are used to indicate which exception was thrown."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixExceptionCodes(pub ::std::os::raw::c_int);
impl OptixExceptionFlags {
    #[doc = " No exception are enabled."]
    pub const OPTIX_EXCEPTION_FLAG_NONE: OptixExceptionFlags = OptixExceptionFlags(0);
}
impl OptixExceptionFlags {
    #[doc = " Enables exceptions check related to the continuation stack."]
    pub const OPTIX_EXCEPTION_FLAG_STACK_OVERFLOW: OptixExceptionFlags = OptixExceptionFlags(1);
}
impl OptixExceptionFlags {
    #[doc = " Enables exceptions check related to trace depth."]
    pub const OPTIX_EXCEPTION_FLAG_TRACE_DEPTH: OptixExceptionFlags = OptixExceptionFlags(2);
}
impl OptixExceptionFlags {
    #[doc = " Enables user exceptions via optixThrowException(). This flag must be specified for all modules in a pipeline"]
    #[doc = " if any module calls optixThrowException()."]
    pub const OPTIX_EXCEPTION_FLAG_USER: OptixExceptionFlags = OptixExceptionFlags(4);
}
impl OptixExceptionFlags {
    #[doc = " Enables various exceptions check related to traversal."]
    pub const OPTIX_EXCEPTION_FLAG_DEBUG: OptixExceptionFlags = OptixExceptionFlags(8);
}
#[repr(transparent)]
#[doc = " Exception flags."]
#[doc = ""]
#[doc = " \\see #OptixPipelineCompileOptions::exceptionFlags, #OptixExceptionCodes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixExceptionFlags(pub ::std::os::raw::c_uint);
#[doc = " Compilation options for all modules of a pipeline."]
#[doc = ""]
#[doc = " Similar to #OptixModuleCompileOptions, but these options here need to be equal for all modules of a pipeline."]
#[doc = ""]
#[doc = " \\see #optixModuleCreateFromPTX(), #optixPipelineCreate()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixPipelineCompileOptions {
    #[doc = " Boolean value indicating whether motion blur could be used"]
    pub usesMotionBlur: ::std::os::raw::c_int,
    #[doc = " Traversable graph bitfield. See OptixTraversableGraphFlags"]
    pub traversableGraphFlags: ::std::os::raw::c_uint,
    #[doc = " How much storage, in 32b words, to make available for the payload, [0..32]"]
    #[doc = " Must be zero if numPayloadTypes is not zero."]
    pub numPayloadValues: ::std::os::raw::c_int,
    #[doc = " How much storage, in 32b words, to make available for the attributes. The"]
    #[doc = " minimum number is 2. Values below that will automatically be changed to 2. [2..8]"]
    pub numAttributeValues: ::std::os::raw::c_int,
    #[doc = " A bitmask of OptixExceptionFlags indicating which exceptions are enabled."]
    pub exceptionFlags: ::std::os::raw::c_uint,
    #[doc = " The name of the pipeline parameter variable.  If 0, no pipeline parameter"]
    #[doc = " will be available. This will be ignored if the launch param variable was"]
    #[doc = " optimized out or was not found in the modules linked to the pipeline."]
    pub pipelineLaunchParamsVariableName: *const ::std::os::raw::c_char,
    #[doc = " Bit field enabling primitive types. See OptixPrimitiveTypeFlags."]
    #[doc = " Setting to zero corresponds to enabling OPTIX_PRIMITIVE_TYPE_FLAGS_CUSTOM and OPTIX_PRIMITIVE_TYPE_FLAGS_TRIANGLE."]
    pub usesPrimitiveTypeFlags: ::std::os::raw::c_uint,
}
#[doc = " Link options for a pipeline"]
#[doc = ""]
#[doc = " \\see #optixPipelineCreate()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixPipelineLinkOptions {
    #[doc = " Maximum trace recursion depth. 0 means a ray generation program can be"]
    #[doc = " launched, but can't trace any rays. The maximum allowed value is 31."]
    pub maxTraceDepth: ::std::os::raw::c_uint,
    #[doc = " Generate debug information."]
    pub debugLevel: OptixCompileDebugLevel,
}
#[doc = " Describes the shader binding table (SBT)"]
#[doc = ""]
#[doc = " \\see #optixLaunch()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixShaderBindingTable {
    #[doc = " Device address of the SBT record of the ray gen program to start launch at. The address must be a multiple of"]
    #[doc = " OPTIX_SBT_RECORD_ALIGNMENT."]
    pub raygenRecord: CUdeviceptr,
    #[doc = " Device address of the SBT record of the exception program. The address must be a multiple of"]
    #[doc = " OPTIX_SBT_RECORD_ALIGNMENT."]
    pub exceptionRecord: CUdeviceptr,
    #[doc = " Arrays of SBT records for miss programs. The base address and the stride must be a multiple of"]
    #[doc = " OPTIX_SBT_RECORD_ALIGNMENT."]
    #[doc = " @{"]
    pub missRecordBase: CUdeviceptr,
    pub missRecordStrideInBytes: ::std::os::raw::c_uint,
    pub missRecordCount: ::std::os::raw::c_uint,
    #[doc = " Arrays of SBT records for hit groups. The base address and the stride must be a multiple of"]
    #[doc = " OPTIX_SBT_RECORD_ALIGNMENT."]
    #[doc = " @{"]
    pub hitgroupRecordBase: CUdeviceptr,
    pub hitgroupRecordStrideInBytes: ::std::os::raw::c_uint,
    pub hitgroupRecordCount: ::std::os::raw::c_uint,
    #[doc = " Arrays of SBT records for callable programs. If the base address is not null, the stride and count must not be"]
    #[doc = " zero. If the base address is null, then the count needs to zero. The base address and the stride must be a"]
    #[doc = " multiple of OPTIX_SBT_RECORD_ALIGNMENT."]
    #[doc = " @{"]
    pub callablesRecordBase: CUdeviceptr,
    pub callablesRecordStrideInBytes: ::std::os::raw::c_uint,
    pub callablesRecordCount: ::std::os::raw::c_uint,
}
#[doc = " Describes the stack size requirements of a program group."]
#[doc = ""]
#[doc = " \\see optixProgramGroupGetStackSize()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixStackSizes {
    #[doc = " Continuation stack size of RG programs in bytes"]
    pub cssRG: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of MS programs in bytes"]
    pub cssMS: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of CH programs in bytes"]
    pub cssCH: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of AH programs in bytes"]
    pub cssAH: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of IS programs in bytes"]
    pub cssIS: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of CC programs in bytes"]
    pub cssCC: ::std::os::raw::c_uint,
    #[doc = " Direct stack size of DC programs in bytes"]
    pub dssDC: ::std::os::raw::c_uint,
}
impl OptixQueryFunctionTableOptions {
    #[doc = " Placeholder (there are no options yet)"]
    pub const OPTIX_QUERY_FUNCTION_TABLE_OPTION_DUMMY: OptixQueryFunctionTableOptions =
        OptixQueryFunctionTableOptions(0);
}
#[repr(transparent)]
#[doc = " Options that can be passed to \\c optixQueryFunctionTable()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OptixQueryFunctionTableOptions(pub ::std::os::raw::c_uint);
#[doc = " Type of the function \\c optixQueryFunctionTable()"]
pub type OptixQueryFunctionTable_t = ::std::option::Option<
    unsafe extern "C" fn(
        abiId: ::std::os::raw::c_int,
        numOptions: ::std::os::raw::c_uint,
        arg1: *mut OptixQueryFunctionTableOptions,
        arg2: *mut *const ::std::os::raw::c_void,
        functionTable: *mut ::std::os::raw::c_void,
        sizeOfTable: usize,
    ) -> OptixResult,
>;
#[doc = " Specifies the options for retrieving an intersection program for a built-in primitive type."]
#[doc = " The primitive type must not be OPTIX_PRIMITIVE_TYPE_CUSTOM."]
#[doc = ""]
#[doc = " \\see #optixBuiltinISModuleGet()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixBuiltinISOptions {
    pub builtinISModuleType: OptixPrimitiveType,
    #[doc = " Boolean value indicating whether vertex motion blur is used (but not motion transform blur)."]
    pub usesMotionBlur: ::std::os::raw::c_int,
    #[doc = " Build flags, see OptixBuildFlags."]
    pub buildFlags: ::std::os::raw::c_uint,
    #[doc = " End cap properties of curves, see OptixCurveEndcapFlags, 0 for non-curve types."]
    pub curveEndcapFlags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
extern "C" {
    #[doc = " Returns a string containing the name of an error code in the enum."]
    #[doc = ""]
    #[doc = " Output is a string representation of the enum.  For example \"OPTIX_SUCCESS\" for"]
    #[doc = " OPTIX_SUCCESS and \"OPTIX_ERROR_INVALID_VALUE\" for OPTIX_ERROR_INVALID_VALUE."]
    #[doc = ""]
    #[doc = " If the error code is not recognized, \"Unrecognized OptixResult code\" is returned."]
    #[doc = ""]
    #[doc = " \\param[in] result  OptixResult enum to generate string name for"]
    #[doc = ""]
    #[doc = " \\see #optixGetErrorString"]
    pub fn optixGetErrorName(result: OptixResult) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the description string for an error code."]
    #[doc = ""]
    #[doc = " Output is a string description of the enum.  For example \"Success\" for"]
    #[doc = " OPTIX_SUCCESS and \"Invalid value\" for OPTIX_ERROR_INVALID_VALUE."]
    #[doc = ""]
    #[doc = " If the error code is not recognized, \"Unrecognized OptixResult code\" is returned."]
    #[doc = ""]
    #[doc = " \\param[in] result  OptixResult enum to generate string description for"]
    #[doc = ""]
    #[doc = " \\see #optixGetErrorName"]
    pub fn optixGetErrorString(result: OptixResult) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a device context associated with the CUDA context specified with 'fromContext'."]
    #[doc = ""]
    #[doc = " If zero is specified for 'fromContext', OptiX will use the current CUDA context. The"]
    #[doc = " CUDA context should be initialized before calling optixDeviceContextCreate."]
    #[doc = ""]
    #[doc = " \\param[in] fromContext"]
    #[doc = " \\param[in] options"]
    #[doc = " \\param[out] context"]
    #[doc = " \\return"]
    #[doc = " - OPTIX_ERROR_CUDA_NOT_INITIALIZED"]
    #[doc = "   If using zero for 'fromContext' and CUDA has not been initialized yet on the calling"]
    #[doc = "   thread."]
    #[doc = " - OPTIX_ERROR_CUDA_ERROR"]
    #[doc = "   CUDA operation failed."]
    #[doc = " - OPTIX_ERROR_HOST_OUT_OF_MEMORY"]
    #[doc = "   Heap allocation failed."]
    #[doc = " - OPTIX_ERROR_INTERNAL_ERROR"]
    #[doc = "   Internal error"]
    pub fn optixDeviceContextCreate(
        fromContext: CUcontext,
        options: *const OptixDeviceContextOptions,
        context: *mut OptixDeviceContext,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Destroys all CPU and GPU state associated with the device."]
    #[doc = ""]
    #[doc = " It will attempt to block on CUDA streams that have launch work outstanding."]
    #[doc = ""]
    #[doc = " Any API objects, such as OptixModule and OptixPipeline, not already destroyed will be"]
    #[doc = " destroyed."]
    #[doc = ""]
    #[doc = " Thread safety: A device context must not be destroyed while it is still in use by concurrent API calls in other threads."]
    pub fn optixDeviceContextDestroy(context: OptixDeviceContext) -> OptixResult;
}
extern "C" {
    #[doc = " Query properties of a device context."]
    #[doc = ""]
    #[doc = " \\param[in] context     the device context to query the property for"]
    #[doc = " \\param[in] property    the property to query"]
    #[doc = " \\param[out] value      pointer to the returned"]
    #[doc = " \\param[in] sizeInBytes size of output"]
    pub fn optixDeviceContextGetProperty(
        context: OptixDeviceContext,
        property: OptixDeviceProperty,
        value: *mut ::std::os::raw::c_void,
        sizeInBytes: usize,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Sets the current log callback method."]
    #[doc = ""]
    #[doc = " See #OptixLogCallback for more details."]
    #[doc = ""]
    #[doc = " Thread safety: It is guaranteed that the callback itself (callbackFunction and callbackData) are updated atomically."]
    #[doc = " It is not guaranteed that the callback itself (callbackFunction and callbackData) and the callbackLevel are updated"]
    #[doc = " atomically. It is unspecified when concurrent API calls using the same context start to make use of the new"]
    #[doc = " callback method."]
    #[doc = ""]
    #[doc = " \\param[in] context          the device context"]
    #[doc = " \\param[in] callbackFunction the callback function to call"]
    #[doc = " \\param[in] callbackData     pointer to data passed to callback function while invoking it"]
    #[doc = " \\param[in] callbackLevel    callback level"]
    pub fn optixDeviceContextSetLogCallback(
        context: OptixDeviceContext,
        callbackFunction: OptixLogCallback,
        callbackData: *mut ::std::os::raw::c_void,
        callbackLevel: ::std::os::raw::c_uint,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Enables or disables the disk cache."]
    #[doc = ""]
    #[doc = " If caching was previously disabled, enabling it will attempt to initialize"]
    #[doc = " the disk cache database using the currently configured cache location. An"]
    #[doc = " error will be returned if initialization fails."]
    #[doc = ""]
    #[doc = " Note that no in-memory cache is used, so no caching behavior will be observed if the disk cache"]
    #[doc = " is disabled."]
    #[doc = ""]
    #[doc = " The cache can be disabled by setting the environment variable OPTIX_CACHE_MAXSIZE=0."]
    #[doc = " The environment variable takes precedence over this setting."]
    #[doc = " See #optixDeviceContextSetCacheDatabaseSizes for additional information."]
    #[doc = ""]
    #[doc = " Note that the disk cache can be disabled by the environment variable, but it cannot be enabled"]
    #[doc = " via the environment if it is disabled via the API."]
    #[doc = ""]
    #[doc = " \\param[in] context the device context"]
    #[doc = " \\param[in] enabled 1 to enabled, 0 to disable"]
    pub fn optixDeviceContextSetCacheEnabled(
        context: OptixDeviceContext,
        enabled: ::std::os::raw::c_int,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Sets the location of the disk cache."]
    #[doc = ""]
    #[doc = " The location is specified by a directory. This directory should not be used for other purposes"]
    #[doc = " and will be created if it does not exist. An error will be returned if is not possible to"]
    #[doc = " create the disk cache at the specified location for any reason (e.g., the path is invalid or"]
    #[doc = " the directory is not writable). Caching will be disabled if the disk cache cannot be"]
    #[doc = " initialized in the new location. If caching is disabled, no error will be returned until caching"]
    #[doc = " is enabled. If the disk cache is located on a network file share, behavior is undefined."]
    #[doc = ""]
    #[doc = " The location of the disk cache can be overridden with the environment variable OPTIX_CACHE_PATH."]
    #[doc = " The environment variable takes precedence over this setting."]
    #[doc = ""]
    #[doc = " The default location depends on the operating system:"]
    #[doc = " - Windows: %LOCALAPPDATA%\\\\NVIDIA\\\\OptixCache"]
    #[doc = " - Linux:   /var/tmp/OptixCache_\\<username\\> (or /tmp/OptixCache_\\<username\\> if the first choice is not usable),"]
    #[doc = "            the underscore and username suffix are omitted if the username cannot be obtained"]
    #[doc = " - macOS: /Library/Application Support/NVIDIA/OptixCache"]
    #[doc = ""]
    #[doc = " \\param[in] context  the device context"]
    #[doc = " \\param[in] location directory of disk cache"]
    pub fn optixDeviceContextSetCacheLocation(
        context: OptixDeviceContext,
        location: *const ::std::os::raw::c_char,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Sets the low and high water marks for disk cache garbage collection."]
    #[doc = ""]
    #[doc = " Garbage collection is triggered when a new entry is written to the cache and"]
    #[doc = " the current cache data size plus the size of the cache entry that is about"]
    #[doc = " to be inserted exceeds the high water mark. Garbage collection proceeds until"]
    #[doc = " the size reaches the low water mark. Garbage collection will always free enough"]
    #[doc = " space to insert the new entry without exceeding the low water mark. Setting"]
    #[doc = " either limit to zero will disable garbage collection. An error will be returned"]
    #[doc = " if both limits are non-zero and the high water mark is smaller than the low water mark."]
    #[doc = ""]
    #[doc = " Note that garbage collection is performed only on writes to the disk cache. No garbage"]
    #[doc = " collection is triggered on disk cache initialization or immediately when calling this function,"]
    #[doc = " but on subsequent inserting of data into the database."]
    #[doc = ""]
    #[doc = " If the size of a compiled module exceeds the value configured for the high water"]
    #[doc = " mark and garbage collection is enabled, the module will not be added to the cache"]
    #[doc = " and a warning will be added to the log."]
    #[doc = ""]
    #[doc = " The high water mark can be overridden with the environment variable OPTIX_CACHE_MAXSIZE."]
    #[doc = " The environment variable takes precedence over the function parameters.  The low water mark"]
    #[doc = " will be set to half the value of OPTIX_CACHE_MAXSIZE.  Setting OPTIX_CACHE_MAXSIZE to 0 will"]
    #[doc = " disable the disk cache, but will not alter the contents of the cache.  Negative and non-integer"]
    #[doc = " values will be ignored."]
    #[doc = ""]
    #[doc = " \\param[in] context       the device context"]
    #[doc = " \\param[in] lowWaterMark  the low water mark"]
    #[doc = " \\param[in] highWaterMark the high water mark"]
    pub fn optixDeviceContextSetCacheDatabaseSizes(
        context: OptixDeviceContext,
        lowWaterMark: usize,
        highWaterMark: usize,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Indicates whether the disk cache is enabled or disabled."]
    #[doc = ""]
    #[doc = " \\param[in] context   the device context"]
    #[doc = " \\param[out] enabled  1 if enabled, 0 if disabled"]
    pub fn optixDeviceContextGetCacheEnabled(
        context: OptixDeviceContext,
        enabled: *mut ::std::os::raw::c_int,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Returns the location of the disk cache.  If the cache has been disabled by setting the environment"]
    #[doc = " variable OPTIX_CACHE_MAXSIZE=0, this function will return an empty string."]
    #[doc = ""]
    #[doc = " \\param[in] context      the device context"]
    #[doc = " \\param[out] location    directory of disk cache, null terminated if locationSize > 0"]
    #[doc = " \\param[in] locationSize locationSize"]
    pub fn optixDeviceContextGetCacheLocation(
        context: OptixDeviceContext,
        location: *mut ::std::os::raw::c_char,
        locationSize: usize,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Returns the low and high water marks for disk cache garbage collection.  If the cache has been disabled by"]
    #[doc = " setting the environment variable OPTIX_CACHE_MAXSIZE=0, this function will return 0 for the low and high"]
    #[doc = " water marks."]
    #[doc = ""]
    #[doc = " \\param[in] context        the device context"]
    #[doc = " \\param[out] lowWaterMark  the low water mark"]
    #[doc = " \\param[out] highWaterMark the high water mark"]
    pub fn optixDeviceContextGetCacheDatabaseSizes(
        context: OptixDeviceContext,
        lowWaterMark: *mut usize,
        highWaterMark: *mut usize,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " logString is an optional buffer that contains compiler feedback and errors.  This"]
    #[doc = " information is also passed to the context logger (if enabled), however it may be"]
    #[doc = " difficult to correlate output to the logger to specific API invocations when using"]
    #[doc = " multiple threads.  The output to logString will only contain feedback for this specific"]
    #[doc = " invocation of this API call."]
    #[doc = ""]
    #[doc = " logStringSize as input should be a pointer to the number of bytes backing logString."]
    #[doc = " Upon return it contains the length of the log message (including the null terminator)"]
    #[doc = " which may be greater than the input value.  In this case, the log message will be"]
    #[doc = " truncated to fit into logString."]
    #[doc = ""]
    #[doc = " If logString or logStringSize are NULL, no output is written to logString.  If"]
    #[doc = " logStringSize points to a value that is zero, no output is written.  This does not"]
    #[doc = " affect output to the context logger if enabled."]
    #[doc = ""]
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] pipelineCompileOptions"]
    #[doc = " \\param[in] pipelineLinkOptions"]
    #[doc = " \\param[in] programGroups          array of ProgramGroup objects"]
    #[doc = " \\param[in] numProgramGroups       number of ProgramGroup objects"]
    #[doc = " \\param[out] logString             Information will be written to this string. If logStringSize > 0 logString will be null terminated."]
    #[doc = " \\param[in,out] logStringSize"]
    #[doc = " \\param[out] pipeline"]
    pub fn optixPipelineCreate(
        context: OptixDeviceContext,
        pipelineCompileOptions: *const OptixPipelineCompileOptions,
        pipelineLinkOptions: *const OptixPipelineLinkOptions,
        programGroups: *const OptixProgramGroup,
        numProgramGroups: ::std::os::raw::c_uint,
        logString: *mut ::std::os::raw::c_char,
        logStringSize: *mut usize,
        pipeline: *mut OptixPipeline,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Thread safety: A pipeline must not be destroyed while it is still in use by concurrent API calls in other threads."]
    pub fn optixPipelineDestroy(pipeline: OptixPipeline) -> OptixResult;
}
extern "C" {
    #[doc = " Sets the stack sizes for a pipeline."]
    #[doc = ""]
    #[doc = " Users are encouraged to see the programming guide and the implementations of the helper functions"]
    #[doc = " to understand how to construct the stack sizes based on their particular needs."]
    #[doc = ""]
    #[doc = " If this method is not used, an internal default implementation is used. The default implementation is correct (but"]
    #[doc = " not necessarily optimal) as long as the maximum depth of call trees of CC and DC programs is at most 2 and no motion transforms are used."]
    #[doc = ""]
    #[doc = " The maxTraversableGraphDepth responds to the maximal number of traversables visited when calling trace."]
    #[doc = " Every acceleration structure and motion transform count as one level of traversal."]
    #[doc = " E.g., for a simple IAS (instance acceleration structure) -> GAS (geometry acceleration structure)"]
    #[doc = " traversal graph, the maxTraversableGraphDepth is two."]
    #[doc = " For IAS -> MT (motion transform) -> GAS, the maxTraversableGraphDepth is three."]
    #[doc = " Note that it does not matter whether a IAS or GAS has motion or not, it always counts as one."]
    #[doc = " Launching optix with exceptions turned on (see #OPTIX_EXCEPTION_FLAG_TRACE_DEPTH) will throw an exception"]
    #[doc = " if the specified maxTraversableGraphDepth is too small."]
    #[doc = ""]
    #[doc = " \\param[in] pipeline                             The pipeline to configure the stack size for."]
    #[doc = " \\param[in] directCallableStackSizeFromTraversal The direct stack size requirement for direct callables invoked from IS or AH."]
    #[doc = " \\param[in] directCallableStackSizeFromState     The direct stack size requirement for direct callables invoked from RG, MS, or CH."]
    #[doc = " \\param[in] continuationStackSize                The continuation stack requirement."]
    #[doc = " \\param[in] maxTraversableGraphDepth             The maximum depth of a traversable graph passed to trace."]
    pub fn optixPipelineSetStackSize(
        pipeline: OptixPipeline,
        directCallableStackSizeFromTraversal: ::std::os::raw::c_uint,
        directCallableStackSizeFromState: ::std::os::raw::c_uint,
        continuationStackSize: ::std::os::raw::c_uint,
        maxTraversableGraphDepth: ::std::os::raw::c_uint,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " logString is an optional buffer that contains compiler feedback and errors.  This"]
    #[doc = " information is also passed to the context logger (if enabled), however it may be"]
    #[doc = " difficult to correlate output to the logger to specific API invocations when using"]
    #[doc = " multiple threads.  The output to logString will only contain feedback for this specific"]
    #[doc = " invocation of this API call."]
    #[doc = ""]
    #[doc = " logStringSize as input should be a pointer to the number of bytes backing logString."]
    #[doc = " Upon return it contains the length of the log message (including the null terminator)"]
    #[doc = " which may be greater than the input value.  In this case, the log message will be"]
    #[doc = " truncated to fit into logString."]
    #[doc = ""]
    #[doc = " If logString or logStringSize are NULL, no output is written to logString.  If"]
    #[doc = " logStringSize points to a value that is zero, no output is written.  This does not"]
    #[doc = " affect output to the context logger if enabled."]
    #[doc = ""]
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] moduleCompileOptions"]
    #[doc = " \\param[in] pipelineCompileOptions All modules in a pipeline need to use the same values for the pipeline compile options."]
    #[doc = " \\param[in] PTX                    Pointer to the PTX input string."]
    #[doc = " \\param[in] PTXsize                Parsing proceeds up to PTXsize characters, or the first NUL byte, whichever occurs first."]
    #[doc = " \\param[out] logString             Information will be written to this string. If logStringSize > 0 logString will be null terminated."]
    #[doc = " \\param[in,out] logStringSize"]
    #[doc = " \\param[out] module"]
    #[doc = ""]
    #[doc = " \\return OPTIX_ERROR_INVALID_VALUE - context is 0, moduleCompileOptions is 0, pipelineCompileOptions is 0, PTX is 0, module is 0."]
    pub fn optixModuleCreateFromPTX(
        context: OptixDeviceContext,
        moduleCompileOptions: *const OptixModuleCompileOptions,
        pipelineCompileOptions: *const OptixPipelineCompileOptions,
        PTX: *const ::std::os::raw::c_char,
        PTXsize: usize,
        logString: *mut ::std::os::raw::c_char,
        logStringSize: *mut usize,
        module: *mut OptixModule,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " All OptixTask objects associated with a given OptixModule will be cleaned up when"]
    #[doc = " #optixModuleDestroy() is called regardless of whether the compilation was successful"]
    #[doc = " or not. If the compilation state is OPTIX_MODULE_COMPILE_STATE_IMPENDING_FAILURE, any"]
    #[doc = " unstarted OptixTask objects do not need to be executed though there is no harm doing"]
    #[doc = " so."]
    #[doc = ""]
    #[doc = " \\see #optixModuleCreateFromPTX"]
    pub fn optixModuleCreateFromPTXWithTasks(
        context: OptixDeviceContext,
        moduleCompileOptions: *const OptixModuleCompileOptions,
        pipelineCompileOptions: *const OptixPipelineCompileOptions,
        PTX: *const ::std::os::raw::c_char,
        PTXsize: usize,
        logString: *mut ::std::os::raw::c_char,
        logStringSize: *mut usize,
        module: *mut OptixModule,
        firstTask: *mut OptixTask,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " When creating a module with tasks, the current state of the module can be queried"]
    #[doc = " using this function."]
    #[doc = ""]
    #[doc = " Thread safety: Safe to call from any thread until optixModuleDestroy is called."]
    #[doc = ""]
    #[doc = " \\see #optixModuleCreateFromPTXWithTasks"]
    pub fn optixModuleGetCompilationState(
        module: OptixModule,
        state: *mut OptixModuleCompileState,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Call for OptixModule objects created with optixModuleCreateFromPTX and optixModuleDeserialize."]
    #[doc = ""]
    #[doc = " Modules must not be destroyed while they are still used by any program group."]
    #[doc = ""]
    #[doc = " Thread safety: A module must not be destroyed while it is still in use by concurrent API calls in other threads."]
    pub fn optixModuleDestroy(module: OptixModule) -> OptixResult;
}
extern "C" {
    #[doc = " Returns a module containing the intersection program for the built-in primitive type specified"]
    #[doc = " by the builtinISOptions.  This module must be used as the moduleIS for the OptixProgramGroupHitgroup"]
    #[doc = " in any SBT record for that primitive type.  (The entryFunctionNameIS should be null.)"]
    pub fn optixBuiltinISModuleGet(
        context: OptixDeviceContext,
        moduleCompileOptions: *const OptixModuleCompileOptions,
        pipelineCompileOptions: *const OptixPipelineCompileOptions,
        builtinISOptions: *const OptixBuiltinISOptions,
        builtinModule: *mut OptixModule,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Each OptixTask should be executed with #optixTaskExecute(). If additional parallel"]
    #[doc = " work is found, new OptixTask objects will be returned in additionalTasks along with"]
    #[doc = " the number of additional tasks in numAdditionalTasksCreated. The parameter"]
    #[doc = " additionalTasks should point to a user allocated array of minimum size"]
    #[doc = " maxNumAdditionalTasks. OptiX can generate upto maxNumAdditionalTasks additional tasks."]
    #[doc = ""]
    #[doc = " Each task can be executed in parallel and in any order."]
    #[doc = ""]
    #[doc = " Thread safety: Safe to call from any thread until #optixModuleDestroy() is called for"]
    #[doc = " any associated task."]
    #[doc = ""]
    #[doc = " \\see #optixModuleCreateFromPTXWithTasks"]
    #[doc = ""]
    #[doc = " \\param[in] task the OptixTask to execute"]
    #[doc = " \\param[in] additionalTasks pointer to array of OptixTask objects to be filled in"]
    #[doc = " \\param[in] maxNumAdditionalTasks maximum number of additional OptixTask objects"]
    #[doc = " \\param[out] numAdditionalTasksCreated number of OptixTask objects created by OptiX and written into #additionalTasks"]
    pub fn optixTaskExecute(
        task: OptixTask,
        additionalTasks: *mut OptixTask,
        maxNumAdditionalTasks: ::std::os::raw::c_uint,
        numAdditionalTasksCreated: *mut ::std::os::raw::c_uint,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Returns the stack sizes for the given program group."]
    #[doc = ""]
    #[doc = " \\param[in] programGroup the program group"]
    #[doc = " \\param[out] stackSizes  the corresponding stack sizes"]
    pub fn optixProgramGroupGetStackSize(
        programGroup: OptixProgramGroup,
        stackSizes: *mut OptixStackSizes,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " logString is an optional buffer that contains compiler feedback and errors.  This"]
    #[doc = " information is also passed to the context logger (if enabled), however it may be"]
    #[doc = " difficult to correlate output to the logger to specific API invocations when using"]
    #[doc = " multiple threads.  The output to logString will only contain feedback for this specific"]
    #[doc = " invocation of this API call."]
    #[doc = ""]
    #[doc = " logStringSize as input should be a pointer to the number of bytes backing logString."]
    #[doc = " Upon return it contains the length of the log message (including the null terminator)"]
    #[doc = " which may be greater than the input value.  In this case, the log message will be"]
    #[doc = " truncated to fit into logString."]
    #[doc = ""]
    #[doc = " If logString or logStringSize are NULL, no output is written to logString.  If"]
    #[doc = " logStringSize points to a value that is zero, no output is written.  This does not"]
    #[doc = " affect output to the context logger if enabled."]
    #[doc = ""]
    #[doc = " Creates numProgramGroups OptiXProgramGroup objects from the specified"]
    #[doc = " OptixProgramGroupDesc array.  The size of the arrays must match."]
    #[doc = ""]
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] programDescriptions    N * OptixProgramGroupDesc"]
    #[doc = " \\param[in] numProgramGroups       N"]
    #[doc = " \\param[in] options"]
    #[doc = " \\param[out] logString             Information will be written to this string. If logStringSize > 0 logString will be null terminated."]
    #[doc = " \\param[in,out] logStringSize"]
    #[doc = " \\param[out] programGroups"]
    pub fn optixProgramGroupCreate(
        context: OptixDeviceContext,
        programDescriptions: *const OptixProgramGroupDesc,
        numProgramGroups: ::std::os::raw::c_uint,
        options: *const OptixProgramGroupOptions,
        logString: *mut ::std::os::raw::c_char,
        logStringSize: *mut usize,
        programGroups: *mut OptixProgramGroup,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Thread safety: A program group must not be destroyed while it is still in use by concurrent API calls in other threads."]
    pub fn optixProgramGroupDestroy(programGroup: OptixProgramGroup) -> OptixResult;
}
extern "C" {
    #[doc = " Where the magic happens."]
    #[doc = ""]
    #[doc = " The stream and pipeline must belong to the same device context.  Multiple launches"]
    #[doc = " may be issues in parallel from multiple threads to different streams."]
    #[doc = ""]
    #[doc = " pipelineParamsSize number of bytes are copied from the device memory pointed to by"]
    #[doc = " pipelineParams before launch.  It is an error if pipelineParamsSize is greater than the"]
    #[doc = " size of the variable declared in modules and identified by"]
    #[doc = " OptixPipelineCompileOptions::pipelineLaunchParamsVariableName. If the launch params"]
    #[doc = " variable was optimized out or not found in the modules linked to the pipeline then"]
    #[doc = " the pipelineParams and pipelineParamsSize parameters are ignored."]
    #[doc = ""]
    #[doc = " sbt points to the shader binding table, which defines shader"]
    #[doc = " groupings and their resources. See the SBT spec."]
    #[doc = ""]
    #[doc = " \\param[in] pipeline"]
    #[doc = " \\param[in] stream"]
    #[doc = " \\param[in] pipelineParams"]
    #[doc = " \\param[in] pipelineParamsSize"]
    #[doc = " \\param[in] sbt"]
    #[doc = " \\param[in] width              number of elements to compute"]
    #[doc = " \\param[in] height             number of elements to compute"]
    #[doc = " \\param[in] depth              number of elements to compute"]
    #[doc = ""]
    #[doc = " Thread safety: In the current implementation concurrent launches to the same pipeline are not"]
    #[doc = " supported.  Concurrent launches require separate OptixPipeline objects."]
    pub fn optixLaunch(
        pipeline: OptixPipeline,
        stream: CUstream,
        pipelineParams: CUdeviceptr,
        pipelineParamsSize: usize,
        sbt: *const OptixShaderBindingTable,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        depth: ::std::os::raw::c_uint,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " \\param[in]  programGroup               the program group containing the program(s)"]
    #[doc = " \\param[out] sbtRecordHeaderHostPointer  the result sbt record header"]
    pub fn optixSbtRecordPackHeader(
        programGroup: OptixProgramGroup,
        sbtRecordHeaderHostPointer: *mut ::std::os::raw::c_void,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] accelOptions   options for the accel build"]
    #[doc = " \\param[in] buildInputs    an array of OptixBuildInput objects"]
    #[doc = " \\param[in] numBuildInputs number of elements in buildInputs (must be at least 1)"]
    #[doc = " \\param[out] bufferSizes   fills in buffer sizes"]
    pub fn optixAccelComputeMemoryUsage(
        context: OptixDeviceContext,
        accelOptions: *const OptixAccelBuildOptions,
        buildInputs: *const OptixBuildInput,
        numBuildInputs: ::std::os::raw::c_uint,
        bufferSizes: *mut OptixAccelBufferSizes,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] stream"]
    #[doc = " \\param[in] accelOptions             accel options"]
    #[doc = " \\param[in] buildInputs              an array of OptixBuildInput objects"]
    #[doc = " \\param[in] numBuildInputs           must be >= 1 for GAS, and == 1 for IAS"]
    #[doc = " \\param[in] tempBuffer               must be a multiple of OPTIX_ACCEL_BUFFER_BYTE_ALIGNMENT"]
    #[doc = " \\param[in] tempBufferSizeInBytes"]
    #[doc = " \\param[in] outputBuffer             must be a multiple of OPTIX_ACCEL_BUFFER_BYTE_ALIGNMENT"]
    #[doc = " \\param[in] outputBufferSizeInBytes"]
    #[doc = " \\param[out] outputHandle"]
    #[doc = " \\param[out] emittedProperties        types of requested properties and output buffers"]
    #[doc = " \\param[in] numEmittedProperties      number of post-build properties to populate (may be zero)"]
    pub fn optixAccelBuild(
        context: OptixDeviceContext,
        stream: CUstream,
        accelOptions: *const OptixAccelBuildOptions,
        buildInputs: *const OptixBuildInput,
        numBuildInputs: ::std::os::raw::c_uint,
        tempBuffer: CUdeviceptr,
        tempBufferSizeInBytes: usize,
        outputBuffer: CUdeviceptr,
        outputBufferSizeInBytes: usize,
        outputHandle: *mut OptixTraversableHandle,
        emittedProperties: *const OptixAccelEmitDesc,
        numEmittedProperties: ::std::os::raw::c_uint,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Obtain relocation information, stored in OptixAccelRelocationInfo, for a given context"]
    #[doc = " and acceleration structure's traversable handle."]
    #[doc = ""]
    #[doc = " The relocation information can be passed to optixAccelCheckRelocationCompatibility to"]
    #[doc = " determine if an acceleration structure, referenced by 'handle', can be relocated to a"]
    #[doc = " different device's memory space (see #optixAccelCheckRelocationCompatibility)."]
    #[doc = ""]
    #[doc = " When used with optixAccelRelocate, it provides data necessary for doing the relocation."]
    #[doc = ""]
    #[doc = " If the acceleration structure data associated with 'handle' is copied multiple times,"]
    #[doc = " the same OptixAccelRelocationInfo can also be used on all copies."]
    #[doc = ""]
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] handle"]
    #[doc = " \\param[out] info"]
    #[doc = " \\return OPTIX_ERROR_INVALID_VALUE will be returned for traversable handles that are not from"]
    #[doc = " acceleration structure builds."]
    pub fn optixAccelGetRelocationInfo(
        context: OptixDeviceContext,
        handle: OptixTraversableHandle,
        info: *mut OptixAccelRelocationInfo,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Checks if an acceleration structure built using another OptixDeviceContext (that was"]
    #[doc = " used to fill in 'info') is compatible with the OptixDeviceContext specified in the"]
    #[doc = " 'context' parameter."]
    #[doc = ""]
    #[doc = " Any device is always compatible with itself."]
    #[doc = ""]
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] info"]
    #[doc = " \\param[out] compatible If OPTIX_SUCCESS is returned 'compatible' will have the value of either:"]
    #[doc = " - 0: This context is not compatible with acceleration structure data associated with 'info'."]
    #[doc = " - 1: This context is compatible."]
    pub fn optixAccelCheckRelocationCompatibility(
        context: OptixDeviceContext,
        info: *const OptixAccelRelocationInfo,
        compatible: *mut ::std::os::raw::c_int,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " optixAccelRelocate is called to update the acceleration structure after it has been"]
    #[doc = " relocated.  Relocation is necessary when the acceleration structure's location in device"]
    #[doc = " memory has changed.  optixAccelRelocate does not copy the memory.  This function only"]
    #[doc = " operates on the relocated memory who's new location is specified by 'targetAccel'."]
    #[doc = " optixAccelRelocate also returns the new OptixTraversableHandle associated with"]
    #[doc = " 'targetAccel'.  The original memory (source) is not required to be valid, only the"]
    #[doc = " OptixAccelRelocationInfo."]
    #[doc = ""]
    #[doc = " Before copying the data and calling optixAccelRelocate,"]
    #[doc = " optixAccelCheckRelocationCompatibility should be called to ensure the copy will be"]
    #[doc = " compatible with the destination device context."]
    #[doc = ""]
    #[doc = " The memory pointed to by 'targetAccel' should be allocated with the same size as the"]
    #[doc = " source acceleration.  Similar to the 'outputBuffer' used in optixAccelBuild, this"]
    #[doc = " pointer must be a multiple of OPTIX_ACCEL_BUFFER_BYTE_ALIGNMENT."]
    #[doc = ""]
    #[doc = " The memory in 'targetAccel' must be allocated as long as the accel is in use."]
    #[doc = ""]
    #[doc = " When relocating an accel that contains instances, 'instanceTraversableHandles' and"]
    #[doc = " 'numInstanceTraversableHandles' should be supplied.  These are the traversable handles"]
    #[doc = " of the instances.  These can be used when also relocating the instances.  No updates to"]
    #[doc = " the bounds are performed.  Use optixAccelBuild to update the bounds."]
    #[doc = " 'instanceTraversableHandles' and 'numInstanceTraversableHandles' may be zero when"]
    #[doc = " relocating bottom level accel (i.e. an accel with no instances)."]
    #[doc = ""]
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] stream"]
    #[doc = " \\param[in] info"]
    #[doc = " \\param[in] instanceTraversableHandles"]
    #[doc = " \\param[in] numInstanceTraversableHandles"]
    #[doc = " \\param[in] targetAccel"]
    #[doc = " \\param[in] targetAccelSizeInBytes"]
    #[doc = " \\param[out] targetHandle"]
    pub fn optixAccelRelocate(
        context: OptixDeviceContext,
        stream: CUstream,
        info: *const OptixAccelRelocationInfo,
        instanceTraversableHandles: CUdeviceptr,
        numInstanceTraversableHandles: usize,
        targetAccel: CUdeviceptr,
        targetAccelSizeInBytes: usize,
        targetHandle: *mut OptixTraversableHandle,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " After building an acceleration structure, it can be copied in a compacted form to reduce"]
    #[doc = " memory.  In order to be compacted, OPTIX_BUILD_FLAG_ALLOW_COMPACTION must be supplied in"]
    #[doc = " OptixAccelBuildOptions::buildFlags passed to optixAccelBuild."]
    #[doc = ""]
    #[doc = " 'outputBuffer' is the pointer to where the compacted acceleration structure will be"]
    #[doc = " written.  This pointer must be a multiple of OPTIX_ACCEL_BUFFER_BYTE_ALIGNMENT."]
    #[doc = ""]
    #[doc = " The size of the memory specified in 'outputBufferSizeInBytes' should be at least the"]
    #[doc = " value computed using the OPTIX_PROPERTY_TYPE_COMPACTED_SIZE that was reported during"]
    #[doc = " optixAccelBuild."]
    #[doc = ""]
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] stream"]
    #[doc = " \\param[in] inputHandle"]
    #[doc = " \\param[in] outputBuffer"]
    #[doc = " \\param[in] outputBufferSizeInBytes"]
    #[doc = " \\param[out] outputHandle"]
    pub fn optixAccelCompact(
        context: OptixDeviceContext,
        stream: CUstream,
        inputHandle: OptixTraversableHandle,
        outputBuffer: CUdeviceptr,
        outputBufferSizeInBytes: usize,
        outputHandle: *mut OptixTraversableHandle,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " \\param[in] onDevice"]
    #[doc = " \\param[in] pointer            pointer to traversable allocated in OptixDeviceContext. This pointer must be a multiple of OPTIX_TRANSFORM_BYTE_ALIGNMENT"]
    #[doc = " \\param[in] traversableType    Type of OptixTraversableHandle to create"]
    #[doc = " \\param[out] traversableHandle traversable handle. traversableHandle must be in host memory"]
    pub fn optixConvertPointerToTraversableHandle(
        onDevice: OptixDeviceContext,
        pointer: CUdeviceptr,
        traversableType: OptixTraversableType,
        traversableHandle: *mut OptixTraversableHandle,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Creates a denoiser object with the given options, using built-in inference models"]
    #[doc = ""]
    #[doc = " 'modelKind' selects the model used for inference."]
    #[doc = " Inference for the built-in models can be guided (giving hints to improve image quality) with"]
    #[doc = " albedo and normal vector images in the guide layer (see 'optixDenoiserInvoke')."]
    #[doc = " Use of these images must be enabled in 'OptixDenoiserOptions'."]
    #[doc = ""]
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] modelKind"]
    #[doc = " \\param[in] options"]
    #[doc = " \\param[out] denoiser"]
    pub fn optixDenoiserCreate(
        context: OptixDeviceContext,
        modelKind: OptixDenoiserModelKind,
        options: *const OptixDenoiserOptions,
        denoiser: *mut OptixDenoiser,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Creates a denoiser object with the given options, using a provided inference model"]
    #[doc = ""]
    #[doc = " 'userData' and 'userDataSizeInBytes' provide a user model for inference."]
    #[doc = " The memory passed in userData will be accessed only during the invocation of this function and"]
    #[doc = " can be freed after it returns."]
    #[doc = " The user model must export only one weight set which determines both the model kind and the"]
    #[doc = " required set of guide images."]
    #[doc = ""]
    #[doc = " \\param[in] context"]
    #[doc = " \\param[in] userData"]
    #[doc = " \\param[in] userDataSizeInBytes"]
    #[doc = " \\param[out] denoiser"]
    pub fn optixDenoiserCreateWithUserModel(
        context: OptixDeviceContext,
        userData: *const ::std::os::raw::c_void,
        userDataSizeInBytes: usize,
        denoiser: *mut OptixDenoiser,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Destroys the denoiser object and any associated host resources."]
    pub fn optixDenoiserDestroy(denoiser: OptixDenoiser) -> OptixResult;
}
extern "C" {
    #[doc = " Computes the GPU memory resources required to execute the denoiser."]
    #[doc = ""]
    #[doc = " Memory for state and scratch buffers must be allocated with the sizes in 'returnSizes' and scratch memory"]
    #[doc = " passed to optixDenoiserSetup, optixDenoiserInvoke,"]
    #[doc = " optixDenoiserComputeIntensity and optixDenoiserComputeAverageColor."]
    #[doc = " For tiled denoising an overlap area must be added to each tile on all sides which increases the amount of"]
    #[doc = " memory needed to denoise a tile. In case of tiling use withOverlapScratchSizeInBytes."]
    #[doc = " If only full resolution images are denoised, withoutOverlapScratchSizeInBytes can be used which is always"]
    #[doc = " smaller than withOverlapScratchSizeInBytes."]
    #[doc = ""]
    #[doc = " 'outputWidth' and 'outputHeight' is the dimension of the image to be denoised (without overlap in case tiling"]
    #[doc = " is being used)."]
    #[doc = " 'outputWidth' and 'outputHeight' must be greater than or equal to the dimensions passed to optixDenoiserSetup."]
    #[doc = ""]
    #[doc = " \\param[in] denoiser"]
    #[doc = " \\param[in] outputWidth"]
    #[doc = " \\param[in] outputHeight"]
    #[doc = " \\param[out] returnSizes"]
    pub fn optixDenoiserComputeMemoryResources(
        denoiser: OptixDenoiser,
        outputWidth: ::std::os::raw::c_uint,
        outputHeight: ::std::os::raw::c_uint,
        returnSizes: *mut OptixDenoiserSizes,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Initializes the state required by the denoiser."]
    #[doc = ""]
    #[doc = " 'inputWidth' and 'inputHeight' must include overlap on both sides of the image if tiling is being used. The overlap is"]
    #[doc = " returned by #optixDenoiserComputeMemoryResources."]
    #[doc = " For subsequent calls to #optixDenoiserInvoke 'inputWidth' and 'inputHeight' are the maximum dimensions"]
    #[doc = " of the input layers. Dimensions of the input layers passed to #optixDenoiserInvoke may be different in each"]
    #[doc = " invocation however they always must be smaller than 'inputWidth' and 'inputHeight' passed to #optixDenoiserSetup."]
    #[doc = ""]
    #[doc = " \\param[in] denoiser"]
    #[doc = " \\param[in] stream"]
    #[doc = " \\param[in] inputWidth"]
    #[doc = " \\param[in] inputHeight"]
    #[doc = " \\param[in] denoiserState"]
    #[doc = " \\param[in] denoiserStateSizeInBytes"]
    #[doc = " \\param[in] scratch"]
    #[doc = " \\param[in] scratchSizeInBytes"]
    pub fn optixDenoiserSetup(
        denoiser: OptixDenoiser,
        stream: CUstream,
        inputWidth: ::std::os::raw::c_uint,
        inputHeight: ::std::os::raw::c_uint,
        denoiserState: CUdeviceptr,
        denoiserStateSizeInBytes: usize,
        scratch: CUdeviceptr,
        scratchSizeInBytes: usize,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Invokes denoiser on a set of input data and produces at least one output image."]
    #[doc = " State memory must be available during the execution of the"]
    #[doc = " denoiser (or until optixDenoiserSetup is called with a new state memory pointer)."]
    #[doc = " Scratch memory passed is used only for the duration of this function."]
    #[doc = " Scratch and state memory sizes must have a size greater than or equal to the sizes as returned by"]
    #[doc = " optixDenoiserComputeMemoryResources."]
    #[doc = ""]
    #[doc = " 'inputOffsetX' and 'inputOffsetY' are pixel offsets in the 'inputLayers' image"]
    #[doc = " specifying the beginning of the image without overlap. When denoising an entire image without tiling"]
    #[doc = " there is no overlap and 'inputOffsetX' and 'inputOffsetY' must be zero. When denoising a tile which is"]
    #[doc = " adjacent to one of the four sides of the entire image the corresponding offsets must also be zero since"]
    #[doc = " there is no overlap at the side adjacent to the image border."]
    #[doc = ""]
    #[doc = " 'guideLayer' provides additional information to the denoiser. When providing albedo and normal vector"]
    #[doc = " guide images, the corresponding fields in the 'OptixDenoiserOptions' must be"]
    #[doc = " enabled, see #optixDenoiserCreate."]
    #[doc = " 'guideLayer' must not be null. If a guide image in 'OptixDenoiserOptions' is not enabled, the"]
    #[doc = " corresponding image in 'OptixDenoiserGuideLayer' is ignored."]
    #[doc = ""]
    #[doc = " If OPTIX_DENOISER_MODEL_KIND_TEMPORAL or OPTIX_DENOISER_MODEL_KIND_TEMPORAL_AOV  is selected, a 2d flow"]
    #[doc = " image must be given in 'OptixDenoiserGuideLayer'."]
    #[doc = " It describes for each pixel the flow from the previous to the current frame (a 2d vector in pixel space)."]
    #[doc = " The denoised beauty/AOV of the previous frame must be given in 'previousOutput'."]
    #[doc = " If this image is not available in the first frame of a sequence, the noisy beauty/AOV from the first frame"]
    #[doc = " and zero flow vectors could be given as a substitute."]
    #[doc = " For non-temporal model kinds the flow image in 'OptixDenoiserGuideLayer' is ignored."]
    #[doc = " 'previousOutput' and"]
    #[doc = " 'output' may refer to the same buffer, i.e. 'previousOutput' is first read by this function and later"]
    #[doc = " overwritten with the denoised result. 'output' can be passed as 'previousOutput' to the next frame."]
    #[doc = " In other model kinds (not temporal) 'previousOutput' is ignored."]
    #[doc = ""]
    #[doc = " The beauty layer must be given as the first entry in 'layers'."]
    #[doc = " In AOV type model kinds (OPTIX_DENOISER_MODEL_KIND_AOV or in user defined models implementing"]
    #[doc = " kernel-prediction) additional layers for the AOV images can be given."]
    #[doc = " In each layer the noisy input image is given in 'input', the denoised output is written into the"]
    #[doc = " 'output' image. input and output images may refer to the same buffer, with the restriction that"]
    #[doc = " the pixel formats must be identical for input and output when the blend mode is selected (see"]
    #[doc = " #OptixDenoiserParams)."]
    #[doc = ""]
    #[doc = " If OPTIX_DENOISER_MODEL_KIND_TEMPORAL or OPTIX_DENOISER_MODEL_KIND_TEMPORAL_AOV  is selected, the denoised"]
    #[doc = " image from the previous frame must be given in 'previousOutput' in the layer. 'previousOutput' and"]
    #[doc = " 'output' may refer to the same buffer, i.e. 'previousOutput' is first read by this function and later"]
    #[doc = " overwritten with the denoised result. 'output' can be passed as 'previousOutput' to the next frame."]
    #[doc = " In other model kinds (not temporal) 'previousOutput' is ignored."]
    #[doc = ""]
    #[doc = " If OPTIX_DENOISER_MODEL_KIND_TEMPORAL or OPTIX_DENOISER_MODEL_KIND_TEMPORAL_AOV  is selected, the"]
    #[doc = " normal vector guide image must be given as 3d vectors in camera space. In the other models only"]
    #[doc = " the x and y channels are used and other channels are ignored."]
    #[doc = ""]
    #[doc = " \\param[in] denoiser"]
    #[doc = " \\param[in] stream"]
    #[doc = " \\param[in] params"]
    #[doc = " \\param[in] denoiserState"]
    #[doc = " \\param[in] denoiserStateSizeInBytes"]
    #[doc = " \\param[in] guideLayer"]
    #[doc = " \\param[in] layers"]
    #[doc = " \\param[in] numLayers"]
    #[doc = " \\param[in] inputOffsetX"]
    #[doc = " \\param[in] inputOffsetY"]
    #[doc = " \\param[in] scratch"]
    #[doc = " \\param[in] scratchSizeInBytes"]
    pub fn optixDenoiserInvoke(
        denoiser: OptixDenoiser,
        stream: CUstream,
        params: *const OptixDenoiserParams,
        denoiserState: CUdeviceptr,
        denoiserStateSizeInBytes: usize,
        guideLayer: *const OptixDenoiserGuideLayer,
        layers: *const OptixDenoiserLayer,
        numLayers: ::std::os::raw::c_uint,
        inputOffsetX: ::std::os::raw::c_uint,
        inputOffsetY: ::std::os::raw::c_uint,
        scratch: CUdeviceptr,
        scratchSizeInBytes: usize,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " data type unsigned char is not supported for 'inputImage', it must be 3 or 4 component half/float."]
    #[doc = ""]
    #[doc = " \\param[in] denoiser"]
    #[doc = " \\param[in] stream"]
    #[doc = " \\param[in] inputImage"]
    #[doc = " \\param[out] outputIntensity    single float"]
    #[doc = " \\param[in] scratch"]
    #[doc = " \\param[in] scratchSizeInBytes"]
    pub fn optixDenoiserComputeIntensity(
        denoiser: OptixDenoiser,
        stream: CUstream,
        inputImage: *const OptixImage2D,
        outputIntensity: CUdeviceptr,
        scratch: CUdeviceptr,
        scratchSizeInBytes: usize,
    ) -> OptixResult;
}
extern "C" {
    #[doc = " Compute average logarithmic for each of the first three channels for the given image."]
    #[doc = " When denoising tiles the intensity of the entire image should be computed, i.e. not per tile to get"]
    #[doc = " consistent results."]
    #[doc = " This function needs scratch memory with a size of at least"]
    #[doc = " sizeof( int ) * ( 3 + 3 * inputImage::width * inputImage::height ). When denoising entire images (no tiling)"]
    #[doc = " the same scratch memory as passed to optixDenoiserInvoke could be used."]
    #[doc = ""]
    #[doc = " data type unsigned char is not supported for 'inputImage', it must be 3 or 4 component half/float."]
    #[doc = ""]
    #[doc = " \\param[in] denoiser"]
    #[doc = " \\param[in] stream"]
    #[doc = " \\param[in] inputImage"]
    #[doc = " \\param[out] outputAverageColor three floats"]
    #[doc = " \\param[in] scratch"]
    #[doc = " \\param[in] scratchSizeInBytes"]
    pub fn optixDenoiserComputeAverageColor(
        denoiser: OptixDenoiser,
        stream: CUstream,
        inputImage: *const OptixImage2D,
        outputAverageColor: CUdeviceptr,
        scratch: CUdeviceptr,
        scratchSizeInBytes: usize,
    ) -> OptixResult;
}
#[doc = " The function table containing all API functions."]
#[doc = ""]
#[doc = " See #optixInit() and #optixInitWithHandle()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixFunctionTable {
    #[doc = " See ::optixGetErrorName()."]
    pub optixGetErrorName: ::std::option::Option<
        unsafe extern "C" fn(result: OptixResult) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " See ::optixGetErrorString()."]
    pub optixGetErrorString: ::std::option::Option<
        unsafe extern "C" fn(result: OptixResult) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " See ::optixDeviceContextCreate()."]
    pub optixDeviceContextCreate: ::std::option::Option<
        unsafe extern "C" fn(
            fromContext: CUcontext,
            options: *const OptixDeviceContextOptions,
            context: *mut OptixDeviceContext,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextDestroy()."]
    pub optixDeviceContextDestroy:
        ::std::option::Option<unsafe extern "C" fn(context: OptixDeviceContext) -> OptixResult>,
    #[doc = " See ::optixDeviceContextGetProperty()."]
    pub optixDeviceContextGetProperty: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            property: OptixDeviceProperty,
            value: *mut ::std::os::raw::c_void,
            sizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextSetLogCallback()."]
    pub optixDeviceContextSetLogCallback: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            callbackFunction: OptixLogCallback,
            callbackData: *mut ::std::os::raw::c_void,
            callbackLevel: ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextSetCacheEnabled()."]
    pub optixDeviceContextSetCacheEnabled: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            enabled: ::std::os::raw::c_int,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextSetCacheLocation()."]
    pub optixDeviceContextSetCacheLocation: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            location: *const ::std::os::raw::c_char,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextSetCacheDatabaseSizes()."]
    pub optixDeviceContextSetCacheDatabaseSizes: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            lowWaterMark: usize,
            highWaterMark: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextGetCacheEnabled()."]
    pub optixDeviceContextGetCacheEnabled: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            enabled: *mut ::std::os::raw::c_int,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextGetCacheLocation()."]
    pub optixDeviceContextGetCacheLocation: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            location: *mut ::std::os::raw::c_char,
            locationSize: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextGetCacheDatabaseSizes()."]
    pub optixDeviceContextGetCacheDatabaseSizes: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            lowWaterMark: *mut usize,
            highWaterMark: *mut usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixModuleCreateFromPTX()."]
    pub optixModuleCreateFromPTX: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            moduleCompileOptions: *const OptixModuleCompileOptions,
            pipelineCompileOptions: *const OptixPipelineCompileOptions,
            PTX: *const ::std::os::raw::c_char,
            PTXsize: usize,
            logString: *mut ::std::os::raw::c_char,
            logStringSize: *mut usize,
            module: *mut OptixModule,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixModuleCreateFromPTXWithTasks()."]
    pub optixModuleCreateFromPTXWithTasks: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            moduleCompileOptions: *const OptixModuleCompileOptions,
            pipelineCompileOptions: *const OptixPipelineCompileOptions,
            PTX: *const ::std::os::raw::c_char,
            PTXsize: usize,
            logString: *mut ::std::os::raw::c_char,
            logStringSize: *mut usize,
            module: *mut OptixModule,
            firstTask: *mut OptixTask,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixModuleGetCompilationState()."]
    pub optixModuleGetCompilationState: ::std::option::Option<
        unsafe extern "C" fn(
            module: OptixModule,
            state: *mut OptixModuleCompileState,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixModuleDestroy()."]
    pub optixModuleDestroy:
        ::std::option::Option<unsafe extern "C" fn(module: OptixModule) -> OptixResult>,
    #[doc = " See ::optixBuiltinISModuleGet()."]
    pub optixBuiltinISModuleGet: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            moduleCompileOptions: *const OptixModuleCompileOptions,
            pipelineCompileOptions: *const OptixPipelineCompileOptions,
            builtinISOptions: *const OptixBuiltinISOptions,
            builtinModule: *mut OptixModule,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixTaskExecute()."]
    pub optixTaskExecute: ::std::option::Option<
        unsafe extern "C" fn(
            task: OptixTask,
            additionalTasks: *mut OptixTask,
            maxNumAdditionalTasks: ::std::os::raw::c_uint,
            numAdditionalTasksCreated: *mut ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixProgramGroupCreate()."]
    pub optixProgramGroupCreate: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            programDescriptions: *const OptixProgramGroupDesc,
            numProgramGroups: ::std::os::raw::c_uint,
            options: *const OptixProgramGroupOptions,
            logString: *mut ::std::os::raw::c_char,
            logStringSize: *mut usize,
            programGroups: *mut OptixProgramGroup,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixProgramGroupDestroy()."]
    pub optixProgramGroupDestroy:
        ::std::option::Option<unsafe extern "C" fn(programGroup: OptixProgramGroup) -> OptixResult>,
    #[doc = " See ::optixProgramGroupGetStackSize()."]
    pub optixProgramGroupGetStackSize: ::std::option::Option<
        unsafe extern "C" fn(
            programGroup: OptixProgramGroup,
            stackSizes: *mut OptixStackSizes,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixPipelineCreate()."]
    pub optixPipelineCreate: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            pipelineCompileOptions: *const OptixPipelineCompileOptions,
            pipelineLinkOptions: *const OptixPipelineLinkOptions,
            programGroups: *const OptixProgramGroup,
            numProgramGroups: ::std::os::raw::c_uint,
            logString: *mut ::std::os::raw::c_char,
            logStringSize: *mut usize,
            pipeline: *mut OptixPipeline,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixPipelineDestroy()."]
    pub optixPipelineDestroy:
        ::std::option::Option<unsafe extern "C" fn(pipeline: OptixPipeline) -> OptixResult>,
    #[doc = " See ::optixPipelineSetStackSize()."]
    pub optixPipelineSetStackSize: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: OptixPipeline,
            directCallableStackSizeFromTraversal: ::std::os::raw::c_uint,
            directCallableStackSizeFromState: ::std::os::raw::c_uint,
            continuationStackSize: ::std::os::raw::c_uint,
            maxTraversableGraphDepth: ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelComputeMemoryUsage()."]
    pub optixAccelComputeMemoryUsage: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            accelOptions: *const OptixAccelBuildOptions,
            buildInputs: *const OptixBuildInput,
            numBuildInputs: ::std::os::raw::c_uint,
            bufferSizes: *mut OptixAccelBufferSizes,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelBuild()."]
    pub optixAccelBuild: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            stream: CUstream,
            accelOptions: *const OptixAccelBuildOptions,
            buildInputs: *const OptixBuildInput,
            numBuildInputs: ::std::os::raw::c_uint,
            tempBuffer: CUdeviceptr,
            tempBufferSizeInBytes: usize,
            outputBuffer: CUdeviceptr,
            outputBufferSizeInBytes: usize,
            outputHandle: *mut OptixTraversableHandle,
            emittedProperties: *const OptixAccelEmitDesc,
            numEmittedProperties: ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelGetRelocationInfo()."]
    pub optixAccelGetRelocationInfo: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            handle: OptixTraversableHandle,
            info: *mut OptixAccelRelocationInfo,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelCheckRelocationCompatibility()."]
    pub optixAccelCheckRelocationCompatibility: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            info: *const OptixAccelRelocationInfo,
            compatible: *mut ::std::os::raw::c_int,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelRelocate()."]
    pub optixAccelRelocate: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            stream: CUstream,
            info: *const OptixAccelRelocationInfo,
            instanceTraversableHandles: CUdeviceptr,
            numInstanceTraversableHandles: usize,
            targetAccel: CUdeviceptr,
            targetAccelSizeInBytes: usize,
            targetHandle: *mut OptixTraversableHandle,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelCompact()."]
    pub optixAccelCompact: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            stream: CUstream,
            inputHandle: OptixTraversableHandle,
            outputBuffer: CUdeviceptr,
            outputBufferSizeInBytes: usize,
            outputHandle: *mut OptixTraversableHandle,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixConvertPointerToTraversableHandle()."]
    pub optixConvertPointerToTraversableHandle: ::std::option::Option<
        unsafe extern "C" fn(
            onDevice: OptixDeviceContext,
            pointer: CUdeviceptr,
            traversableType: OptixTraversableType,
            traversableHandle: *mut OptixTraversableHandle,
        ) -> OptixResult,
    >,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " See ::optixConvertPointerToTraversableHandle()."]
    pub optixSbtRecordPackHeader: ::std::option::Option<
        unsafe extern "C" fn(
            programGroup: OptixProgramGroup,
            sbtRecordHeaderHostPointer: *mut ::std::os::raw::c_void,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixConvertPointerToTraversableHandle()."]
    pub optixLaunch: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: OptixPipeline,
            stream: CUstream,
            pipelineParams: CUdeviceptr,
            pipelineParamsSize: usize,
            sbt: *const OptixShaderBindingTable,
            width: ::std::os::raw::c_uint,
            height: ::std::os::raw::c_uint,
            depth: ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserCreate()."]
    pub optixDenoiserCreate: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            modelKind: OptixDenoiserModelKind,
            options: *const OptixDenoiserOptions,
            returnHandle: *mut OptixDenoiser,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserDestroy()."]
    pub optixDenoiserDestroy:
        ::std::option::Option<unsafe extern "C" fn(handle: OptixDenoiser) -> OptixResult>,
    #[doc = " See ::optixDenoiserComputeMemoryResources()."]
    pub optixDenoiserComputeMemoryResources: ::std::option::Option<
        unsafe extern "C" fn(
            handle: OptixDenoiser,
            maximumInputWidth: ::std::os::raw::c_uint,
            maximumInputHeight: ::std::os::raw::c_uint,
            returnSizes: *mut OptixDenoiserSizes,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserSetup()."]
    pub optixDenoiserSetup: ::std::option::Option<
        unsafe extern "C" fn(
            denoiser: OptixDenoiser,
            stream: CUstream,
            inputWidth: ::std::os::raw::c_uint,
            inputHeight: ::std::os::raw::c_uint,
            state: CUdeviceptr,
            stateSizeInBytes: usize,
            scratch: CUdeviceptr,
            scratchSizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserInvoke()."]
    pub optixDenoiserInvoke: ::std::option::Option<
        unsafe extern "C" fn(
            denoiser: OptixDenoiser,
            stream: CUstream,
            params: *const OptixDenoiserParams,
            denoiserState: CUdeviceptr,
            denoiserStateSizeInBytes: usize,
            guideLayer: *const OptixDenoiserGuideLayer,
            layers: *const OptixDenoiserLayer,
            numLayers: ::std::os::raw::c_uint,
            inputOffsetX: ::std::os::raw::c_uint,
            inputOffsetY: ::std::os::raw::c_uint,
            scratch: CUdeviceptr,
            scratchSizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserComputeIntensity()."]
    pub optixDenoiserComputeIntensity: ::std::option::Option<
        unsafe extern "C" fn(
            handle: OptixDenoiser,
            stream: CUstream,
            inputImage: *const OptixImage2D,
            outputIntensity: CUdeviceptr,
            scratch: CUdeviceptr,
            scratchSizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserComputeAverageColor()."]
    pub optixDenoiserComputeAverageColor: ::std::option::Option<
        unsafe extern "C" fn(
            handle: OptixDenoiser,
            stream: CUstream,
            inputImage: *const OptixImage2D,
            outputAverageColor: CUdeviceptr,
            scratch: CUdeviceptr,
            scratchSizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserCreateWithUserModel()."]
    pub optixDenoiserCreateWithUserModel: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            data: *const ::std::os::raw::c_void,
            dataSizeInBytes: usize,
            returnHandle: *mut OptixDenoiser,
        ) -> OptixResult,
    >,
}
