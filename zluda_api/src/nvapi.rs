use windows::Win32::Graphics::Direct3D11::*;
use windows::Win32::Graphics::Direct3D12::*;
type D3D12_GPU_VIRTUAL_ADDRESS = u64;

use windows::Win32::Graphics::Dxgi::Common::DXGI_FORMAT;

type DWORD = u64;
type D3D11_RECT = RECT;

/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const NVAPI_DEFAULT_HANDLE: u32 = 0;
pub const NVAPI_GENERIC_STRING_MAX: u32 = 4096;
pub const NVAPI_LONG_STRING_MAX: u32 = 256;
pub const NVAPI_SHORT_STRING_MAX: u32 = 64;
pub const NVAPI_MAX_PHYSICAL_GPUS: u32 = 64;
pub const NVAPI_MAX_PHYSICAL_BRIDGES: u32 = 100;
pub const NVAPI_PHYSICAL_GPUS: u32 = 32;
pub const NVAPI_MAX_LOGICAL_GPUS: u32 = 64;
pub const NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES: u32 = 256;
pub const NVAPI_MAX_AVAILABLE_SLI_GROUPS: u32 = 256;
pub const NVAPI_MAX_GPU_TOPOLOGIES: u32 = 64;
pub const NVAPI_MAX_GPU_PER_TOPOLOGY: u32 = 8;
pub const NVAPI_MAX_DISPLAY_HEADS: u32 = 2;
pub const NVAPI_ADVANCED_DISPLAY_HEADS: u32 = 4;
pub const NVAPI_MAX_DISPLAYS: u32 = 128;
pub const NVAPI_MAX_ACPI_IDS: u32 = 16;
pub const NVAPI_MAX_VIEW_MODES: u32 = 8;
pub const NVAPI_SYSTEM_MAX_HWBCS: u32 = 128;
pub const NVAPI_SYSTEM_HWBC_INVALID_ID: u32 = 4294967295;
pub const NV_MAX_HEADS: u32 = 4;
pub const NVAPI_MAX_HEADS_PER_GPU: u32 = 32;
pub const NV_MAX_VID_STREAMS: u32 = 4;
pub const NV_MAX_VID_STREAMS_EX: u32 = 20;
pub const NV_MAX_VID_PROFILES: u32 = 4;
pub const NVAPI_MAX_AUDIO_DEVICES: u32 = 16;
pub const NV_MOSAIC_MAX_DISPLAYS: u32 = 64;
pub const NV_EDID_V1_DATA_SIZE: u32 = 256;
pub const NV_EDID_DATA_SIZE: u32 = 256;
pub const NVAPI_MAX_VIEW_TARGET: u32 = 2;
pub const NVAPI_ADVANCED_MAX_VIEW_TARGET: u32 = 4;
pub const NV_TIMING_H_SYNC_POSITIVE: u32 = 0;
pub const NV_TIMING_H_SYNC_NEGATIVE: u32 = 1;
pub const NV_TIMING_H_SYNC_DEFAULT: u32 = 1;
pub const NV_TIMING_V_SYNC_POSITIVE: u32 = 0;
pub const NV_TIMING_V_SYNC_NEGATIVE: u32 = 1;
pub const NV_TIMING_V_SYNC_DEFAULT: u32 = 0;
pub const NV_TIMING_PROGRESSIVE: u32 = 0;
pub const NV_TIMING_INTERLACED: u32 = 1;
pub const NV_TIMING_INTERLACED_EXTRA_VBLANK_ON_FIELD2: u32 = 1;
pub const NV_TIMING_INTERLACED_NO_EXTRA_VBLANK_ON_FIELD2: u32 = 2;
pub const NVAPI_MAX_DISPLAY_PATH: u32 = 2;
pub const NVAPI_ADVANCED_MAX_DISPLAY_PATH: u32 = 4;
pub const NVAPI_UNICODE_STRING_MAX: u32 = 2048;
pub const NVAPI_BINARY_DATA_MAX: u32 = 4096;
pub const NVAPI_MAX_GPU_CLOCKS: u32 = 32;
pub const NVAPI_MAX_GPU_PUBLIC_CLOCKS: u32 = 32;
pub const NVAPI_MAX_GPU_PERF_CLOCKS: u32 = 32;
pub const NVAPI_MAX_GPU_PERF_VOLTAGES: u32 = 16;
pub const NVAPI_MAX_GPU_PERF_PSTATES: u32 = 16;
pub const NVAPI_MAX_GPU_PSTATE20_PSTATES: u32 = 16;
pub const NVAPI_MAX_GPU_PSTATE20_CLOCKS: u32 = 8;
pub const NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES: u32 = 4;
pub const NVAPI_OGLEXPERT_DETAIL_NONE: u32 = 0;
pub const NVAPI_OGLEXPERT_DETAIL_ERROR: u32 = 1;
pub const NVAPI_OGLEXPERT_DETAIL_SWFALLBACK: u32 = 2;
pub const NVAPI_OGLEXPERT_DETAIL_BASIC_INFO: u32 = 4;
pub const NVAPI_OGLEXPERT_DETAIL_DETAILED_INFO: u32 = 8;
pub const NVAPI_OGLEXPERT_DETAIL_PERFORMANCE_WARNING: u32 = 16;
pub const NVAPI_OGLEXPERT_DETAIL_QUALITY_WARNING: u32 = 32;
pub const NVAPI_OGLEXPERT_DETAIL_USAGE_WARNING: u32 = 64;
pub const NVAPI_OGLEXPERT_DETAIL_ALL: u32 = 4294967295;
pub const NVAPI_OGLEXPERT_REPORT_NONE: u32 = 0;
pub const NVAPI_OGLEXPERT_REPORT_ERROR: u32 = 1;
pub const NVAPI_OGLEXPERT_REPORT_SWFALLBACK: u32 = 2;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_VERTEX: u32 = 4;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_GEOMETRY: u32 = 8;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_XFB: u32 = 16;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_RASTER: u32 = 32;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAGMENT: u32 = 64;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_ROP: u32 = 128;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAMEBUFFER: u32 = 256;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_PIXEL: u32 = 512;
pub const NVAPI_OGLEXPERT_REPORT_PIPELINE_TEXTURE: u32 = 1024;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_BUFFEROBJECT: u32 = 2048;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_TEXTURE: u32 = 4096;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_PROGRAM: u32 = 8192;
pub const NVAPI_OGLEXPERT_REPORT_OBJECT_FBO: u32 = 16384;
pub const NVAPI_OGLEXPERT_REPORT_FEATURE_SLI: u32 = 32768;
pub const NVAPI_OGLEXPERT_REPORT_ALL: u32 = 4294967295;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_NONE: u32 = 0;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_CONSOLE: u32 = 1;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_DEBUGGER: u32 = 4;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_CALLBACK: u32 = 8;
pub const NVAPI_OGLEXPERT_OUTPUT_TO_ALL: u32 = 4294967295;
pub const NVAPI_MAX_SIZEOF_I2C_DATA_BUFFER: u32 = 4096;
pub const NVAPI_MAX_SIZEOF_I2C_REG_ADDRESS: u32 = 4;
pub const NVAPI_DISPLAY_DEVICE_MASK_MAX: u32 = 24;
pub const NVAPI_I2C_SPEED_DEPRECATED: u32 = 65535;
pub const NV_LICENSE_MAX_COUNT: u32 = 3;
pub const NV_LICENSE_SIGNATURE_SIZE: u32 = 128;
pub const NV_LICENSE_INFO_MAX_LENGTH: u32 = 128;
pub const NVAPI_MAX_GPU_UTILIZATIONS: u32 = 8;
pub const NVAPI_MAX_THERMAL_SENSORS_PER_GPU: u32 = 3;
pub const NV_GPU_MAX_CLOCK_FREQUENCIES: u32 = 3;
pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS: u32 = 2;
pub const NV_GPU_CLIENT_ILLUM_DEVICE_NUM_DEVICES_MAX: u32 = 32;
pub const NV_GPU_CLIENT_ILLUM_ZONE_NUM_ZONES_MAX: u32 = 32;
pub const NV_SOURCE_PID_CURRENT: u32 = 0;
pub const NVAPI_MAX_MOSAIC_DISPLAY_ROWS: u32 = 8;
pub const NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS: u32 = 8;
pub const NV_MOSAIC_TOPO_VALIDITY_VALID: u32 = 0;
pub const NV_MOSAIC_TOPO_VALIDITY_MISSING_GPU: u32 = 1;
pub const NV_MOSAIC_TOPO_VALIDITY_MISSING_DISPLAY: u32 = 2;
pub const NV_MOSAIC_TOPO_VALIDITY_MIXED_DISPLAY_TYPES: u32 = 4;
pub const NV_MOSAIC_DISPLAY_SETTINGS_MAX: u32 = 40;
pub const NV_MOSAIC_TOPO_IDX_DEFAULT: u32 = 0;
pub const NV_MOSAIC_TOPO_IDX_LEFT_EYE: u32 = 0;
pub const NV_MOSAIC_TOPO_IDX_RIGHT_EYE: u32 = 1;
pub const NV_MOSAIC_TOPO_NUM_EYES: u32 = 2;
pub const NV_MOSAIC_MAX_TOPO_PER_TOPO_GROUP: u32 = 2;
pub const NVAPI_MAX_MOSAIC_TOPOS: u32 = 16;
pub const NVAPI_MAX_GSYNC_DEVICES: u32 = 4;
pub const NVAPI_GSYNC_BOARD_ID_P358: u32 = 856;
pub const NVAPI_GSYNC_BOARD_ID_P2060: u32 = 8288;
pub const NVAPI_GSYNC_BOARD_ID_P2061: u32 = 8289;
pub const NVAPI_MAX_RJ45_PER_GSYNC: u32 = 2;
pub const NV_CUSTOM_SEMANTIC_MAX_LIMIT: u32 = 32;
pub const NVAPI_UAV_INFO_VER1: u32 = 1;
pub const NV_META_COMMAND_MAX_TENSOR_DIM: u32 = 5;
pub const NV_META_COMMAND_ACTIVATION_MAX_PARAMS: u32 = 2;
pub const NV_META_COMMAND_NUM_SPATIAL_DIM: u32 = 3;
pub const NVAPI_COPY_ASYNCHRONOUSLY: u32 = 1;
pub const NVAPI_COPY_P2P_READ: u32 = 2;
pub const NVAPI_CPU_RESOURCE: u32 = 4294967295;
pub const NVAPI_PRESENT_COMPOSITING_CONFIG_FLAG_USE_VIDEO_BRIDGE: u32 = 1;
pub const NVAPI_PRESENT_COMPOSITING_CONFIG_FLAG_CLEAR_OUTBANDS: u32 = 2;
pub const NVAPI_PRESENT_COMPOSITING_CONFIG_FLAG_GET_VIDEO_BRIDGE_STATUS: u32 = 2147483648;
pub const NVAPI_VIDEO_BRIDGE_STATUS_AVAILABLE: u32 = 0;
pub const NVAPI_VIDEO_BRIDGE_STATUS_NOT_AVAILABLE: u32 = 1;
pub const NVAPI_VIDEO_BRIDGE_STATUS_FAILED_ACCESS: u32 = 2;
pub const NVAPI_VIDEO_BRIDGE_STATUS_UNKNOWN: u32 = 3;
pub const NVAPI_ALL_GPUS: u32 = 0;
pub const NV_MULTIVIEW_MAX_SUPPORTED_VIEWS: u32 = 4;
pub const NV_MODIFIED_W_MAX_VIEWPORTS: u32 = 16;
pub const NV_MAX_NUM_EXCLUSIVE_SCISSOR_RECTS: u32 = 16;
pub const NV_MAX_PIXEL_SHADING_RATES: u32 = 16;
pub const NV_MAX_NUM_VIEWPORTS: u32 = 16;
pub const NV_VARIABLE_PIXEL_SHADING_TILE_WIDTH: u32 = 16;
pub const NV_VARIABLE_PIXEL_SHADING_TILE_HEIGHT: u32 = 16;
pub const NV_SMP_ASSIST_FLAGS_DEFAULT: u32 = 0;
pub const NV_SMP_ASSIST_MAX_VIEWPORTS: u32 = 16;
pub const NV_SMP_ASSIST_MINIMAL_LEVEL_NUM_EYE_INDICES: u32 = 4;
pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BYTE_ALIGNMENT: u32 = 256;
pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_OC1_MAX_SUBDIVISION_LEVEL: u32 = 12;
pub const NVVIOOWNERID_NONE: u32 = 0;
pub const NVVIO_O_READ: u32 = 0;
pub const NVVIO_O_WRITE_EXCLUSIVE: u32 = 65537;
pub const NVVIO_VALID_ACCESSRIGHTS: u32 = 65537;
pub const NVVIO_OWNERID_INITIALIZED: u32 = 2147483648;
pub const NVVIO_OWNERID_EXCLUSIVE: u32 = 1073741824;
pub const NVVIO_OWNERID_TYPEMASK: u32 = 268435455;
pub const NVAPI_MAX_VIO_DEVICES: u32 = 8;
pub const NVAPI_MAX_VIO_JACKS: u32 = 4;
pub const NVAPI_MAX_VIO_CHANNELS_PER_JACK: u32 = 2;
pub const NVAPI_MAX_VIO_STREAMS: u32 = 4;
pub const NVAPI_MIN_VIO_STREAMS: u32 = 1;
pub const NVAPI_MAX_VIO_LINKS_PER_STREAM: u32 = 2;
pub const NVAPI_MAX_FRAMELOCK_MAPPING_MODES: u32 = 20;
pub const NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES: u32 = 1;
pub const NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES: u32 = 32;
pub const NVAPI_GVI_DEFAULT_RAW_CAPTURE_IMAGES: u32 = 5;
pub const NVVIOCAPS_VIDOUT_SDI: u32 = 1;
pub const NVVIOCAPS_SYNC_INTERNAL: u32 = 256;
pub const NVVIOCAPS_SYNC_GENLOCK: u32 = 512;
pub const NVVIOCAPS_SYNCSRC_SDI: u32 = 4096;
pub const NVVIOCAPS_SYNCSRC_COMP: u32 = 8192;
pub const NVVIOCAPS_OUTPUTMODE_DESKTOP: u32 = 65536;
pub const NVVIOCAPS_OUTPUTMODE_OPENGL: u32 = 131072;
pub const NVVIOCAPS_VIDIN_SDI: u32 = 1048576;
pub const NVVIOCAPS_PACKED_ANC_SUPPORTED: u32 = 2097152;
pub const NVVIOCAPS_AUDIO_BLANKING_SUPPORTED: u32 = 4194304;
pub const NVVIOCLASS_SDI: u32 = 1;
pub const NVVIOBUFFERFORMAT_R8G8B8: u32 = 1;
pub const NVVIOBUFFERFORMAT_R8G8B8Z24: u32 = 2;
pub const NVVIOBUFFERFORMAT_R8G8B8A8: u32 = 4;
pub const NVVIOBUFFERFORMAT_R8G8B8A8Z24: u32 = 8;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FP: u32 = 16;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FPZ24: u32 = 32;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FP: u32 = 64;
pub const NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FPZ24: u32 = 128;
pub const NVVIOCONFIG_SIGNALFORMAT: u32 = 1;
pub const NVVIOCONFIG_DATAFORMAT: u32 = 2;
pub const NVVIOCONFIG_OUTPUTREGION: u32 = 4;
pub const NVVIOCONFIG_OUTPUTAREA: u32 = 8;
pub const NVVIOCONFIG_COLORCONVERSION: u32 = 16;
pub const NVVIOCONFIG_GAMMACORRECTION: u32 = 32;
pub const NVVIOCONFIG_SYNCSOURCEENABLE: u32 = 64;
pub const NVVIOCONFIG_SYNCDELAY: u32 = 128;
pub const NVVIOCONFIG_COMPOSITESYNCTYPE: u32 = 256;
pub const NVVIOCONFIG_FRAMELOCKENABLE: u32 = 512;
pub const NVVIOCONFIG_422FILTER: u32 = 1024;
pub const NVVIOCONFIG_COMPOSITETERMINATE: u32 = 2048;
pub const NVVIOCONFIG_DATAINTEGRITYCHECK: u32 = 4096;
pub const NVVIOCONFIG_CSCOVERRIDE: u32 = 8192;
pub const NVVIOCONFIG_FLIPQUEUELENGTH: u32 = 16384;
pub const NVVIOCONFIG_ANCTIMECODEGENERATION: u32 = 32768;
pub const NVVIOCONFIG_COMPOSITE: u32 = 65536;
pub const NVVIOCONFIG_ALPHAKEYCOMPOSITE: u32 = 131072;
pub const NVVIOCONFIG_COMPOSITE_Y: u32 = 262144;
pub const NVVIOCONFIG_COMPOSITE_CR: u32 = 524288;
pub const NVVIOCONFIG_COMPOSITE_CB: u32 = 1048576;
pub const NVVIOCONFIG_FULL_COLOR_RANGE: u32 = 2097152;
pub const NVVIOCONFIG_RGB_DATA: u32 = 4194304;
pub const NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE: u32 = 8388608;
pub const NVVIOCONFIG_STREAMS: u32 = 16777216;
pub const NVVIOCONFIG_ANC_PARITY_COMPUTATION: u32 = 33554432;
pub const NVVIOCONFIG_ANC_AUDIO_REPEAT: u32 = 67108864;
pub const NVVIOCONFIG_ALLFIELDS: u32 = 134217727;
pub const NVVIOCONFIG_VALIDFIELDS: u32 = 134217727;
pub const NVVIOCONFIG_DRIVERFIELDS: u32 = 16412;
pub const NVVIOCONFIG_GAMMAFIELDS: u32 = 32;
pub const NVVIOCONFIG_RMCTRLFIELDS: u32 = 2039619;
pub const NVVIOCONFIG_RMSKEWFIELDS: u32 = 128;
pub const NVVIOCONFIG_ALLOWSDIRUNNING_FIELDS: u32 = 35631232;
pub const NVVIOCONFIG_RMMODESET_FIELDS: u32 = 67109699;
pub const NVAPI_STEREO_QUADBUFFERED_API_VERSION: u32 = 2;
pub const NVAPI_SETTING_MAX_VALUES: u32 = 100;
pub const NV_GPU_CLIENT_UTIL_DOMAINS_MAX_V1: u32 = 4;
pub type ULONG = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type FLOAT = f32;
pub type LPVOID = *mut ::std::os::raw::c_void;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type CHAR = ::std::os::raw::c_char;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = u16;
pub type LPCWSTR = *const WCHAR;
pub type LPSTR = *mut CHAR;
pub type LPCSTR = *const CHAR;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type HRESULT = ::std::os::raw::c_long;
#[repr(C)]
pub struct _LUID {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
pub type LUID = _LUID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
pub type GUID = _GUID;
pub type IID = GUID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MEMORY_RANGE {
    pub BaseAddress: *mut ::std::os::raw::c_void,
    pub Length: SIZE_T,
}
pub type NV_MEMORY_RANGE = _NV_MEMORY_RANGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagRECT {
    pub left: LONG,
    pub top: LONG,
    pub right: LONG,
    pub bottom: LONG,
}
pub type RECT = tagRECT;
#[repr(C)]
pub struct _SECURITY_ATTRIBUTES {
    pub nLength: DWORD,
    pub lpSecurityDescriptor: LPVOID,
    pub bInheritHandle: BOOL,
}
pub type SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES;
#[repr(C)]
pub struct IUnknown__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IUnknown {
    pub vtable_: *const IUnknown__bindgen_vtable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D10Blob {
    pub _base: IUnknown,
}
pub type ID3DBlob = ID3D10Blob;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11DeviceChild {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11DepthStencilState {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11BlendState {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11RasterizerState {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Resource {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Buffer {
    pub _base: ID3D11Resource,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Texture1D {
    pub _base: ID3D11Resource,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Texture2D {
    pub _base: ID3D11Resource,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Texture3D {
    pub _base: ID3D11Resource,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11View {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11ShaderResourceView {
    pub _base: ID3D11View,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11RenderTargetView {
    pub _base: ID3D11View,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11DepthStencilView {
    pub _base: ID3D11View,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11UnorderedAccessView {
    pub _base: ID3D11View,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11VertexShader {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11HullShader {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11DomainShader {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11GeometryShader {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11PixelShader {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11ComputeShader {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11InputLayout {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11SamplerState {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Asynchronous {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Query {
    pub _base: ID3D11Asynchronous,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Predicate {
    pub _base: ID3D11Query,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Counter {
    pub _base: ID3D11Asynchronous,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11ClassInstance {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11ClassLinkage {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11CommandList {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11DeviceContext {
    pub _base: ID3D11DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D11Device {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D12Object {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D12DeviceChild {
    pub _base: ID3D12Object,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D12RootSignature {
    pub _base: ID3D12DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D12Pageable {
    pub _base: ID3D12DeviceChild,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D12Heap {
    pub _base: ID3D12Pageable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D12Resource {
    pub _base: ID3D12Pageable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D12CommandAllocator {
    pub _base: ID3D12Pageable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D12PipelineState {
    pub _base: ID3D12Pageable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3D12Device {
    pub _base: ID3D12Object,
}
pub type NvU64 = ::std::os::raw::c_ulonglong;
pub type NvS64 = ::std::os::raw::c_longlong;
pub type NvS32 = ::std::os::raw::c_int;
pub type NvU32 = ::std::os::raw::c_ulong;
pub type NvS16 = ::std::os::raw::c_short;
pub type NvU16 = ::std::os::raw::c_ushort;
pub type NvU8 = ::std::os::raw::c_uchar;
pub type NvS8 = ::std::os::raw::c_schar;
pub type NvF32 = f32;
pub type NvF64 = f64;
pub type NvBool = NvU8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_RECT {
    pub left: NvU32,
    pub top: NvU32,
    pub right: NvU32,
    pub bottom: NvU32,
}
pub type NV_RECT = _NV_RECT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvLogicalGpuHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvLogicalGpuHandle = *mut NvLogicalGpuHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvPhysicalGpuHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvPhysicalGpuHandle = *mut NvPhysicalGpuHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvDisplayHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvDisplayHandle = *mut NvDisplayHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvMonitorHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvMonitorHandle = *mut NvMonitorHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvUnAttachedDisplayHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvUnAttachedDisplayHandle = *mut NvUnAttachedDisplayHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvVisualComputingDeviceHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvVisualComputingDeviceHandle = *mut NvVisualComputingDeviceHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvEventHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvEventHandle = *mut NvEventHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvHICHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvHICHandle = *mut NvHICHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvGSyncDeviceHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvGSyncDeviceHandle = *mut NvGSyncDeviceHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvVioHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvVioHandle = *mut NvVioHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvTransitionHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvTransitionHandle = *mut NvTransitionHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAudioHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvAudioHandle = *mut NvAudioHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Nv3DVPContextHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type Nv3DVPContextHandle = *mut Nv3DVPContextHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Nv3DVPTransceiverHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type Nv3DVPTransceiverHandle = *mut Nv3DVPTransceiverHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Nv3DVPGlassesHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type Nv3DVPGlassesHandle = *mut Nv3DVPGlassesHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvPcfClientHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvPcfClientHandle = *mut NvPcfClientHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvSourceHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvSourceHandle = *mut NvSourceHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvTargetHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvTargetHandle = *mut NvTargetHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVDX_SwapChainHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NVDX_SwapChainHandle = *mut NVDX_SwapChainHandle__;
extern "C" {
    pub static NVDX_SWAPCHAIN_NONE: NVDX_SwapChainHandle;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvPresentBarrierClientHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvPresentBarrierClientHandle = *mut NvPresentBarrierClientHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvSBox {
    pub sX: NvS32,
    pub sY: NvS32,
    pub sWidth: NvS32,
    pub sHeight: NvS32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvGUID {
    pub data1: NvU32,
    pub data2: NvU16,
    pub data3: NvU16,
    pub data4: [NvU8; 8usize],
}
pub type NvLUID = NvGUID;
pub type NvAPI_String = [::std::os::raw::c_char; 4096usize];
pub type NvAPI_LongString = [::std::os::raw::c_char; 256usize];
pub type NvAPI_ShortString = [::std::os::raw::c_char; 64usize];
pub type NvAPI_UnicodeShortString = [NvU16; 64usize];
impl _NvAPI_Status {
    pub const NVAPI_OK: _NvAPI_Status = _NvAPI_Status(0);
}
impl _NvAPI_Status {
    pub const NVAPI_ERROR: _NvAPI_Status = _NvAPI_Status(-1);
}
impl _NvAPI_Status {
    pub const NVAPI_LIBRARY_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-2);
}
impl _NvAPI_Status {
    pub const NVAPI_NO_IMPLEMENTATION: _NvAPI_Status = _NvAPI_Status(-3);
}
impl _NvAPI_Status {
    pub const NVAPI_API_NOT_INITIALIZED: _NvAPI_Status = _NvAPI_Status(-4);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_ARGUMENT: _NvAPI_Status = _NvAPI_Status(-5);
}
impl _NvAPI_Status {
    pub const NVAPI_NVIDIA_DEVICE_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-6);
}
impl _NvAPI_Status {
    pub const NVAPI_END_ENUMERATION: _NvAPI_Status = _NvAPI_Status(-7);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_HANDLE: _NvAPI_Status = _NvAPI_Status(-8);
}
impl _NvAPI_Status {
    pub const NVAPI_INCOMPATIBLE_STRUCT_VERSION: _NvAPI_Status = _NvAPI_Status(-9);
}
impl _NvAPI_Status {
    pub const NVAPI_HANDLE_INVALIDATED: _NvAPI_Status = _NvAPI_Status(-10);
}
impl _NvAPI_Status {
    pub const NVAPI_OPENGL_CONTEXT_NOT_CURRENT: _NvAPI_Status = _NvAPI_Status(-11);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_POINTER: _NvAPI_Status = _NvAPI_Status(-14);
}
impl _NvAPI_Status {
    pub const NVAPI_NO_GL_EXPERT: _NvAPI_Status = _NvAPI_Status(-12);
}
impl _NvAPI_Status {
    pub const NVAPI_INSTRUMENTATION_DISABLED: _NvAPI_Status = _NvAPI_Status(-13);
}
impl _NvAPI_Status {
    pub const NVAPI_NO_GL_NSIGHT: _NvAPI_Status = _NvAPI_Status(-15);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_LOGICAL_GPU_HANDLE: _NvAPI_Status = _NvAPI_Status(-100);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: _NvAPI_Status = _NvAPI_Status(-101);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_DISPLAY_HANDLE: _NvAPI_Status = _NvAPI_Status(-102);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_COMBINATION: _NvAPI_Status = _NvAPI_Status(-103);
}
impl _NvAPI_Status {
    pub const NVAPI_NOT_SUPPORTED: _NvAPI_Status = _NvAPI_Status(-104);
}
impl _NvAPI_Status {
    pub const NVAPI_PORTID_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-105);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_UNATTACHED_DISPLAY_HANDLE: _NvAPI_Status = _NvAPI_Status(-106);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_PERF_LEVEL: _NvAPI_Status = _NvAPI_Status(-107);
}
impl _NvAPI_Status {
    pub const NVAPI_DEVICE_BUSY: _NvAPI_Status = _NvAPI_Status(-108);
}
impl _NvAPI_Status {
    pub const NVAPI_NV_PERSIST_FILE_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-109);
}
impl _NvAPI_Status {
    pub const NVAPI_PERSIST_DATA_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-110);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_TV_DISPLAY: _NvAPI_Status = _NvAPI_Status(-111);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_TV_DISPLAY_ON_DCONNECTOR: _NvAPI_Status = _NvAPI_Status(-112);
}
impl _NvAPI_Status {
    pub const NVAPI_NO_ACTIVE_SLI_TOPOLOGY: _NvAPI_Status = _NvAPI_Status(-113);
}
impl _NvAPI_Status {
    pub const NVAPI_SLI_RENDERING_MODE_NOTALLOWED: _NvAPI_Status = _NvAPI_Status(-114);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_DIGITAL_FLAT_PANEL: _NvAPI_Status = _NvAPI_Status(-115);
}
impl _NvAPI_Status {
    pub const NVAPI_ARGUMENT_EXCEED_MAX_SIZE: _NvAPI_Status = _NvAPI_Status(-116);
}
impl _NvAPI_Status {
    pub const NVAPI_DEVICE_SWITCHING_NOT_ALLOWED: _NvAPI_Status = _NvAPI_Status(-117);
}
impl _NvAPI_Status {
    pub const NVAPI_TESTING_CLOCKS_NOT_SUPPORTED: _NvAPI_Status = _NvAPI_Status(-118);
}
impl _NvAPI_Status {
    pub const NVAPI_UNKNOWN_UNDERSCAN_CONFIG: _NvAPI_Status = _NvAPI_Status(-119);
}
impl _NvAPI_Status {
    pub const NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO: _NvAPI_Status = _NvAPI_Status(-120);
}
impl _NvAPI_Status {
    pub const NVAPI_DATA_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-121);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_ANALOG_DISPLAY: _NvAPI_Status = _NvAPI_Status(-122);
}
impl _NvAPI_Status {
    pub const NVAPI_NO_VIDLINK: _NvAPI_Status = _NvAPI_Status(-123);
}
impl _NvAPI_Status {
    pub const NVAPI_REQUIRES_REBOOT: _NvAPI_Status = _NvAPI_Status(-124);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_HYBRID_MODE: _NvAPI_Status = _NvAPI_Status(-125);
}
impl _NvAPI_Status {
    pub const NVAPI_MIXED_TARGET_TYPES: _NvAPI_Status = _NvAPI_Status(-126);
}
impl _NvAPI_Status {
    pub const NVAPI_SYSWOW64_NOT_SUPPORTED: _NvAPI_Status = _NvAPI_Status(-127);
}
impl _NvAPI_Status {
    pub const NVAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED: _NvAPI_Status =
        _NvAPI_Status(-128);
}
impl _NvAPI_Status {
    pub const NVAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS: _NvAPI_Status = _NvAPI_Status(-129);
}
impl _NvAPI_Status {
    pub const NVAPI_OUT_OF_MEMORY: _NvAPI_Status = _NvAPI_Status(-130);
}
impl _NvAPI_Status {
    pub const NVAPI_WAS_STILL_DRAWING: _NvAPI_Status = _NvAPI_Status(-131);
}
impl _NvAPI_Status {
    pub const NVAPI_FILE_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-132);
}
impl _NvAPI_Status {
    pub const NVAPI_TOO_MANY_UNIQUE_STATE_OBJECTS: _NvAPI_Status = _NvAPI_Status(-133);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_CALL: _NvAPI_Status = _NvAPI_Status(-134);
}
impl _NvAPI_Status {
    pub const NVAPI_D3D10_1_LIBRARY_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-135);
}
impl _NvAPI_Status {
    pub const NVAPI_FUNCTION_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-136);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_USER_PRIVILEGE: _NvAPI_Status = _NvAPI_Status(-137);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE: _NvAPI_Status = _NvAPI_Status(-138);
}
impl _NvAPI_Status {
    pub const NVAPI_EXPECTED_COMPUTE_GPU_HANDLE: _NvAPI_Status = _NvAPI_Status(-139);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_NOT_INITIALIZED: _NvAPI_Status = _NvAPI_Status(-140);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_REGISTRY_ACCESS_FAILED: _NvAPI_Status = _NvAPI_Status(-141);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED: _NvAPI_Status = _NvAPI_Status(-142);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED: _NvAPI_Status = _NvAPI_Status(-143);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_NOT_ENABLED: _NvAPI_Status = _NvAPI_Status(-144);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_NOT_TURNED_ON: _NvAPI_Status = _NvAPI_Status(-145);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_INVALID_DEVICE_INTERFACE: _NvAPI_Status = _NvAPI_Status(-146);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_PARAMETER_OUT_OF_RANGE: _NvAPI_Status = _NvAPI_Status(-147);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED: _NvAPI_Status = _NvAPI_Status(-148);
}
impl _NvAPI_Status {
    pub const NVAPI_TOPO_NOT_POSSIBLE: _NvAPI_Status = _NvAPI_Status(-149);
}
impl _NvAPI_Status {
    pub const NVAPI_MODE_CHANGE_FAILED: _NvAPI_Status = _NvAPI_Status(-150);
}
impl _NvAPI_Status {
    pub const NVAPI_D3D11_LIBRARY_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-151);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_ADDRESS: _NvAPI_Status = _NvAPI_Status(-152);
}
impl _NvAPI_Status {
    pub const NVAPI_STRING_TOO_SMALL: _NvAPI_Status = _NvAPI_Status(-153);
}
impl _NvAPI_Status {
    pub const NVAPI_MATCHING_DEVICE_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-154);
}
impl _NvAPI_Status {
    pub const NVAPI_DRIVER_RUNNING: _NvAPI_Status = _NvAPI_Status(-155);
}
impl _NvAPI_Status {
    pub const NVAPI_DRIVER_NOTRUNNING: _NvAPI_Status = _NvAPI_Status(-156);
}
impl _NvAPI_Status {
    pub const NVAPI_ERROR_DRIVER_RELOAD_REQUIRED: _NvAPI_Status = _NvAPI_Status(-157);
}
impl _NvAPI_Status {
    pub const NVAPI_SET_NOT_ALLOWED: _NvAPI_Status = _NvAPI_Status(-158);
}
impl _NvAPI_Status {
    pub const NVAPI_ADVANCED_DISPLAY_TOPOLOGY_REQUIRED: _NvAPI_Status = _NvAPI_Status(-159);
}
impl _NvAPI_Status {
    pub const NVAPI_SETTING_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-160);
}
impl _NvAPI_Status {
    pub const NVAPI_SETTING_SIZE_TOO_LARGE: _NvAPI_Status = _NvAPI_Status(-161);
}
impl _NvAPI_Status {
    pub const NVAPI_TOO_MANY_SETTINGS_IN_PROFILE: _NvAPI_Status = _NvAPI_Status(-162);
}
impl _NvAPI_Status {
    pub const NVAPI_PROFILE_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-163);
}
impl _NvAPI_Status {
    pub const NVAPI_PROFILE_NAME_IN_USE: _NvAPI_Status = _NvAPI_Status(-164);
}
impl _NvAPI_Status {
    pub const NVAPI_PROFILE_NAME_EMPTY: _NvAPI_Status = _NvAPI_Status(-165);
}
impl _NvAPI_Status {
    pub const NVAPI_EXECUTABLE_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-166);
}
impl _NvAPI_Status {
    pub const NVAPI_EXECUTABLE_ALREADY_IN_USE: _NvAPI_Status = _NvAPI_Status(-167);
}
impl _NvAPI_Status {
    pub const NVAPI_DATATYPE_MISMATCH: _NvAPI_Status = _NvAPI_Status(-168);
}
impl _NvAPI_Status {
    pub const NVAPI_PROFILE_REMOVED: _NvAPI_Status = _NvAPI_Status(-169);
}
impl _NvAPI_Status {
    pub const NVAPI_UNREGISTERED_RESOURCE: _NvAPI_Status = _NvAPI_Status(-170);
}
impl _NvAPI_Status {
    pub const NVAPI_ID_OUT_OF_RANGE: _NvAPI_Status = _NvAPI_Status(-171);
}
impl _NvAPI_Status {
    pub const NVAPI_DISPLAYCONFIG_VALIDATION_FAILED: _NvAPI_Status = _NvAPI_Status(-172);
}
impl _NvAPI_Status {
    pub const NVAPI_DPMST_CHANGED: _NvAPI_Status = _NvAPI_Status(-173);
}
impl _NvAPI_Status {
    pub const NVAPI_INSUFFICIENT_BUFFER: _NvAPI_Status = _NvAPI_Status(-174);
}
impl _NvAPI_Status {
    pub const NVAPI_ACCESS_DENIED: _NvAPI_Status = _NvAPI_Status(-175);
}
impl _NvAPI_Status {
    pub const NVAPI_MOSAIC_NOT_ACTIVE: _NvAPI_Status = _NvAPI_Status(-176);
}
impl _NvAPI_Status {
    pub const NVAPI_SHARE_RESOURCE_RELOCATED: _NvAPI_Status = _NvAPI_Status(-177);
}
impl _NvAPI_Status {
    pub const NVAPI_REQUEST_USER_TO_DISABLE_DWM: _NvAPI_Status = _NvAPI_Status(-178);
}
impl _NvAPI_Status {
    pub const NVAPI_D3D_DEVICE_LOST: _NvAPI_Status = _NvAPI_Status(-179);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_CONFIGURATION: _NvAPI_Status = _NvAPI_Status(-180);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_HANDSHAKE_NOT_DONE: _NvAPI_Status = _NvAPI_Status(-181);
}
impl _NvAPI_Status {
    pub const NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS: _NvAPI_Status = _NvAPI_Status(-182);
}
impl _NvAPI_Status {
    pub const NVAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED: _NvAPI_Status = _NvAPI_Status(-183);
}
impl _NvAPI_Status {
    pub const NVAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST: _NvAPI_Status = _NvAPI_Status(-184);
}
impl _NvAPI_Status {
    pub const NVAPI_CLUSTER_ALREADY_EXISTS: _NvAPI_Status = _NvAPI_Status(-185);
}
impl _NvAPI_Status {
    pub const NVAPI_DPMST_DISPLAY_ID_EXPECTED: _NvAPI_Status = _NvAPI_Status(-186);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_DISPLAY_ID: _NvAPI_Status = _NvAPI_Status(-187);
}
impl _NvAPI_Status {
    pub const NVAPI_STREAM_IS_OUT_OF_SYNC: _NvAPI_Status = _NvAPI_Status(-188);
}
impl _NvAPI_Status {
    pub const NVAPI_INCOMPATIBLE_AUDIO_DRIVER: _NvAPI_Status = _NvAPI_Status(-189);
}
impl _NvAPI_Status {
    pub const NVAPI_VALUE_ALREADY_SET: _NvAPI_Status = _NvAPI_Status(-190);
}
impl _NvAPI_Status {
    pub const NVAPI_TIMEOUT: _NvAPI_Status = _NvAPI_Status(-191);
}
impl _NvAPI_Status {
    pub const NVAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE: _NvAPI_Status = _NvAPI_Status(-192);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_INIT_ACTIVATION_NOT_DONE: _NvAPI_Status = _NvAPI_Status(-193);
}
impl _NvAPI_Status {
    pub const NVAPI_SYNC_NOT_ACTIVE: _NvAPI_Status = _NvAPI_Status(-194);
}
impl _NvAPI_Status {
    pub const NVAPI_SYNC_MASTER_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-195);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_SYNC_TOPOLOGY: _NvAPI_Status = _NvAPI_Status(-196);
}
impl _NvAPI_Status {
    pub const NVAPI_ECID_SIGN_ALGO_UNSUPPORTED: _NvAPI_Status = _NvAPI_Status(-197);
}
impl _NvAPI_Status {
    pub const NVAPI_ECID_KEY_VERIFICATION_FAILED: _NvAPI_Status = _NvAPI_Status(-198);
}
impl _NvAPI_Status {
    pub const NVAPI_FIRMWARE_OUT_OF_DATE: _NvAPI_Status = _NvAPI_Status(-199);
}
impl _NvAPI_Status {
    pub const NVAPI_FIRMWARE_REVISION_NOT_SUPPORTED: _NvAPI_Status = _NvAPI_Status(-200);
}
impl _NvAPI_Status {
    pub const NVAPI_LICENSE_CALLER_AUTHENTICATION_FAILED: _NvAPI_Status = _NvAPI_Status(-201);
}
impl _NvAPI_Status {
    pub const NVAPI_D3D_DEVICE_NOT_REGISTERED: _NvAPI_Status = _NvAPI_Status(-202);
}
impl _NvAPI_Status {
    pub const NVAPI_RESOURCE_NOT_ACQUIRED: _NvAPI_Status = _NvAPI_Status(-203);
}
impl _NvAPI_Status {
    pub const NVAPI_TIMING_NOT_SUPPORTED: _NvAPI_Status = _NvAPI_Status(-204);
}
impl _NvAPI_Status {
    pub const NVAPI_HDCP_ENCRYPTION_FAILED: _NvAPI_Status = _NvAPI_Status(-205);
}
impl _NvAPI_Status {
    pub const NVAPI_PCLK_LIMITATION_FAILED: _NvAPI_Status = _NvAPI_Status(-206);
}
impl _NvAPI_Status {
    pub const NVAPI_NO_CONNECTOR_FOUND: _NvAPI_Status = _NvAPI_Status(-207);
}
impl _NvAPI_Status {
    pub const NVAPI_HDCP_DISABLED: _NvAPI_Status = _NvAPI_Status(-208);
}
impl _NvAPI_Status {
    pub const NVAPI_API_IN_USE: _NvAPI_Status = _NvAPI_Status(-209);
}
impl _NvAPI_Status {
    pub const NVAPI_NVIDIA_DISPLAY_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-210);
}
impl _NvAPI_Status {
    pub const NVAPI_PRIV_SEC_VIOLATION: _NvAPI_Status = _NvAPI_Status(-211);
}
impl _NvAPI_Status {
    pub const NVAPI_INCORRECT_VENDOR: _NvAPI_Status = _NvAPI_Status(-212);
}
impl _NvAPI_Status {
    pub const NVAPI_DISPLAY_IN_USE: _NvAPI_Status = _NvAPI_Status(-213);
}
impl _NvAPI_Status {
    pub const NVAPI_UNSUPPORTED_CONFIG_NON_HDCP_HMD: _NvAPI_Status = _NvAPI_Status(-214);
}
impl _NvAPI_Status {
    pub const NVAPI_MAX_DISPLAY_LIMIT_REACHED: _NvAPI_Status = _NvAPI_Status(-215);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_DIRECT_MODE_DISPLAY: _NvAPI_Status = _NvAPI_Status(-216);
}
impl _NvAPI_Status {
    pub const NVAPI_GPU_IN_DEBUG_MODE: _NvAPI_Status = _NvAPI_Status(-217);
}
impl _NvAPI_Status {
    pub const NVAPI_D3D_CONTEXT_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-218);
}
impl _NvAPI_Status {
    pub const NVAPI_STEREO_VERSION_MISMATCH: _NvAPI_Status = _NvAPI_Status(-219);
}
impl _NvAPI_Status {
    pub const NVAPI_GPU_NOT_POWERED: _NvAPI_Status = _NvAPI_Status(-220);
}
impl _NvAPI_Status {
    pub const NVAPI_ERROR_DRIVER_RELOAD_IN_PROGRESS: _NvAPI_Status = _NvAPI_Status(-221);
}
impl _NvAPI_Status {
    pub const NVAPI_WAIT_FOR_HW_RESOURCE: _NvAPI_Status = _NvAPI_Status(-222);
}
impl _NvAPI_Status {
    pub const NVAPI_REQUIRE_FURTHER_HDCP_ACTION: _NvAPI_Status = _NvAPI_Status(-223);
}
impl _NvAPI_Status {
    pub const NVAPI_DISPLAY_MUX_TRANSITION_FAILED: _NvAPI_Status = _NvAPI_Status(-224);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_DSC_VERSION: _NvAPI_Status = _NvAPI_Status(-225);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_DSC_SLICECOUNT: _NvAPI_Status = _NvAPI_Status(-226);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_DSC_OUTPUT_BPP: _NvAPI_Status = _NvAPI_Status(-227);
}
impl _NvAPI_Status {
    pub const NVAPI_FAILED_TO_LOAD_FROM_DRIVER_STORE: _NvAPI_Status = _NvAPI_Status(-228);
}
impl _NvAPI_Status {
    pub const NVAPI_NO_VULKAN: _NvAPI_Status = _NvAPI_Status(-229);
}
impl _NvAPI_Status {
    pub const NVAPI_REQUEST_PENDING: _NvAPI_Status = _NvAPI_Status(-230);
}
impl _NvAPI_Status {
    pub const NVAPI_RESOURCE_IN_USE: _NvAPI_Status = _NvAPI_Status(-231);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_IMAGE: _NvAPI_Status = _NvAPI_Status(-232);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_PTX: _NvAPI_Status = _NvAPI_Status(-233);
}
impl _NvAPI_Status {
    pub const NVAPI_NVLINK_UNCORRECTABLE: _NvAPI_Status = _NvAPI_Status(-234);
}
impl _NvAPI_Status {
    pub const NVAPI_JIT_COMPILER_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-235);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_SOURCE: _NvAPI_Status = _NvAPI_Status(-236);
}
impl _NvAPI_Status {
    pub const NVAPI_ILLEGAL_INSTRUCTION: _NvAPI_Status = _NvAPI_Status(-237);
}
impl _NvAPI_Status {
    pub const NVAPI_INVALID_PC: _NvAPI_Status = _NvAPI_Status(-238);
}
impl _NvAPI_Status {
    pub const NVAPI_LAUNCH_FAILED: _NvAPI_Status = _NvAPI_Status(-239);
}
impl _NvAPI_Status {
    pub const NVAPI_NOT_PERMITTED: _NvAPI_Status = _NvAPI_Status(-240);
}
impl _NvAPI_Status {
    pub const NVAPI_CALLBACK_ALREADY_REGISTERED: _NvAPI_Status = _NvAPI_Status(-241);
}
impl _NvAPI_Status {
    pub const NVAPI_CALLBACK_NOT_FOUND: _NvAPI_Status = _NvAPI_Status(-242);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NvAPI_Status(pub ::std::os::raw::c_int);
pub use self::_NvAPI_Status as NvAPI_Status;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_MEMORY_INFO_V1 {
    pub version: NvU32,
    pub dedicatedVideoMemory: NvU32,
    pub availableDedicatedVideoMemory: NvU32,
    pub systemVideoMemory: NvU32,
    pub sharedSystemMemory: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_MEMORY_INFO_V2 {
    pub version: NvU32,
    pub dedicatedVideoMemory: NvU32,
    pub availableDedicatedVideoMemory: NvU32,
    pub systemVideoMemory: NvU32,
    pub sharedSystemMemory: NvU32,
    pub curAvailableDedicatedVideoMemory: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_MEMORY_INFO_V3 {
    pub version: NvU32,
    pub dedicatedVideoMemory: NvU32,
    pub availableDedicatedVideoMemory: NvU32,
    pub systemVideoMemory: NvU32,
    pub sharedSystemMemory: NvU32,
    pub curAvailableDedicatedVideoMemory: NvU32,
    pub dedicatedVideoMemoryEvictionsSize: NvU32,
    pub dedicatedVideoMemoryEvictionCount: NvU32,
}
pub type NV_DISPLAY_DRIVER_MEMORY_INFO = NV_DISPLAY_DRIVER_MEMORY_INFO_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_MEMORY_INFO_EX_V1 {
    pub version: NvU32,
    pub dedicatedVideoMemory: NvU64,
    pub availableDedicatedVideoMemory: NvU64,
    pub systemVideoMemory: NvU64,
    pub sharedSystemMemory: NvU64,
    pub curAvailableDedicatedVideoMemory: NvU64,
    pub dedicatedVideoMemoryEvictionsSize: NvU64,
    pub dedicatedVideoMemoryEvictionCount: NvU64,
    pub dedicatedVideoMemoryPromotionsSize: NvU64,
    pub dedicatedVideoMemoryPromotionCount: NvU64,
}
pub type NV_GPU_MEMORY_INFO_EX = NV_GPU_MEMORY_INFO_EX_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVDX_ObjectHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NVDX_ObjectHandle = *mut NVDX_ObjectHandle__;
extern "C" {
    pub static NVDX_OBJECT_NONE: NVDX_ObjectHandle;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GET_CURRENT_SLI_STATE_V1 {
    pub version: NvU32,
    pub maxNumAFRGroups: NvU32,
    pub numAFRGroups: NvU32,
    pub currentAFRIndex: NvU32,
    pub nextFrameAFRIndex: NvU32,
    pub previousFrameAFRIndex: NvU32,
    pub bIsCurAFRGroupNew: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GET_CURRENT_SLI_STATE_V2 {
    pub version: NvU32,
    pub maxNumAFRGroups: NvU32,
    pub numAFRGroups: NvU32,
    pub currentAFRIndex: NvU32,
    pub nextFrameAFRIndex: NvU32,
    pub previousFrameAFRIndex: NvU32,
    pub bIsCurAFRGroupNew: NvU32,
    pub numVRSLIGpus: NvU32,
}
impl _NVAPI_D3D_SETRESOURCEHINT_CATEGORY {
    pub const NVAPI_D3D_SRH_CATEGORY_SLI: _NVAPI_D3D_SETRESOURCEHINT_CATEGORY =
        _NVAPI_D3D_SETRESOURCEHINT_CATEGORY(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D_SETRESOURCEHINT_CATEGORY(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D_SETRESOURCEHINT_CATEGORY as NVAPI_D3D_SETRESOURCEHINT_CATEGORY;
impl _NVAPI_D3D_SETRESOURCEHINT_SLI {
    pub const NVAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC:
        _NVAPI_D3D_SETRESOURCEHINT_SLI = _NVAPI_D3D_SETRESOURCEHINT_SLI(1);
}
impl _NVAPI_D3D_SETRESOURCEHINT_SLI {
    pub const NVAPI_D3D_SRH_SLI_ASK_FOR_BROADCAST_USAGE: _NVAPI_D3D_SETRESOURCEHINT_SLI =
        _NVAPI_D3D_SETRESOURCEHINT_SLI(2);
}
impl _NVAPI_D3D_SETRESOURCEHINT_SLI {
    pub const NVAPI_D3D_SRH_SLI_RESPECT_DRIVER_INTERFRAME_CONTENT_SYNC:
        _NVAPI_D3D_SETRESOURCEHINT_SLI = _NVAPI_D3D_SETRESOURCEHINT_SLI(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D_SETRESOURCEHINT_SLI(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D_SETRESOURCEHINT_SLI as NVAPI_D3D_SETRESOURCEHINT_SLI;
impl _NVAPI_D3D_RESOURCERENDERING_FLAG {
    pub const NVAPI_D3D_RR_FLAG_DEFAULTS: _NVAPI_D3D_RESOURCERENDERING_FLAG =
        _NVAPI_D3D_RESOURCERENDERING_FLAG(0);
}
impl _NVAPI_D3D_RESOURCERENDERING_FLAG {
    pub const NVAPI_D3D_RR_FLAG_FORCE_DISCARD_CONTENT: _NVAPI_D3D_RESOURCERENDERING_FLAG =
        _NVAPI_D3D_RESOURCERENDERING_FLAG(1);
}
impl _NVAPI_D3D_RESOURCERENDERING_FLAG {
    pub const NVAPI_D3D_RR_FLAG_FORCE_KEEP_CONTENT: _NVAPI_D3D_RESOURCERENDERING_FLAG =
        _NVAPI_D3D_RESOURCERENDERING_FLAG(2);
}
impl _NVAPI_D3D_RESOURCERENDERING_FLAG {
    pub const NVAPI_D3D_RR_FLAG_MULTI_FRAME: _NVAPI_D3D_RESOURCERENDERING_FLAG =
        _NVAPI_D3D_RESOURCERENDERING_FLAG(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D_RESOURCERENDERING_FLAG(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D_RESOURCERENDERING_FLAG as NVAPI_D3D_RESOURCERENDERING_FLAG;
impl _NV_StereoActiveEye {
    pub const NVAPI_STEREO_EYE_RIGHT: _NV_StereoActiveEye = _NV_StereoActiveEye(1);
}
impl _NV_StereoActiveEye {
    pub const NVAPI_STEREO_EYE_LEFT: _NV_StereoActiveEye = _NV_StereoActiveEye(2);
}
impl _NV_StereoActiveEye {
    pub const NVAPI_STEREO_EYE_MONO: _NV_StereoActiveEye = _NV_StereoActiveEye(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_StereoActiveEye(pub ::std::os::raw::c_int);
pub use self::_NV_StereoActiveEye as NV_STEREO_ACTIVE_EYE;
impl _NV_StereoDriverMode {
    pub const NVAPI_STEREO_DRIVER_MODE_AUTOMATIC: _NV_StereoDriverMode = _NV_StereoDriverMode(0);
}
impl _NV_StereoDriverMode {
    pub const NVAPI_STEREO_DRIVER_MODE_DIRECT: _NV_StereoDriverMode = _NV_StereoDriverMode(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_StereoDriverMode(pub ::std::os::raw::c_int);
pub use self::_NV_StereoDriverMode as NV_STEREO_DRIVER_MODE;
impl _NVAPI_STEREO_SURFACECREATEMODE {
    pub const NVAPI_STEREO_SURFACECREATEMODE_AUTO: _NVAPI_STEREO_SURFACECREATEMODE =
        _NVAPI_STEREO_SURFACECREATEMODE(0);
}
impl _NVAPI_STEREO_SURFACECREATEMODE {
    pub const NVAPI_STEREO_SURFACECREATEMODE_FORCESTEREO: _NVAPI_STEREO_SURFACECREATEMODE =
        _NVAPI_STEREO_SURFACECREATEMODE(1);
}
impl _NVAPI_STEREO_SURFACECREATEMODE {
    pub const NVAPI_STEREO_SURFACECREATEMODE_FORCEMONO: _NVAPI_STEREO_SURFACECREATEMODE =
        _NVAPI_STEREO_SURFACECREATEMODE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_STEREO_SURFACECREATEMODE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_STEREO_SURFACECREATEMODE as NVAPI_STEREO_SURFACECREATEMODE;
impl NVAPI_DEVICE_FEATURE_LEVEL {
    pub const NVAPI_DEVICE_FEATURE_LEVEL_NULL: NVAPI_DEVICE_FEATURE_LEVEL =
        NVAPI_DEVICE_FEATURE_LEVEL(-1);
}
impl NVAPI_DEVICE_FEATURE_LEVEL {
    pub const NVAPI_DEVICE_FEATURE_LEVEL_10_0: NVAPI_DEVICE_FEATURE_LEVEL =
        NVAPI_DEVICE_FEATURE_LEVEL(0);
}
impl NVAPI_DEVICE_FEATURE_LEVEL {
    pub const NVAPI_DEVICE_FEATURE_LEVEL_10_0_PLUS: NVAPI_DEVICE_FEATURE_LEVEL =
        NVAPI_DEVICE_FEATURE_LEVEL(1);
}
impl NVAPI_DEVICE_FEATURE_LEVEL {
    pub const NVAPI_DEVICE_FEATURE_LEVEL_10_1: NVAPI_DEVICE_FEATURE_LEVEL =
        NVAPI_DEVICE_FEATURE_LEVEL(2);
}
impl NVAPI_DEVICE_FEATURE_LEVEL {
    pub const NVAPI_DEVICE_FEATURE_LEVEL_11_0: NVAPI_DEVICE_FEATURE_LEVEL =
        NVAPI_DEVICE_FEATURE_LEVEL(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NVAPI_DEVICE_FEATURE_LEVEL(pub ::std::os::raw::c_int);
impl _NV_DP_LINK_RATE {
    pub const NV_DP_1_62GBPS: _NV_DP_LINK_RATE = _NV_DP_LINK_RATE(6);
}
impl _NV_DP_LINK_RATE {
    pub const NV_DP_2_70GBPS: _NV_DP_LINK_RATE = _NV_DP_LINK_RATE(10);
}
impl _NV_DP_LINK_RATE {
    pub const NV_DP_5_40GBPS: _NV_DP_LINK_RATE = _NV_DP_LINK_RATE(20);
}
impl _NV_DP_LINK_RATE {
    pub const NV_DP_8_10GBPS: _NV_DP_LINK_RATE = _NV_DP_LINK_RATE(30);
}
impl _NV_DP_LINK_RATE {
    pub const NV_EDP_2_16GBPS: _NV_DP_LINK_RATE = _NV_DP_LINK_RATE(8);
}
impl _NV_DP_LINK_RATE {
    pub const NV_EDP_2_43GBPS: _NV_DP_LINK_RATE = _NV_DP_LINK_RATE(9);
}
impl _NV_DP_LINK_RATE {
    pub const NV_EDP_3_24GBPS: _NV_DP_LINK_RATE = _NV_DP_LINK_RATE(12);
}
impl _NV_DP_LINK_RATE {
    pub const NV_EDP_4_32GBPS: _NV_DP_LINK_RATE = _NV_DP_LINK_RATE(16);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DP_LINK_RATE(pub ::std::os::raw::c_int);
pub use self::_NV_DP_LINK_RATE as NV_DP_LINK_RATE;
impl _NV_DP_LANE_COUNT {
    pub const NV_DP_1_LANE: _NV_DP_LANE_COUNT = _NV_DP_LANE_COUNT(1);
}
impl _NV_DP_LANE_COUNT {
    pub const NV_DP_2_LANE: _NV_DP_LANE_COUNT = _NV_DP_LANE_COUNT(2);
}
impl _NV_DP_LANE_COUNT {
    pub const NV_DP_4_LANE: _NV_DP_LANE_COUNT = _NV_DP_LANE_COUNT(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DP_LANE_COUNT(pub ::std::os::raw::c_int);
pub use self::_NV_DP_LANE_COUNT as NV_DP_LANE_COUNT;
impl _NV_DP_COLOR_FORMAT {
    pub const NV_DP_COLOR_FORMAT_RGB: _NV_DP_COLOR_FORMAT = _NV_DP_COLOR_FORMAT(0);
}
impl _NV_DP_COLOR_FORMAT {
    pub const NV_DP_COLOR_FORMAT_YCbCr422: _NV_DP_COLOR_FORMAT = _NV_DP_COLOR_FORMAT(1);
}
impl _NV_DP_COLOR_FORMAT {
    pub const NV_DP_COLOR_FORMAT_YCbCr444: _NV_DP_COLOR_FORMAT = _NV_DP_COLOR_FORMAT(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DP_COLOR_FORMAT(pub ::std::os::raw::c_int);
pub use self::_NV_DP_COLOR_FORMAT as NV_DP_COLOR_FORMAT;
impl _NV_DP_COLORIMETRY {
    pub const NV_DP_COLORIMETRY_RGB: _NV_DP_COLORIMETRY = _NV_DP_COLORIMETRY(0);
}
impl _NV_DP_COLORIMETRY {
    pub const NV_DP_COLORIMETRY_YCbCr_ITU601: _NV_DP_COLORIMETRY = _NV_DP_COLORIMETRY(1);
}
impl _NV_DP_COLORIMETRY {
    pub const NV_DP_COLORIMETRY_YCbCr_ITU709: _NV_DP_COLORIMETRY = _NV_DP_COLORIMETRY(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DP_COLORIMETRY(pub ::std::os::raw::c_int);
pub use self::_NV_DP_COLORIMETRY as NV_DP_COLORIMETRY;
impl _NV_DP_DYNAMIC_RANGE {
    pub const NV_DP_DYNAMIC_RANGE_VESA: _NV_DP_DYNAMIC_RANGE = _NV_DP_DYNAMIC_RANGE(0);
}
impl _NV_DP_DYNAMIC_RANGE {
    pub const NV_DP_DYNAMIC_RANGE_CEA: _NV_DP_DYNAMIC_RANGE = _NV_DP_DYNAMIC_RANGE(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DP_DYNAMIC_RANGE(pub ::std::os::raw::c_int);
pub use self::_NV_DP_DYNAMIC_RANGE as NV_DP_DYNAMIC_RANGE;
impl _NV_DP_BPC {
    pub const NV_DP_BPC_DEFAULT: _NV_DP_BPC = _NV_DP_BPC(0);
}
impl _NV_DP_BPC {
    pub const NV_DP_BPC_6: _NV_DP_BPC = _NV_DP_BPC(1);
}
impl _NV_DP_BPC {
    pub const NV_DP_BPC_8: _NV_DP_BPC = _NV_DP_BPC(2);
}
impl _NV_DP_BPC {
    pub const NV_DP_BPC_10: _NV_DP_BPC = _NV_DP_BPC(3);
}
impl _NV_DP_BPC {
    pub const NV_DP_BPC_12: _NV_DP_BPC = _NV_DP_BPC(4);
}
impl _NV_DP_BPC {
    pub const NV_DP_BPC_16: _NV_DP_BPC = _NV_DP_BPC(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DP_BPC(pub ::std::os::raw::c_int);
pub use self::_NV_DP_BPC as NV_DP_BPC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_EDID_V1 {
    pub version: NvU32,
    pub EDID_Data: [NvU8; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_EDID_V2 {
    pub version: NvU32,
    pub EDID_Data: [NvU8; 256usize],
    pub sizeofEDID: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_EDID_V3 {
    pub version: NvU32,
    pub EDID_Data: [NvU8; 256usize],
    pub sizeofEDID: NvU32,
    pub edidId: NvU32,
    pub offset: NvU32,
}
pub type NV_EDID = NV_EDID_V3;
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_VGA_15_PIN: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(0);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_TV_COMPOSITE: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(16);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_TV_SVIDEO: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(17);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_TV_HDTV_COMPONENT: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(19);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_TV_SCART: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(20);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_TV_COMPOSITE_SCART_ON_EIAJ4120: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(22);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_TV_HDTV_EIAJ4120: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(23);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_PC_POD_HDTV_YPRPB: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(24);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_PC_POD_SVIDEO: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(25);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_PC_POD_COMPOSITE: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(26);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_DVI_I_TV_SVIDEO: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(32);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_DVI_I_TV_COMPOSITE: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(33);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_DVI_I: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(48);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_DVI_D: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(49);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_ADC: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(50);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_LFH_DVI_I_1: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(56);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_LFH_DVI_I_2: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(57);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_SPWG: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(64);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_OEM: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(65);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_DISPLAYPORT_EXTERNAL: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(70);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_DISPLAYPORT_INTERNAL: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(71);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_DISPLAYPORT_MINI_EXT: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(72);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_HDMI_A: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(97);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_HDMI_C_MINI: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(99);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_1: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(100);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_2: _NV_GPU_CONNECTOR_TYPE =
        _NV_GPU_CONNECTOR_TYPE(101);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_VIRTUAL_WFD: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(112);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_USB_C: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(113);
}
impl _NV_GPU_CONNECTOR_TYPE {
    pub const NVAPI_GPU_CONNECTOR_UNKNOWN: _NV_GPU_CONNECTOR_TYPE = _NV_GPU_CONNECTOR_TYPE(-1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_CONNECTOR_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_CONNECTOR_TYPE as NV_GPU_CONNECTOR_TYPE;
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_NONE: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(0);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_SD_NTSCM: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(1);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_SD_NTSCJ: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(2);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_SD_PALM: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(4);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_SD_PALBDGH: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(8);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_SD_PALN: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(16);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_SD_PALNC: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(32);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_SD_576i: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(256);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_SD_480i: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(512);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_ED_480p: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(1024);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_ED_576p: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(2048);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_HD_720p: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(4096);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_HD_1080i: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(8192);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_HD_1080p: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(16384);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_HD_720p50: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(32768);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_HD_1080p24: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(65536);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_HD_1080i50: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(131072);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_HD_1080p50: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(262144);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp30: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(524288);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp30_3840: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(524288);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp25: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(1048576);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp25_3840: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(1048576);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp24: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(2097152);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp24_3840: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(2097152);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp24_SMPTE: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(4194304);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp50_3840: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(8388608);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp60_3840: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(9437184);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp30_4096: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(10485760);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp25_4096: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(11534336);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp24_4096: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(12582912);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp50_4096: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(13631488);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp60_4096: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(14680064);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_8Kp24_7680: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(16777216);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_8Kp25_7680: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(33554432);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_8Kp30_7680: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(67108864);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_8Kp48_7680: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(134217728);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_8Kp50_7680: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(150994944);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_8Kp60_7680: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(167772160);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_8Kp100_7680: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(184549376);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_8Kp120_7680: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(201326592);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp48_3840: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(218103808);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp48_4096: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(234881024);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp100_4096: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(251658240);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp100_3840: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(268435456);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp120_4096: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(285212672);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp120_3840: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(301989888);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp100_5120: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(318767104);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp120_5120: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(335544320);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp24_5120: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(352321536);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp25_5120: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(369098752);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp30_5120: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(385875968);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp48_5120: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(402653184);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp50_5120: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(419430400);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_4Kp60_5120: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(536870912);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_10Kp24_10240: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(553648128);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_10Kp25_10240: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(570425344);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_10Kp30_10240: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(587202560);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_10Kp48_10240: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(603979776);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_10Kp50_10240: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(620756992);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_10Kp60_10240: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(637534208);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_10Kp100_10240: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(654311424);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_UHD_10Kp120_10240: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(671088640);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_SD_OTHER: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(805306368);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_ED_OTHER: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(1073741824);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_HD_OTHER: _NV_DISPLAY_TV_FORMAT =
        _NV_DISPLAY_TV_FORMAT(1342177280);
}
impl _NV_DISPLAY_TV_FORMAT {
    pub const NV_DISPLAY_TV_FORMAT_ANY: _NV_DISPLAY_TV_FORMAT = _NV_DISPLAY_TV_FORMAT(-2147483648);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DISPLAY_TV_FORMAT(pub ::std::os::raw::c_int);
pub use self::_NV_DISPLAY_TV_FORMAT as NV_DISPLAY_TV_FORMAT;
impl _NV_TARGET_VIEW_MODE {
    pub const NV_VIEW_MODE_STANDARD: _NV_TARGET_VIEW_MODE = _NV_TARGET_VIEW_MODE(0);
}
impl _NV_TARGET_VIEW_MODE {
    pub const NV_VIEW_MODE_CLONE: _NV_TARGET_VIEW_MODE = _NV_TARGET_VIEW_MODE(1);
}
impl _NV_TARGET_VIEW_MODE {
    pub const NV_VIEW_MODE_HSPAN: _NV_TARGET_VIEW_MODE = _NV_TARGET_VIEW_MODE(2);
}
impl _NV_TARGET_VIEW_MODE {
    pub const NV_VIEW_MODE_VSPAN: _NV_TARGET_VIEW_MODE = _NV_TARGET_VIEW_MODE(3);
}
impl _NV_TARGET_VIEW_MODE {
    pub const NV_VIEW_MODE_DUALVIEW: _NV_TARGET_VIEW_MODE = _NV_TARGET_VIEW_MODE(4);
}
impl _NV_TARGET_VIEW_MODE {
    pub const NV_VIEW_MODE_MULTIVIEW: _NV_TARGET_VIEW_MODE = _NV_TARGET_VIEW_MODE(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_TARGET_VIEW_MODE(pub ::std::os::raw::c_int);
pub use self::_NV_TARGET_VIEW_MODE as NV_TARGET_VIEW_MODE;
impl _NV_SCALING {
    pub const NV_SCALING_DEFAULT: _NV_SCALING = _NV_SCALING(0);
}
impl _NV_SCALING {
    pub const NV_SCALING_GPU_SCALING_TO_CLOSEST: _NV_SCALING = _NV_SCALING(1);
}
impl _NV_SCALING {
    pub const NV_SCALING_GPU_SCALING_TO_NATIVE: _NV_SCALING = _NV_SCALING(2);
}
impl _NV_SCALING {
    pub const NV_SCALING_GPU_SCANOUT_TO_NATIVE: _NV_SCALING = _NV_SCALING(3);
}
impl _NV_SCALING {
    pub const NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_NATIVE: _NV_SCALING = _NV_SCALING(5);
}
impl _NV_SCALING {
    pub const NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_CLOSEST: _NV_SCALING = _NV_SCALING(6);
}
impl _NV_SCALING {
    pub const NV_SCALING_GPU_SCANOUT_TO_CLOSEST: _NV_SCALING = _NV_SCALING(7);
}
impl _NV_SCALING {
    pub const NV_SCALING_GPU_INTEGER_ASPECT_SCALING: _NV_SCALING = _NV_SCALING(8);
}
impl _NV_SCALING {
    pub const NV_SCALING_MONITOR_SCALING: _NV_SCALING = _NV_SCALING(1);
}
impl _NV_SCALING {
    pub const NV_SCALING_ADAPTER_SCALING: _NV_SCALING = _NV_SCALING(2);
}
impl _NV_SCALING {
    pub const NV_SCALING_CENTERED: _NV_SCALING = _NV_SCALING(3);
}
impl _NV_SCALING {
    pub const NV_SCALING_ASPECT_SCALING: _NV_SCALING = _NV_SCALING(5);
}
impl _NV_SCALING {
    pub const NV_SCALING_CUSTOMIZED: _NV_SCALING = _NV_SCALING(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_SCALING(pub ::std::os::raw::c_int);
pub use self::_NV_SCALING as NV_SCALING;
impl _NV_ROTATE {
    pub const NV_ROTATE_0: _NV_ROTATE = _NV_ROTATE(0);
}
impl _NV_ROTATE {
    pub const NV_ROTATE_90: _NV_ROTATE = _NV_ROTATE(1);
}
impl _NV_ROTATE {
    pub const NV_ROTATE_180: _NV_ROTATE = _NV_ROTATE(2);
}
impl _NV_ROTATE {
    pub const NV_ROTATE_270: _NV_ROTATE = _NV_ROTATE(3);
}
impl _NV_ROTATE {
    pub const NV_ROTATE_IGNORED: _NV_ROTATE = _NV_ROTATE(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ROTATE(pub ::std::os::raw::c_int);
pub use self::_NV_ROTATE as NV_ROTATE;
impl _NV_FORMAT {
    pub const NV_FORMAT_UNKNOWN: _NV_FORMAT = _NV_FORMAT(0);
}
impl _NV_FORMAT {
    pub const NV_FORMAT_P8: _NV_FORMAT = _NV_FORMAT(41);
}
impl _NV_FORMAT {
    pub const NV_FORMAT_R5G6B5: _NV_FORMAT = _NV_FORMAT(23);
}
impl _NV_FORMAT {
    pub const NV_FORMAT_A8R8G8B8: _NV_FORMAT = _NV_FORMAT(21);
}
impl _NV_FORMAT {
    pub const NV_FORMAT_A16B16G16R16F: _NV_FORMAT = _NV_FORMAT(113);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_FORMAT(pub ::std::os::raw::c_int);
pub use self::_NV_FORMAT as NV_FORMAT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_VIEWPORTF {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_CURRENT: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(0);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_AUTO: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(1);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_EDID: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(2);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_DMT: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(3);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_DMT_RB: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(4);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_CVT: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(5);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_CVT_RB: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(6);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_GTF: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(7);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_EIA861: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(8);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_ANALOG_TV: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(9);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_CUST: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(10);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_NV_PREDEFINED: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(11);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_NV_PSF: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(11);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_NV_ASPR: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(12);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_SDI: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(13);
}
impl _NV_TIMING_OVERRIDE {
    pub const NV_TIMING_OVERRIDE_MAX: _NV_TIMING_OVERRIDE = _NV_TIMING_OVERRIDE(14);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_TIMING_OVERRIDE(pub ::std::os::raw::c_int);
pub use self::_NV_TIMING_OVERRIDE as NV_TIMING_OVERRIDE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagNV_TIMINGEXT {
    pub flag: NvU32,
    pub rr: NvU16,
    pub rrx1k: NvU32,
    pub aspect: NvU32,
    pub rep: NvU16,
    pub status: NvU32,
    pub name: [NvU8; 40usize],
}
pub type NV_TIMINGEXT = tagNV_TIMINGEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_TIMING {
    pub HVisible: NvU16,
    pub HBorder: NvU16,
    pub HFrontPorch: NvU16,
    pub HSyncWidth: NvU16,
    pub HTotal: NvU16,
    pub HSyncPol: NvU8,
    pub VVisible: NvU16,
    pub VBorder: NvU16,
    pub VFrontPorch: NvU16,
    pub VSyncWidth: NvU16,
    pub VTotal: NvU16,
    pub VSyncPol: NvU8,
    pub interlaced: NvU16,
    pub pclk: NvU32,
    pub etc: NV_TIMINGEXT,
}
pub type NV_TIMING = _NV_TIMING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_VIEW_TARGET_INFO {
    pub version: NvU32,
    pub count: NvU32,
    pub target: [NV_VIEW_TARGET_INFO__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_VIEW_TARGET_INFO__bindgen_ty_1 {
    pub deviceMask: NvU32,
    pub sourceId: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl NV_VIEW_TARGET_INFO__bindgen_ty_1 {
    #[inline]
    pub fn bPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bInterlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bInterlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bGDIPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bGDIPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bForceModeSet(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bForceModeSet(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bPrimary: NvU32,
        bInterlaced: NvU32,
        bGDIPrimary: NvU32,
        bForceModeSet: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bPrimary: u32 = unsafe { ::std::mem::transmute(bPrimary) };
            bPrimary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bInterlaced: u32 = unsafe { ::std::mem::transmute(bInterlaced) };
            bInterlaced as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bGDIPrimary: u32 = unsafe { ::std::mem::transmute(bGDIPrimary) };
            bGDIPrimary as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bForceModeSet: u32 = unsafe { ::std::mem::transmute(bForceModeSet) };
            bForceModeSet as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_DISPLAY_PATH {
    pub deviceMask: NvU32,
    pub sourceId: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub connector: NV_GPU_CONNECTOR_TYPE,
    pub width: NvU32,
    pub height: NvU32,
    pub depth: NvU32,
    pub colorFormat: NV_FORMAT,
    pub rotation: NV_ROTATE,
    pub scaling: NV_SCALING,
    pub refreshRate: NvU32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tvFormat: NV_DISPLAY_TV_FORMAT,
    pub posx: NvU32,
    pub posy: NvU32,
    pub _bitfield_align_3: [u32; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl NV_DISPLAY_PATH {
    #[inline]
    pub fn bPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bPrimary: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bPrimary: u32 = unsafe { ::std::mem::transmute(bPrimary) };
            bPrimary as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn interlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(interlaced: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaced: u32 = unsafe { ::std::mem::transmute(interlaced) };
            interlaced as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn bGDIPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bGDIPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bForceModeSet(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bForceModeSet(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFocusDisplay(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bFocusDisplay(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpuId(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(3usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_gpuId(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(3usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        bGDIPrimary: NvU32,
        bForceModeSet: NvU32,
        bFocusDisplay: NvU32,
        gpuId: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bGDIPrimary: u32 = unsafe { ::std::mem::transmute(bGDIPrimary) };
            bGDIPrimary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bForceModeSet: u32 = unsafe { ::std::mem::transmute(bForceModeSet) };
            bForceModeSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bFocusDisplay: u32 = unsafe { ::std::mem::transmute(bFocusDisplay) };
            bFocusDisplay as u64
        });
        __bindgen_bitfield_unit.set(3usize, 24u8, {
            let gpuId: u32 = unsafe { ::std::mem::transmute(gpuId) };
            gpuId as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_DISPLAY_PATH_INFO_V3 {
    pub version: NvU32,
    pub count: NvU32,
    pub path: [NV_DISPLAY_PATH; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_DISPLAY_PATH_INFO {
    pub version: NvU32,
    pub count: NvU32,
    pub path: [NV_DISPLAY_PATH; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_POSITION {
    pub x: NvS32,
    pub y: NvS32,
}
pub type NV_POSITION = _NV_POSITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_RESOLUTION {
    pub width: NvU32,
    pub height: NvU32,
    pub colorDepth: NvU32,
}
pub type NV_RESOLUTION = _NV_RESOLUTION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 {
    pub version: NvU32,
    pub rotation: NV_ROTATE,
    pub scaling: NV_SCALING,
    pub refreshRate1K: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub connector: NV_GPU_CONNECTOR_TYPE,
    pub tvFormat: NV_DISPLAY_TV_FORMAT,
    pub timingOverride: NV_TIMING_OVERRIDE,
    pub timing: NV_TIMING,
}
impl _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 {
    #[inline]
    pub fn interlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn primary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_primary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBit1(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBit1(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableVirtualModeSupport(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableVirtualModeSupport(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isPreferredUnscaledTarget(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isPreferredUnscaledTarget(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interlaced: NvU32,
        primary: NvU32,
        reservedBit1: NvU32,
        disableVirtualModeSupport: NvU32,
        isPreferredUnscaledTarget: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaced: u32 = unsafe { ::std::mem::transmute(interlaced) };
            interlaced as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let primary: u32 = unsafe { ::std::mem::transmute(primary) };
            primary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reservedBit1: u32 = unsafe { ::std::mem::transmute(reservedBit1) };
            reservedBit1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disableVirtualModeSupport: u32 =
                unsafe { ::std::mem::transmute(disableVirtualModeSupport) };
            disableVirtualModeSupport as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isPreferredUnscaledTarget: u32 =
                unsafe { ::std::mem::transmute(isPreferredUnscaledTarget) };
            isPreferredUnscaledTarget as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 =
    _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1;
pub type NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO = NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1 {
    pub displayId: NvU32,
    pub details: *mut NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO,
}
pub type NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1 = _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 {
    pub displayId: NvU32,
    pub details: *mut NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO,
    pub targetId: NvU32,
}
pub type NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 = _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2;
pub type NV_DISPLAYCONFIG_PATH_TARGET_INFO = NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2;
impl _NV_DISPLAYCONFIG_SPANNING_ORIENTATION {
    pub const NV_DISPLAYCONFIG_SPAN_NONE: _NV_DISPLAYCONFIG_SPANNING_ORIENTATION =
        _NV_DISPLAYCONFIG_SPANNING_ORIENTATION(0);
}
impl _NV_DISPLAYCONFIG_SPANNING_ORIENTATION {
    pub const NV_DISPLAYCONFIG_SPAN_HORIZONTAL: _NV_DISPLAYCONFIG_SPANNING_ORIENTATION =
        _NV_DISPLAYCONFIG_SPANNING_ORIENTATION(1);
}
impl _NV_DISPLAYCONFIG_SPANNING_ORIENTATION {
    pub const NV_DISPLAYCONFIG_SPAN_VERTICAL: _NV_DISPLAYCONFIG_SPANNING_ORIENTATION =
        _NV_DISPLAYCONFIG_SPANNING_ORIENTATION(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DISPLAYCONFIG_SPANNING_ORIENTATION(pub ::std::os::raw::c_int);
pub use self::_NV_DISPLAYCONFIG_SPANNING_ORIENTATION as NV_DISPLAYCONFIG_SPANNING_ORIENTATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 {
    pub resolution: NV_RESOLUTION,
    pub colorFormat: NV_FORMAT,
    pub position: NV_POSITION,
    pub spanningOrientation: NV_DISPLAYCONFIG_SPANNING_ORIENTATION,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 {
    #[inline]
    pub fn bGDIPrimary(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bGDIPrimary(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSLIFocus(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSLIFocus(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bGDIPrimary: NvU32,
        bSLIFocus: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bGDIPrimary: u32 = unsafe { ::std::mem::transmute(bGDIPrimary) };
            bGDIPrimary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSLIFocus: u32 = unsafe { ::std::mem::transmute(bSLIFocus) };
            bSLIFocus as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 = _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_INFO_V1 {
    pub version: NvU32,
    pub reserved_sourceId: NvU32,
    pub targetInfoCount: NvU32,
    pub targetInfo: *mut NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1,
    pub sourceModeInfo: *mut NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1,
}
pub type NV_DISPLAYCONFIG_PATH_INFO_V1 = _NV_DISPLAYCONFIG_PATH_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAYCONFIG_PATH_INFO {
    pub version: NvU32,
    pub __bindgen_anon_1: _NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1,
    pub targetInfoCount: NvU32,
    pub targetInfo: *mut NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2,
    pub sourceModeInfo: *mut NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pOSAdapterID: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_DISPLAYCONFIG_PATH_INFO__bindgen_ty_1 {
    pub sourceId: NvU32,
    pub reserved_sourceId: NvU32,
}
impl _NV_DISPLAYCONFIG_PATH_INFO {
    #[inline]
    pub fn IsNonNVIDIAAdapter(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsNonNVIDIAAdapter(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsNonNVIDIAAdapter: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsNonNVIDIAAdapter: u32 = unsafe { ::std::mem::transmute(IsNonNVIDIAAdapter) };
            IsNonNVIDIAAdapter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_DISPLAYCONFIG_PATH_INFO_V2 = _NV_DISPLAYCONFIG_PATH_INFO;
pub type NV_DISPLAYCONFIG_PATH_INFO = NV_DISPLAYCONFIG_PATH_INFO_V2;
pub type NV_DISPLAYCONFIG_SOURCE_MODE_INFO = NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1;
impl _NV_DISPLAYCONFIG_FLAGS {
    pub const NV_DISPLAYCONFIG_VALIDATE_ONLY: _NV_DISPLAYCONFIG_FLAGS = _NV_DISPLAYCONFIG_FLAGS(1);
}
impl _NV_DISPLAYCONFIG_FLAGS {
    pub const NV_DISPLAYCONFIG_SAVE_TO_PERSISTENCE: _NV_DISPLAYCONFIG_FLAGS =
        _NV_DISPLAYCONFIG_FLAGS(2);
}
impl _NV_DISPLAYCONFIG_FLAGS {
    pub const NV_DISPLAYCONFIG_DRIVER_RELOAD_ALLOWED: _NV_DISPLAYCONFIG_FLAGS =
        _NV_DISPLAYCONFIG_FLAGS(4);
}
impl _NV_DISPLAYCONFIG_FLAGS {
    pub const NV_DISPLAYCONFIG_FORCE_MODE_ENUMERATION: _NV_DISPLAYCONFIG_FLAGS =
        _NV_DISPLAYCONFIG_FLAGS(8);
}
impl _NV_DISPLAYCONFIG_FLAGS {
    pub const NV_FORCE_COMMIT_VIDPN: _NV_DISPLAYCONFIG_FLAGS = _NV_DISPLAYCONFIG_FLAGS(16);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DISPLAYCONFIG_FLAGS(pub ::std::os::raw::c_int);
pub use self::_NV_DISPLAYCONFIG_FLAGS as NV_DISPLAYCONFIG_FLAGS;
pub type NvAPI_UnicodeString = [NvU16; 2048usize];
pub type NvAPI_LPCWSTR = *const NvU16;
impl _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID {
    pub const NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_CORE: _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID =
        _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID(0);
}
impl _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID {
    pub const NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED: _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID =
        _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID(16);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID as NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID;
impl _NV_GPU_PUBLIC_CLOCK_ID {
    pub const NVAPI_GPU_PUBLIC_CLOCK_GRAPHICS: _NV_GPU_PUBLIC_CLOCK_ID = _NV_GPU_PUBLIC_CLOCK_ID(0);
}
impl _NV_GPU_PUBLIC_CLOCK_ID {
    pub const NVAPI_GPU_PUBLIC_CLOCK_MEMORY: _NV_GPU_PUBLIC_CLOCK_ID = _NV_GPU_PUBLIC_CLOCK_ID(4);
}
impl _NV_GPU_PUBLIC_CLOCK_ID {
    pub const NVAPI_GPU_PUBLIC_CLOCK_PROCESSOR: _NV_GPU_PUBLIC_CLOCK_ID =
        _NV_GPU_PUBLIC_CLOCK_ID(7);
}
impl _NV_GPU_PUBLIC_CLOCK_ID {
    pub const NVAPI_GPU_PUBLIC_CLOCK_VIDEO: _NV_GPU_PUBLIC_CLOCK_ID = _NV_GPU_PUBLIC_CLOCK_ID(8);
}
impl _NV_GPU_PUBLIC_CLOCK_ID {
    pub const NVAPI_GPU_PUBLIC_CLOCK_UNDEFINED: _NV_GPU_PUBLIC_CLOCK_ID =
        _NV_GPU_PUBLIC_CLOCK_ID(32);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_PUBLIC_CLOCK_ID(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_PUBLIC_CLOCK_ID as NV_GPU_PUBLIC_CLOCK_ID;
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P0: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(0);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P1: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(1);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P2: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(2);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P3: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(3);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P4: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(4);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P5: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(5);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P6: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(6);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P7: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(7);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P8: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(8);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P9: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(9);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P10: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(10);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P11: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(11);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P12: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(12);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P13: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(13);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P14: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(14);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_P15: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(15);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_UNDEFINED: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(16);
}
impl _NV_GPU_PERF_PSTATE_ID {
    pub const NVAPI_GPU_PERF_PSTATE_ALL: _NV_GPU_PERF_PSTATE_ID = _NV_GPU_PERF_PSTATE_ID(17);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_PERF_PSTATE_ID(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_PERF_PSTATE_ID as NV_GPU_PERF_PSTATE_ID;
impl NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID {
    pub const NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_SINGLE: NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID =
        NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID(0);
}
impl NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID {
    pub const NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_RANGE: NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID =
        NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_PARAM_DELTA {
    pub value: NvS32,
    pub valueRange: NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_PARAM_DELTA__bindgen_ty_1 {
    pub min: NvS32,
    pub max: NvS32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PSTATE20_CLOCK_ENTRY_V1 {
    pub domainId: NV_GPU_PUBLIC_CLOCK_ID,
    pub typeId: NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub freqDelta_kHz: NV_GPU_PERF_PSTATES20_PARAM_DELTA,
    pub data: NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1 {
    pub single: NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1,
    pub range: NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_1 {
    pub freq_kHz: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PSTATE20_CLOCK_ENTRY_V1__bindgen_ty_1__bindgen_ty_2 {
    pub minFreq_kHz: NvU32,
    pub maxFreq_kHz: NvU32,
    pub domainId: NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID,
    pub minVoltage_uV: NvU32,
    pub maxVoltage_uV: NvU32,
}
impl NV_GPU_PSTATE20_CLOCK_ENTRY_V1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 {
    pub domainId: NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub volt_uV: NvU32,
    pub voltDelta_uV: NV_GPU_PERF_PSTATES20_PARAM_DELTA,
}
impl NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_INFO_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub numPstates: NvU32,
    pub numClocks: NvU32,
    pub numBaseVoltages: NvU32,
    pub pstates: [NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1 {
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub clocks: [NV_GPU_PSTATE20_CLOCK_ENTRY_V1; 8usize],
    pub baseVoltages: [NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1; 4usize],
}
impl NV_GPU_PERF_PSTATES20_INFO_V1__bindgen_ty_1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl NV_GPU_PERF_PSTATES20_INFO_V1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_PERF_PSTATES20_INFO_V2 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub numPstates: NvU32,
    pub numClocks: NvU32,
    pub numBaseVoltages: NvU32,
    pub pstates: [_NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1; 16usize],
    pub ov: _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1 {
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub clocks: [NV_GPU_PSTATE20_CLOCK_ENTRY_V1; 8usize],
    pub baseVoltages: [NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1; 4usize],
}
impl _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_1 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_PERF_PSTATES20_INFO_V2__bindgen_ty_2 {
    pub numVoltages: NvU32,
    pub voltages: [NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1; 4usize],
}
impl _NV_GPU_PERF_PSTATES20_INFO_V2 {
    #[inline]
    pub fn bIsEditable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsEditable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsEditable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsEditable: u32 = unsafe { ::std::mem::transmute(bIsEditable) };
            bIsEditable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GPU_PERF_PSTATES20_INFO_V2 = _NV_GPU_PERF_PSTATES20_INFO_V2;
pub type NV_GPU_PERF_PSTATES20_INFO = NV_GPU_PERF_PSTATES20_INFO_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_DISPLAY_DRIVER_VERSION {
    pub version: NvU32,
    pub drvVersion: NvU32,
    pub bldChangeListNum: NvU32,
    pub szBuildBranchString: NvAPI_ShortString,
    pub szAdapterString: NvAPI_ShortString,
}
pub type NVAPI_OGLEXPERT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        categoryId: ::std::os::raw::c_uint,
        messageId: ::std::os::raw::c_uint,
        detailLevel: ::std::os::raw::c_uint,
        objectId: ::std::os::raw::c_int,
        messageStr: *const ::std::os::raw::c_char,
    ),
>;
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_UNINITIALIZED: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(0);
}
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_VGA: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(1);
}
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_COMPONENT: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(2);
}
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_SVIDEO: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(3);
}
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_HDMI: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(4);
}
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_DVI: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(5);
}
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_LVDS: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(6);
}
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_DP: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(7);
}
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_COMPOSITE: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(8);
}
impl NV_MONITOR_CONN_TYPE {
    pub const NV_MONITOR_CONN_TYPE_UNKNOWN: NV_MONITOR_CONN_TYPE = NV_MONITOR_CONN_TYPE(-1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_MONITOR_CONN_TYPE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_DISPLAYIDS {
    pub version: NvU32,
    pub connectorType: NV_MONITOR_CONN_TYPE,
    pub displayId: NvU32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NV_GPU_DISPLAYIDS {
    #[inline]
    pub fn isDynamic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDynamic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMultiStreamRootNode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMultiStreamRootNode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isActive(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isActive(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCluster(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCluster(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isOSVisible(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isOSVisible(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isWFD(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isWFD(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isConnected(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isConnected(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedInternal(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reservedInternal(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn isPhysicallyConnected(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isPhysicallyConnected(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isDynamic: NvU32,
        isMultiStreamRootNode: NvU32,
        isActive: NvU32,
        isCluster: NvU32,
        isOSVisible: NvU32,
        isWFD: NvU32,
        isConnected: NvU32,
        reservedInternal: NvU32,
        isPhysicallyConnected: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isDynamic: u32 = unsafe { ::std::mem::transmute(isDynamic) };
            isDynamic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMultiStreamRootNode: u32 =
                unsafe { ::std::mem::transmute(isMultiStreamRootNode) };
            isMultiStreamRootNode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isActive: u32 = unsafe { ::std::mem::transmute(isActive) };
            isActive as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isCluster: u32 = unsafe { ::std::mem::transmute(isCluster) };
            isCluster as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isOSVisible: u32 = unsafe { ::std::mem::transmute(isOSVisible) };
            isOSVisible as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isWFD: u32 = unsafe { ::std::mem::transmute(isWFD) };
            isWFD as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isConnected: u32 = unsafe { ::std::mem::transmute(isConnected) };
            isConnected as u64
        });
        __bindgen_bitfield_unit.set(7usize, 10u8, {
            let reservedInternal: u32 = unsafe { ::std::mem::transmute(reservedInternal) };
            reservedInternal as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let isPhysicallyConnected: u32 =
                unsafe { ::std::mem::transmute(isPhysicallyConnected) };
            isPhysicallyConnected as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GPU_DISPLAYIDS = _NV_GPU_DISPLAYIDS;
impl NV_SYSTEM_TYPE {
    pub const NV_SYSTEM_TYPE_UNKNOWN: NV_SYSTEM_TYPE = NV_SYSTEM_TYPE(0);
}
impl NV_SYSTEM_TYPE {
    pub const NV_SYSTEM_TYPE_LAPTOP: NV_SYSTEM_TYPE = NV_SYSTEM_TYPE(1);
}
impl NV_SYSTEM_TYPE {
    pub const NV_SYSTEM_TYPE_DESKTOP: NV_SYSTEM_TYPE = NV_SYSTEM_TYPE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_SYSTEM_TYPE(pub ::std::os::raw::c_int);
impl _NV_GPU_OUTPUT_TYPE {
    pub const NVAPI_GPU_OUTPUT_UNKNOWN: _NV_GPU_OUTPUT_TYPE = _NV_GPU_OUTPUT_TYPE(0);
}
impl _NV_GPU_OUTPUT_TYPE {
    pub const NVAPI_GPU_OUTPUT_CRT: _NV_GPU_OUTPUT_TYPE = _NV_GPU_OUTPUT_TYPE(1);
}
impl _NV_GPU_OUTPUT_TYPE {
    pub const NVAPI_GPU_OUTPUT_DFP: _NV_GPU_OUTPUT_TYPE = _NV_GPU_OUTPUT_TYPE(2);
}
impl _NV_GPU_OUTPUT_TYPE {
    pub const NVAPI_GPU_OUTPUT_TV: _NV_GPU_OUTPUT_TYPE = _NV_GPU_OUTPUT_TYPE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_OUTPUT_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_OUTPUT_TYPE as NV_GPU_OUTPUT_TYPE;
impl _NV_GPU_TYPE {
    pub const NV_SYSTEM_TYPE_GPU_UNKNOWN: _NV_GPU_TYPE = _NV_GPU_TYPE(0);
}
impl _NV_GPU_TYPE {
    pub const NV_SYSTEM_TYPE_IGPU: _NV_GPU_TYPE = _NV_GPU_TYPE(1);
}
impl _NV_GPU_TYPE {
    pub const NV_SYSTEM_TYPE_DGPU: _NV_GPU_TYPE = _NV_GPU_TYPE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_TYPE as NV_GPU_TYPE;
impl _NV_GPU_BUS_TYPE {
    pub const NVAPI_GPU_BUS_TYPE_UNDEFINED: _NV_GPU_BUS_TYPE = _NV_GPU_BUS_TYPE(0);
}
impl _NV_GPU_BUS_TYPE {
    pub const NVAPI_GPU_BUS_TYPE_PCI: _NV_GPU_BUS_TYPE = _NV_GPU_BUS_TYPE(1);
}
impl _NV_GPU_BUS_TYPE {
    pub const NVAPI_GPU_BUS_TYPE_AGP: _NV_GPU_BUS_TYPE = _NV_GPU_BUS_TYPE(2);
}
impl _NV_GPU_BUS_TYPE {
    pub const NVAPI_GPU_BUS_TYPE_PCI_EXPRESS: _NV_GPU_BUS_TYPE = _NV_GPU_BUS_TYPE(3);
}
impl _NV_GPU_BUS_TYPE {
    pub const NVAPI_GPU_BUS_TYPE_FPCI: _NV_GPU_BUS_TYPE = _NV_GPU_BUS_TYPE(4);
}
impl _NV_GPU_BUS_TYPE {
    pub const NVAPI_GPU_BUS_TYPE_AXI: _NV_GPU_BUS_TYPE = _NV_GPU_BUS_TYPE(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_BUS_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_BUS_TYPE as NV_GPU_BUS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_BOARD_INFO {
    pub version: NvU32,
    pub BoardNum: [NvU8; 16usize],
}
pub type NV_BOARD_INFO_V1 = _NV_BOARD_INFO;
pub type NV_BOARD_INFO = NV_BOARD_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_ARCH_INFO_V1 {
    pub version: NvU32,
    pub architecture: NvU32,
    pub implementation: NvU32,
    pub revision: NvU32,
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_T2X: _NV_GPU_ARCHITECTURE_ID =
        _NV_GPU_ARCHITECTURE_ID(-536870880);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_T3X: _NV_GPU_ARCHITECTURE_ID =
        _NV_GPU_ARCHITECTURE_ID(-536870864);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_T4X: _NV_GPU_ARCHITECTURE_ID =
        _NV_GPU_ARCHITECTURE_ID(-536870848);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_T12X: _NV_GPU_ARCHITECTURE_ID =
        _NV_GPU_ARCHITECTURE_ID(-536870848);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_NV40: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(64);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_NV50: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(80);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_G78: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(96);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_G80: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(128);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_G90: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(144);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GT200: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(160);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GF100: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(192);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GF110: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(208);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GK100: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(224);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GK110: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(240);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GK200: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(256);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GM000: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(272);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GM200: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(288);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GP100: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(304);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GV100: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(320);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GV110: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(336);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_TU100: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(352);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_GA100: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(368);
}
impl _NV_GPU_ARCHITECTURE_ID {
    pub const NV_GPU_ARCHITECTURE_AD100: _NV_GPU_ARCHITECTURE_ID = _NV_GPU_ARCHITECTURE_ID(400);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_ARCHITECTURE_ID(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_ARCHITECTURE_ID as NV_GPU_ARCHITECTURE_ID;
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_T20: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_T30: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_T35: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(5);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_T40: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_T124: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV40: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV41: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(1);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV42: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(2);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV43: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(3);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV44: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV44A: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(10);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV46: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(6);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV47: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(7);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV49: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(9);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV4B: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(11);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV4C: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(12);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV4E: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(14);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV50: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV63: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(3);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_NV67: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(7);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_G84: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_G86: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(6);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_G92: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(2);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_G94: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_G96: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(6);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_G98: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(8);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GT200: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GT212: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(2);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GT214: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GT215: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(3);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GT216: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(5);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GT218: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(8);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_MCP77: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(10);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GT21C: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(11);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_MCP79: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(12);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GT21A: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(13);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_MCP89: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(15);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GF100: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GF104: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GF106: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(3);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GF108: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(1);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GF110: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GF116: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(6);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GF117: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(7);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GF118: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(8);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GF119: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(9);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GK104: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GK106: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(6);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GK107: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(7);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GK20A: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(10);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GK110: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GK208: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(8);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GM204: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GM206: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(6);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GP100: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GP000: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(1);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GP102: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(2);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GP104: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GP106: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(6);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GP107: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(7);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GP108: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(8);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GV100: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GV10B: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(11);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_TU100: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_TU102: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(2);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_TU104: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_TU106: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(6);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_TU116: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(8);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_TU117: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(7);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_TU000: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(1);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GA100: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(0);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GA102: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(2);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_GA104: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_AD102: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(2);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_AD103: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(3);
}
impl _NV_GPU_ARCH_IMPLEMENTATION_ID {
    pub const NV_GPU_ARCH_IMPLEMENTATION_AD104: _NV_GPU_ARCH_IMPLEMENTATION_ID =
        _NV_GPU_ARCH_IMPLEMENTATION_ID(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_ARCH_IMPLEMENTATION_ID(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_ARCH_IMPLEMENTATION_ID as NV_GPU_ARCH_IMPLEMENTATION_ID;
impl _NV_GPU_CHIP_REVISION {
    pub const NV_GPU_CHIP_REV_EMULATION_QT: _NV_GPU_CHIP_REVISION = _NV_GPU_CHIP_REVISION(0);
}
impl _NV_GPU_CHIP_REVISION {
    pub const NV_GPU_CHIP_REV_EMULATION_FPGA: _NV_GPU_CHIP_REVISION = _NV_GPU_CHIP_REVISION(1);
}
impl _NV_GPU_CHIP_REVISION {
    pub const NV_GPU_CHIP_REV_A01: _NV_GPU_CHIP_REVISION = _NV_GPU_CHIP_REVISION(17);
}
impl _NV_GPU_CHIP_REVISION {
    pub const NV_GPU_CHIP_REV_A02: _NV_GPU_CHIP_REVISION = _NV_GPU_CHIP_REVISION(18);
}
impl _NV_GPU_CHIP_REVISION {
    pub const NV_GPU_CHIP_REV_A03: _NV_GPU_CHIP_REVISION = _NV_GPU_CHIP_REVISION(19);
}
impl _NV_GPU_CHIP_REVISION {
    pub const NV_GPU_CHIP_REV_UNKNOWN: _NV_GPU_CHIP_REVISION = _NV_GPU_CHIP_REVISION(-1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_CHIP_REVISION(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_CHIP_REVISION as NV_GPU_CHIP_REVISION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_ARCH_INFO_V2 {
    pub version: NvU32,
    pub __bindgen_anon_1: NV_GPU_ARCH_INFO_V2__bindgen_ty_1,
    pub __bindgen_anon_2: NV_GPU_ARCH_INFO_V2__bindgen_ty_2,
    pub __bindgen_anon_3: NV_GPU_ARCH_INFO_V2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_ARCH_INFO_V2__bindgen_ty_1 {
    pub architecture: NvU32,
    pub architecture_id: NV_GPU_ARCHITECTURE_ID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_ARCH_INFO_V2__bindgen_ty_2 {
    pub implementation: NvU32,
    pub implementation_id: NV_GPU_ARCH_IMPLEMENTATION_ID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_GPU_ARCH_INFO_V2__bindgen_ty_3 {
    pub revision: NvU32,
    pub revision_id: NV_GPU_CHIP_REVISION,
}
pub type NV_GPU_ARCH_INFO = NV_GPU_ARCH_INFO_V2;
impl NV_I2C_SPEED {
    pub const NVAPI_I2C_SPEED_DEFAULT: NV_I2C_SPEED = NV_I2C_SPEED(0);
}
impl NV_I2C_SPEED {
    pub const NVAPI_I2C_SPEED_3KHZ: NV_I2C_SPEED = NV_I2C_SPEED(1);
}
impl NV_I2C_SPEED {
    pub const NVAPI_I2C_SPEED_10KHZ: NV_I2C_SPEED = NV_I2C_SPEED(2);
}
impl NV_I2C_SPEED {
    pub const NVAPI_I2C_SPEED_33KHZ: NV_I2C_SPEED = NV_I2C_SPEED(3);
}
impl NV_I2C_SPEED {
    pub const NVAPI_I2C_SPEED_100KHZ: NV_I2C_SPEED = NV_I2C_SPEED(4);
}
impl NV_I2C_SPEED {
    pub const NVAPI_I2C_SPEED_200KHZ: NV_I2C_SPEED = NV_I2C_SPEED(5);
}
impl NV_I2C_SPEED {
    pub const NVAPI_I2C_SPEED_400KHZ: NV_I2C_SPEED = NV_I2C_SPEED(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_I2C_SPEED(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_I2C_INFO_V1 {
    pub version: NvU32,
    pub displayMask: NvU32,
    pub bIsDDCPort: NvU8,
    pub i2cDevAddress: NvU8,
    pub pbI2cRegAddress: *mut NvU8,
    pub regAddrSize: NvU32,
    pub pbData: *mut NvU8,
    pub cbSize: NvU32,
    pub i2cSpeed: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_I2C_INFO_V2 {
    pub version: NvU32,
    pub displayMask: NvU32,
    pub bIsDDCPort: NvU8,
    pub i2cDevAddress: NvU8,
    pub pbI2cRegAddress: *mut NvU8,
    pub regAddrSize: NvU32,
    pub pbData: *mut NvU8,
    pub cbSize: NvU32,
    pub i2cSpeed: NvU32,
    pub i2cSpeedKhz: NV_I2C_SPEED,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_I2C_INFO_V3 {
    pub version: NvU32,
    pub displayMask: NvU32,
    pub bIsDDCPort: NvU8,
    pub i2cDevAddress: NvU8,
    pub pbI2cRegAddress: *mut NvU8,
    pub regAddrSize: NvU32,
    pub pbData: *mut NvU8,
    pub cbSize: NvU32,
    pub i2cSpeed: NvU32,
    pub i2cSpeedKhz: NV_I2C_SPEED,
    pub portId: NvU8,
    pub bIsPortIdSet: NvU32,
}
pub type NV_I2C_INFO = NV_I2C_INFO_V3;
impl NVAPI_GPU_WORKSTATION_FEATURE_MASK {
    pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_SWAPGROUP: NVAPI_GPU_WORKSTATION_FEATURE_MASK =
        NVAPI_GPU_WORKSTATION_FEATURE_MASK(1);
}
impl NVAPI_GPU_WORKSTATION_FEATURE_MASK {
    pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_STEREO: NVAPI_GPU_WORKSTATION_FEATURE_MASK =
        NVAPI_GPU_WORKSTATION_FEATURE_MASK(16);
}
impl NVAPI_GPU_WORKSTATION_FEATURE_MASK {
    pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_WARPING: NVAPI_GPU_WORKSTATION_FEATURE_MASK =
        NVAPI_GPU_WORKSTATION_FEATURE_MASK(256);
}
impl NVAPI_GPU_WORKSTATION_FEATURE_MASK {
    pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_PIXINTENSITY: NVAPI_GPU_WORKSTATION_FEATURE_MASK =
        NVAPI_GPU_WORKSTATION_FEATURE_MASK(512);
}
impl NVAPI_GPU_WORKSTATION_FEATURE_MASK {
    pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_GRAYSCALE: NVAPI_GPU_WORKSTATION_FEATURE_MASK =
        NVAPI_GPU_WORKSTATION_FEATURE_MASK(1024);
}
impl NVAPI_GPU_WORKSTATION_FEATURE_MASK {
    pub const NVAPI_GPU_WORKSTATION_FEATURE_MASK_BPC10: NVAPI_GPU_WORKSTATION_FEATURE_MASK =
        NVAPI_GPU_WORKSTATION_FEATURE_MASK(4096);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NVAPI_GPU_WORKSTATION_FEATURE_MASK(pub ::std::os::raw::c_int);
impl _NV_GPU_HDCP_FUSE_STATE {
    pub const NV_GPU_HDCP_FUSE_STATE_UNKNOWN: _NV_GPU_HDCP_FUSE_STATE = _NV_GPU_HDCP_FUSE_STATE(0);
}
impl _NV_GPU_HDCP_FUSE_STATE {
    pub const NV_GPU_HDCP_FUSE_STATE_DISABLED: _NV_GPU_HDCP_FUSE_STATE = _NV_GPU_HDCP_FUSE_STATE(1);
}
impl _NV_GPU_HDCP_FUSE_STATE {
    pub const NV_GPU_HDCP_FUSE_STATE_ENABLED: _NV_GPU_HDCP_FUSE_STATE = _NV_GPU_HDCP_FUSE_STATE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_HDCP_FUSE_STATE(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_HDCP_FUSE_STATE as NV_GPU_HDCP_FUSE_STATE;
impl _NV_GPU_HDCP_KEY_SOURCE {
    pub const NV_GPU_HDCP_KEY_SOURCE_UNKNOWN: _NV_GPU_HDCP_KEY_SOURCE = _NV_GPU_HDCP_KEY_SOURCE(0);
}
impl _NV_GPU_HDCP_KEY_SOURCE {
    pub const NV_GPU_HDCP_KEY_SOURCE_NONE: _NV_GPU_HDCP_KEY_SOURCE = _NV_GPU_HDCP_KEY_SOURCE(1);
}
impl _NV_GPU_HDCP_KEY_SOURCE {
    pub const NV_GPU_HDCP_KEY_SOURCE_CRYPTO_ROM: _NV_GPU_HDCP_KEY_SOURCE =
        _NV_GPU_HDCP_KEY_SOURCE(2);
}
impl _NV_GPU_HDCP_KEY_SOURCE {
    pub const NV_GPU_HDCP_KEY_SOURCE_SBIOS: _NV_GPU_HDCP_KEY_SOURCE = _NV_GPU_HDCP_KEY_SOURCE(3);
}
impl _NV_GPU_HDCP_KEY_SOURCE {
    pub const NV_GPU_HDCP_KEY_SOURCE_I2C_ROM: _NV_GPU_HDCP_KEY_SOURCE = _NV_GPU_HDCP_KEY_SOURCE(4);
}
impl _NV_GPU_HDCP_KEY_SOURCE {
    pub const NV_GPU_HDCP_KEY_SOURCE_FUSES: _NV_GPU_HDCP_KEY_SOURCE = _NV_GPU_HDCP_KEY_SOURCE(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_HDCP_KEY_SOURCE(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_HDCP_KEY_SOURCE as NV_GPU_HDCP_KEY_SOURCE;
impl _NV_GPU_HDCP_KEY_SOURCE_STATE {
    pub const NV_GPU_HDCP_KEY_SOURCE_STATE_UNKNOWN: _NV_GPU_HDCP_KEY_SOURCE_STATE =
        _NV_GPU_HDCP_KEY_SOURCE_STATE(0);
}
impl _NV_GPU_HDCP_KEY_SOURCE_STATE {
    pub const NV_GPU_HDCP_KEY_SOURCE_STATE_ABSENT: _NV_GPU_HDCP_KEY_SOURCE_STATE =
        _NV_GPU_HDCP_KEY_SOURCE_STATE(1);
}
impl _NV_GPU_HDCP_KEY_SOURCE_STATE {
    pub const NV_GPU_HDCP_KEY_SOURCE_STATE_PRESENT: _NV_GPU_HDCP_KEY_SOURCE_STATE =
        _NV_GPU_HDCP_KEY_SOURCE_STATE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_HDCP_KEY_SOURCE_STATE(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_HDCP_KEY_SOURCE_STATE as NV_GPU_HDCP_KEY_SOURCE_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_GET_HDCP_SUPPORT_STATUS {
    pub version: NvU32,
    pub hdcpFuseState: NV_GPU_HDCP_FUSE_STATE,
    pub hdcpKeySource: NV_GPU_HDCP_KEY_SOURCE,
    pub hdcpKeySourceState: NV_GPU_HDCP_KEY_SOURCE_STATE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_COMPUTE_GPU_TOPOLOGY_V1 {
    pub version: NvU32,
    pub gpuCount: NvU32,
    pub computeGpus: [NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_COMPUTE_GPU_TOPOLOGY_V1__bindgen_ty_1 {
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    pub flags: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COMPUTE_GPU {
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    pub flags: NvU32,
}
pub type NV_COMPUTE_GPU = _NV_COMPUTE_GPU;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COMPUTE_GPU_TOPOLOGY_V2 {
    pub version: NvU32,
    pub gpuCount: NvU32,
    pub computeGpus: *mut NV_COMPUTE_GPU,
}
pub type NV_COMPUTE_GPU_TOPOLOGY_V2 = _NV_COMPUTE_GPU_TOPOLOGY_V2;
pub type NV_COMPUTE_GPU_TOPOLOGY = NV_COMPUTE_GPU_TOPOLOGY_V2;
impl _NV_ECC_CONFIGURATION {
    pub const NV_ECC_CONFIGURATION_NOT_SUPPORTED: _NV_ECC_CONFIGURATION = _NV_ECC_CONFIGURATION(0);
}
impl _NV_ECC_CONFIGURATION {
    pub const NV_ECC_CONFIGURATION_DEFERRED: _NV_ECC_CONFIGURATION = _NV_ECC_CONFIGURATION(1);
}
impl _NV_ECC_CONFIGURATION {
    pub const NV_ECC_CONFIGURATION_IMMEDIATE: _NV_ECC_CONFIGURATION = _NV_ECC_CONFIGURATION(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ECC_CONFIGURATION(pub ::std::os::raw::c_int);
pub use self::_NV_ECC_CONFIGURATION as NV_ECC_CONFIGURATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_ECC_STATUS_INFO {
    pub version: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub configurationOptions: NV_ECC_CONFIGURATION,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl NV_GPU_ECC_STATUS_INFO {
    #[inline]
    pub fn isSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isSupported: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isSupported: u32 = unsafe { ::std::mem::transmute(isSupported) };
            isSupported as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(isEnabled: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_ECC_ERROR_INFO {
    pub version: NvU32,
    pub current: NV_GPU_ECC_ERROR_INFO__bindgen_ty_1,
    pub aggregate: NV_GPU_ECC_ERROR_INFO__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_ECC_ERROR_INFO__bindgen_ty_1 {
    pub singleBitErrors: NvU64,
    pub doubleBitErrors: NvU64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_ECC_ERROR_INFO__bindgen_ty_2 {
    pub singleBitErrors: NvU64,
    pub doubleBitErrors: NvU64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_ECC_CONFIGURATION_INFO {
    pub version: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl NV_GPU_ECC_CONFIGURATION_INFO {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEnabledByDefault(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabledByDefault(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        isEnabledByDefault: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isEnabledByDefault: u32 = unsafe { ::std::mem::transmute(isEnabledByDefault) };
            isEnabledByDefault as u64
        });
        __bindgen_bitfield_unit
    }
}
impl NV_QSYNC_EVENT {
    pub const NV_QSYNC_EVENT_NONE: NV_QSYNC_EVENT = NV_QSYNC_EVENT(0);
}
impl NV_QSYNC_EVENT {
    pub const NV_QSYNC_EVENT_SYNC_LOSS: NV_QSYNC_EVENT = NV_QSYNC_EVENT(1);
}
impl NV_QSYNC_EVENT {
    pub const NV_QSYNC_EVENT_SYNC_GAIN: NV_QSYNC_EVENT = NV_QSYNC_EVENT(2);
}
impl NV_QSYNC_EVENT {
    pub const NV_QSYNC_EVENT_HOUSESYNC_GAIN: NV_QSYNC_EVENT = NV_QSYNC_EVENT(3);
}
impl NV_QSYNC_EVENT {
    pub const NV_QSYNC_EVENT_HOUSESYNC_LOSS: NV_QSYNC_EVENT = NV_QSYNC_EVENT(4);
}
impl NV_QSYNC_EVENT {
    pub const NV_QSYNC_EVENT_RJ45_GAIN: NV_QSYNC_EVENT = NV_QSYNC_EVENT(5);
}
impl NV_QSYNC_EVENT {
    pub const NV_QSYNC_EVENT_RJ45_LOSS: NV_QSYNC_EVENT = NV_QSYNC_EVENT(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_QSYNC_EVENT(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_QSYNC_EVENT_DATA {
    pub qsyncEvent: NV_QSYNC_EVENT,
    pub reserved: [NvU32; 7usize],
}
pub type NVAPI_CALLBACK_QSYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        qyncEventData: NV_QSYNC_EVENT_DATA,
        callbackParam: *mut ::std::os::raw::c_void,
    ),
>;
impl NV_EVENT_TYPE {
    pub const NV_EVENT_TYPE_NONE: NV_EVENT_TYPE = NV_EVENT_TYPE(0);
}
impl NV_EVENT_TYPE {
    pub const NV_EVENT_TYPE_QSYNC: NV_EVENT_TYPE = NV_EVENT_TYPE(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_EVENT_TYPE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_EVENT_REGISTER_CALLBACK {
    pub version: NvU32,
    pub eventId: NV_EVENT_TYPE,
    pub callbackParam: *mut ::std::os::raw::c_void,
    pub nvCallBackFunc: NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_EVENT_REGISTER_CALLBACK__bindgen_ty_1 {
    pub nvQSYNCEventCallback: NVAPI_CALLBACK_QSYNCEVENT,
}
impl _NV_GPU_WORKSTATION_FEATURE_TYPE {
    pub const NV_GPU_WORKSTATION_FEATURE_TYPE_NVIDIA_RTX_VR_READY:
        _NV_GPU_WORKSTATION_FEATURE_TYPE = _NV_GPU_WORKSTATION_FEATURE_TYPE(1);
}
impl _NV_GPU_WORKSTATION_FEATURE_TYPE {
    pub const NV_GPU_WORKSTATION_FEATURE_TYPE_QUADRO_VR_READY: _NV_GPU_WORKSTATION_FEATURE_TYPE =
        _NV_GPU_WORKSTATION_FEATURE_TYPE(1);
}
impl _NV_GPU_WORKSTATION_FEATURE_TYPE {
    pub const NV_GPU_WORKSTATION_FEATURE_TYPE_PROVIZ: _NV_GPU_WORKSTATION_FEATURE_TYPE =
        _NV_GPU_WORKSTATION_FEATURE_TYPE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_WORKSTATION_FEATURE_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_WORKSTATION_FEATURE_TYPE as NV_GPU_WORKSTATION_FEATURE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_SCANOUT_INTENSITY_DATA_V1 {
    pub version: NvU32,
    pub width: NvU32,
    pub height: NvU32,
    pub blendingTexture: *mut f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_SCANOUT_INTENSITY_DATA_V2 {
    pub version: NvU32,
    pub width: NvU32,
    pub height: NvU32,
    pub blendingTexture: *mut f32,
    pub offsetTexture: *mut f32,
    pub offsetTexChannels: NvU32,
}
pub type NV_SCANOUT_INTENSITY_DATA = NV_SCANOUT_INTENSITY_DATA_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SCANOUT_INTENSITY_STATE_DATA {
    pub version: NvU32,
    pub bEnabled: NvU32,
}
pub type NV_SCANOUT_INTENSITY_STATE_DATA = _NV_SCANOUT_INTENSITY_STATE_DATA;
impl NV_GPU_WARPING_VERTICE_FORMAT {
    pub const NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLESTRIP_XYUVRQ: NV_GPU_WARPING_VERTICE_FORMAT =
        NV_GPU_WARPING_VERTICE_FORMAT(0);
}
impl NV_GPU_WARPING_VERTICE_FORMAT {
    pub const NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLES_XYUVRQ: NV_GPU_WARPING_VERTICE_FORMAT =
        NV_GPU_WARPING_VERTICE_FORMAT(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_WARPING_VERTICE_FORMAT(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_SCANOUT_WARPING_DATA {
    pub version: NvU32,
    pub vertices: *mut f32,
    pub vertexFormat: NV_GPU_WARPING_VERTICE_FORMAT,
    pub numVertices: ::std::os::raw::c_int,
    pub textureRect: *mut NvSBox,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SCANOUT_WARPING_STATE_DATA {
    pub version: NvU32,
    pub bEnabled: NvU32,
}
pub type NV_SCANOUT_WARPING_STATE_DATA = _NV_SCANOUT_WARPING_STATE_DATA;
impl NV_GPU_SCANOUT_COMPOSITION_PARAMETER {
    pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_WARPING_RESAMPLING_METHOD:
        NV_GPU_SCANOUT_COMPOSITION_PARAMETER = NV_GPU_SCANOUT_COMPOSITION_PARAMETER(0);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_SCANOUT_COMPOSITION_PARAMETER(pub ::std::os::raw::c_int);
impl NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE {
    pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_SET_TO_DEFAULT:
        NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE(0);
}
impl NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE {
    pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BILINEAR:
        NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE =
        NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE(256);
}
impl NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE {
    pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_TRIANGULAR : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE (257) ;
}
impl NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE {
    pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BELL_SHAPED : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE (258) ;
}
impl NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE {
    pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BSPLINE : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE (259) ;
}
impl NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE {
    pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_TRIANGULAR : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE (260) ;
}
impl NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE {
    pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BELL_SHAPED : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE (261) ;
}
impl NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE {
    pub const NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BSPLINE : NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE = NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE (262) ;
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SCANOUT_INFORMATION {
    pub version: NvU32,
    pub sourceDesktopRect: NvSBox,
    pub sourceViewportRect: NvSBox,
    pub targetViewportRect: NvSBox,
    pub targetDisplayWidth: NvU32,
    pub targetDisplayHeight: NvU32,
    pub cloneImportance: NvU32,
    pub sourceToTargetRotation: NV_ROTATE,
}
pub type NV_SCANOUT_INFORMATION = _NV_SCANOUT_INFORMATION;
impl _NV_VIRTUALIZATION_MODE {
    pub const NV_VIRTUALIZATION_MODE_NONE: _NV_VIRTUALIZATION_MODE = _NV_VIRTUALIZATION_MODE(0);
}
impl _NV_VIRTUALIZATION_MODE {
    pub const NV_VIRTUALIZATION_MODE_NMOS: _NV_VIRTUALIZATION_MODE = _NV_VIRTUALIZATION_MODE(1);
}
impl _NV_VIRTUALIZATION_MODE {
    pub const NV_VIRTUALIZATION_MODE_VGX: _NV_VIRTUALIZATION_MODE = _NV_VIRTUALIZATION_MODE(2);
}
impl _NV_VIRTUALIZATION_MODE {
    pub const NV_VIRTUALIZATION_MODE_HOST_VGPU: _NV_VIRTUALIZATION_MODE =
        _NV_VIRTUALIZATION_MODE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_VIRTUALIZATION_MODE(pub ::std::os::raw::c_int);
pub use self::_NV_VIRTUALIZATION_MODE as NV_VIRTUALIZATION_MODE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_VIRTUALIZATION_INFO {
    pub version: NvU32,
    pub virtualizationMode: NV_VIRTUALIZATION_MODE,
    pub reserved: NvU32,
}
pub type NV_GPU_VIRTUALIZATION_INFO_V1 = _NV_GPU_VIRTUALIZATION_INFO;
pub type NV_GPU_VIRTUALIZATION_INFO = NV_GPU_VIRTUALIZATION_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LOGICAL_GPU_DATA_V1 {
    pub version: NvU32,
    pub pOSAdapterId: *mut ::std::os::raw::c_void,
    pub physicalGpuCount: NvU32,
    pub physicalGpuHandles: [NvPhysicalGpuHandle; 64usize],
    pub reserved: [NvU32; 8usize],
}
pub type NV_LOGICAL_GPU_DATA_V1 = _NV_LOGICAL_GPU_DATA_V1;
pub type NV_LOGICAL_GPU_DATA = NV_LOGICAL_GPU_DATA_V1;
pub type NvAPI_LicenseString = [::std::os::raw::c_char; 128usize];
impl _NV_LICENSE_FEATURE_TYPE {
    pub const NV_LICENSE_FEATURE_UNKNOWN: _NV_LICENSE_FEATURE_TYPE = _NV_LICENSE_FEATURE_TYPE(0);
}
impl _NV_LICENSE_FEATURE_TYPE {
    pub const NV_LICENSE_FEATURE_VGPU: _NV_LICENSE_FEATURE_TYPE = _NV_LICENSE_FEATURE_TYPE(1);
}
impl _NV_LICENSE_FEATURE_TYPE {
    pub const NV_LICENSE_FEATURE_NVIDIA_RTX: _NV_LICENSE_FEATURE_TYPE = _NV_LICENSE_FEATURE_TYPE(2);
}
impl _NV_LICENSE_FEATURE_TYPE {
    pub const NV_LICENSE_FEATURE_QUADRO: _NV_LICENSE_FEATURE_TYPE = _NV_LICENSE_FEATURE_TYPE(2);
}
impl _NV_LICENSE_FEATURE_TYPE {
    pub const NV_LICENSE_FEATURE_GAMING: _NV_LICENSE_FEATURE_TYPE = _NV_LICENSE_FEATURE_TYPE(3);
}
impl _NV_LICENSE_FEATURE_TYPE {
    pub const NV_LICENSE_FEATURE_COMPUTE: _NV_LICENSE_FEATURE_TYPE = _NV_LICENSE_FEATURE_TYPE(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_LICENSE_FEATURE_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_LICENSE_FEATURE_TYPE as NV_LICENSE_FEATURE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LICENSE_EXPIRY_DETAILS {
    pub year: NvU32,
    pub month: NvU16,
    pub day: NvU16,
    pub hour: NvU16,
    pub min: NvU16,
    pub sec: NvU16,
    pub status: NvU8,
}
pub type NV_LICENSE_EXPIRY_DETAILS = _NV_LICENSE_EXPIRY_DETAILS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    pub licenseInfo: NvAPI_LicenseString,
}
impl _NV_LICENSE_FEATURE_DETAILS_V1 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V1 = _NV_LICENSE_FEATURE_DETAILS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V2 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    pub licenseInfo: NvAPI_LicenseString,
    pub productName: NvAPI_LicenseString,
}
impl _NV_LICENSE_FEATURE_DETAILS_V2 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V2 = _NV_LICENSE_FEATURE_DETAILS_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V3 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    pub licenseInfo: NvAPI_LicenseString,
    pub productName: NvAPI_LicenseString,
}
impl _NV_LICENSE_FEATURE_DETAILS_V3 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isFeatureEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isFeatureEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        isFeatureEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isFeatureEnabled: u32 = unsafe { ::std::mem::transmute(isFeatureEnabled) };
            isFeatureEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V3 = _NV_LICENSE_FEATURE_DETAILS_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LICENSE_FEATURE_DETAILS_V4 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub featureCode: NV_LICENSE_FEATURE_TYPE,
    pub licenseInfo: NvAPI_LicenseString,
    pub productName: NvAPI_LicenseString,
    pub licenseExpiry: NV_LICENSE_EXPIRY_DETAILS,
}
impl _NV_LICENSE_FEATURE_DETAILS_V4 {
    #[inline]
    pub fn isEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isFeatureEnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isFeatureEnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEnabled: NvU32,
        isFeatureEnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEnabled: u32 = unsafe { ::std::mem::transmute(isEnabled) };
            isEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isFeatureEnabled: u32 = unsafe { ::std::mem::transmute(isFeatureEnabled) };
            isFeatureEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSE_FEATURE_DETAILS_V4 = _NV_LICENSE_FEATURE_DETAILS_V4;
pub type NV_LICENSE_FEATURE_DETAILS = NV_LICENSE_FEATURE_DETAILS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub licensableFeatureCount: NvU32,
    pub signature: [NvU8; 128usize],
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V1; 3usize],
}
impl _NV_LICENSABLE_FEATURES_V1 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V1 = _NV_LICENSABLE_FEATURES_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V2 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub licensableFeatureCount: NvU32,
    pub signature: [NvU8; 128usize],
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V2; 3usize],
}
impl _NV_LICENSABLE_FEATURES_V2 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V2 = _NV_LICENSABLE_FEATURES_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V3 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub licensableFeatureCount: NvU32,
    pub signature: [NvU8; 128usize],
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V3; 3usize],
}
impl _NV_LICENSABLE_FEATURES_V3 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V3 = _NV_LICENSABLE_FEATURES_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LICENSABLE_FEATURES_V4 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub licensableFeatureCount: NvU32,
    pub signature: [NvU8; 128usize],
    pub licenseDetails: [NV_LICENSE_FEATURE_DETAILS_V4; 3usize],
}
impl _NV_LICENSABLE_FEATURES_V4 {
    #[inline]
    pub fn isLicenseSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isLicenseSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isLicenseSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isLicenseSupported: u32 = unsafe { ::std::mem::transmute(isLicenseSupported) };
            isLicenseSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_LICENSABLE_FEATURES_V4 = _NV_LICENSABLE_FEATURES_V4;
pub type NV_LICENSABLE_FEATURES = NV_LICENSABLE_FEATURES_V4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_VR_READY_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NV_GPU_VR_READY_V1 {
    #[inline]
    pub fn isVRReady(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isVRReady(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isVRReady: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isVRReady: u32 = unsafe { ::std::mem::transmute(isVRReady) };
            isVRReady as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GPU_VR_READY_V1 = _NV_GPU_VR_READY_V1;
pub type NV_GPU_VR_READY = NV_GPU_VR_READY_V1;
impl _NVAPI_GPU_PERF_DECREASE {
    pub const NV_GPU_PERF_DECREASE_NONE: _NVAPI_GPU_PERF_DECREASE = _NVAPI_GPU_PERF_DECREASE(0);
}
impl _NVAPI_GPU_PERF_DECREASE {
    pub const NV_GPU_PERF_DECREASE_REASON_THERMAL_PROTECTION: _NVAPI_GPU_PERF_DECREASE =
        _NVAPI_GPU_PERF_DECREASE(1);
}
impl _NVAPI_GPU_PERF_DECREASE {
    pub const NV_GPU_PERF_DECREASE_REASON_POWER_CONTROL: _NVAPI_GPU_PERF_DECREASE =
        _NVAPI_GPU_PERF_DECREASE(2);
}
impl _NVAPI_GPU_PERF_DECREASE {
    pub const NV_GPU_PERF_DECREASE_REASON_AC_BATT: _NVAPI_GPU_PERF_DECREASE =
        _NVAPI_GPU_PERF_DECREASE(4);
}
impl _NVAPI_GPU_PERF_DECREASE {
    pub const NV_GPU_PERF_DECREASE_REASON_API_TRIGGERED: _NVAPI_GPU_PERF_DECREASE =
        _NVAPI_GPU_PERF_DECREASE(8);
}
impl _NVAPI_GPU_PERF_DECREASE {
    pub const NV_GPU_PERF_DECREASE_REASON_INSUFFICIENT_POWER: _NVAPI_GPU_PERF_DECREASE =
        _NVAPI_GPU_PERF_DECREASE(16);
}
impl _NVAPI_GPU_PERF_DECREASE {
    pub const NV_GPU_PERF_DECREASE_REASON_UNKNOWN: _NVAPI_GPU_PERF_DECREASE =
        _NVAPI_GPU_PERF_DECREASE(-2147483648);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_GPU_PERF_DECREASE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_GPU_PERF_DECREASE as NVAPI_GPU_PERF_DECREASE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V1 {
    pub version: NvU32,
    pub flags: NvU32,
    pub numPstates: NvU32,
    pub numClocks: NvU32,
    pub pstates: [NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1 {
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    pub flags: NvU32,
    pub clocks: [NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V1__bindgen_ty_1__bindgen_ty_1 {
    pub domainId: NV_GPU_PUBLIC_CLOCK_ID,
    pub flags: NvU32,
    pub freq: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2 {
    pub version: NvU32,
    pub flags: NvU32,
    pub numPstates: NvU32,
    pub numClocks: NvU32,
    pub numVoltages: NvU32,
    pub pstates: [NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1 {
    pub pstateId: NV_GPU_PERF_PSTATE_ID,
    pub flags: NvU32,
    pub clocks: [NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1; 32usize],
    pub voltages: [NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_1 {
    pub domainId: NV_GPU_PUBLIC_CLOCK_ID,
    pub flags: NvU32,
    pub freq: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_PERF_PSTATES_INFO_V2__bindgen_ty_1__bindgen_ty_2 {
    pub domainId: NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID,
    pub flags: NvU32,
    pub mvolt: NvU32,
}
pub type NV_GPU_PERF_PSTATES_INFO = NV_GPU_PERF_PSTATES_INFO_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_DYNAMIC_PSTATES_INFO_EX {
    pub version: NvU32,
    pub flags: NvU32,
    pub utilization: [NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub percentage: NvU32,
}
impl NV_GPU_DYNAMIC_PSTATES_INFO_EX__bindgen_ty_1 {
    #[inline]
    pub fn bIsPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bIsPresent: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsPresent: u32 = unsafe { ::std::mem::transmute(bIsPresent) };
            bIsPresent as u64
        });
        __bindgen_bitfield_unit
    }
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_NONE: NV_THERMAL_TARGET = NV_THERMAL_TARGET(0);
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_GPU: NV_THERMAL_TARGET = NV_THERMAL_TARGET(1);
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_MEMORY: NV_THERMAL_TARGET = NV_THERMAL_TARGET(2);
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_POWER_SUPPLY: NV_THERMAL_TARGET = NV_THERMAL_TARGET(4);
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_BOARD: NV_THERMAL_TARGET = NV_THERMAL_TARGET(8);
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_VCD_BOARD: NV_THERMAL_TARGET = NV_THERMAL_TARGET(9);
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_VCD_INLET: NV_THERMAL_TARGET = NV_THERMAL_TARGET(10);
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_VCD_OUTLET: NV_THERMAL_TARGET = NV_THERMAL_TARGET(11);
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_ALL: NV_THERMAL_TARGET = NV_THERMAL_TARGET(15);
}
impl NV_THERMAL_TARGET {
    pub const NVAPI_THERMAL_TARGET_UNKNOWN: NV_THERMAL_TARGET = NV_THERMAL_TARGET(-1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_THERMAL_TARGET(pub ::std::os::raw::c_int);
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_NONE: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(0);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_GPU_INTERNAL: NV_THERMAL_CONTROLLER =
        NV_THERMAL_CONTROLLER(1);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_ADM1032: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(2);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_MAX6649: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(3);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_MAX1617: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(4);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_LM99: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(5);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_LM89: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(6);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_LM64: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(7);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_ADT7473: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(8);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_SBMAX6649: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(9);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_VBIOSEVT: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(10);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_OS: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(11);
}
impl NV_THERMAL_CONTROLLER {
    pub const NVAPI_THERMAL_CONTROLLER_UNKNOWN: NV_THERMAL_CONTROLLER = NV_THERMAL_CONTROLLER(-1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_THERMAL_CONTROLLER(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V1 {
    pub version: NvU32,
    pub count: NvU32,
    pub sensor: [NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V1__bindgen_ty_1 {
    pub controller: NV_THERMAL_CONTROLLER,
    pub defaultMinTemp: NvU32,
    pub defaultMaxTemp: NvU32,
    pub currentTemp: NvU32,
    pub target: NV_THERMAL_TARGET,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V2 {
    pub version: NvU32,
    pub count: NvU32,
    pub sensor: [NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_THERMAL_SETTINGS_V2__bindgen_ty_1 {
    pub controller: NV_THERMAL_CONTROLLER,
    pub defaultMinTemp: NvS32,
    pub defaultMaxTemp: NvS32,
    pub currentTemp: NvS32,
    pub target: NV_THERMAL_TARGET,
}
pub type NV_GPU_THERMAL_SETTINGS = NV_GPU_THERMAL_SETTINGS_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V1 {
    pub version: NvU32,
    pub reserved: NvU32,
    pub domain: [NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub frequency: NvU32,
}
impl NV_GPU_CLOCK_FREQUENCIES_V1__bindgen_ty_1 {
    #[inline]
    pub fn bIsPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsPresent: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsPresent: u32 = unsafe { ::std::mem::transmute(bIsPresent) };
            bIsPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE {
    pub const NV_GPU_CLOCK_FREQUENCIES_CURRENT_FREQ: NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE =
        NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE(0);
}
impl NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE {
    pub const NV_GPU_CLOCK_FREQUENCIES_BASE_CLOCK: NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE =
        NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE(1);
}
impl NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE {
    pub const NV_GPU_CLOCK_FREQUENCIES_BOOST_CLOCK: NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE =
        NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE(2);
}
impl NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE {
    pub const NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NUM: NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE =
        NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V2 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub domain: [NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub frequency: NvU32,
}
impl NV_GPU_CLOCK_FREQUENCIES_V2__bindgen_ty_1 {
    #[inline]
    pub fn bIsPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsPresent: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsPresent: u32 = unsafe { ::std::mem::transmute(bIsPresent) };
            bIsPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl NV_GPU_CLOCK_FREQUENCIES_V2 {
    #[inline]
    pub fn ClockType(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ClockType(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClockType: NvU32,
        reserved: NvU32,
        reserved1: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ClockType: u32 = unsafe { ::std::mem::transmute(ClockType) };
            ClockType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GPU_CLOCK_FREQUENCIES = NV_GPU_CLOCK_FREQUENCIES_V2;
impl _NV_GPU_ILLUMINATION_ATTRIB {
    pub const NV_GPU_IA_LOGO_BRIGHTNESS: _NV_GPU_ILLUMINATION_ATTRIB =
        _NV_GPU_ILLUMINATION_ATTRIB(0);
}
impl _NV_GPU_ILLUMINATION_ATTRIB {
    pub const NV_GPU_IA_SLI_BRIGHTNESS: _NV_GPU_ILLUMINATION_ATTRIB =
        _NV_GPU_ILLUMINATION_ATTRIB(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_ILLUMINATION_ATTRIB(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_ILLUMINATION_ATTRIB as NV_GPU_ILLUMINATION_ATTRIB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 {
    pub version: NvU32,
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    pub Attribute: NV_GPU_ILLUMINATION_ATTRIB,
    pub bSupported: NvU32,
}
pub type NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 = _NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1;
pub type NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM = NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_GET_ILLUMINATION_PARM_V1 {
    pub version: NvU32,
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    pub Attribute: NV_GPU_ILLUMINATION_ATTRIB,
    pub Value: NvU32,
}
pub type NV_GPU_GET_ILLUMINATION_PARM_V1 = _NV_GPU_GET_ILLUMINATION_PARM_V1;
pub type NV_GPU_GET_ILLUMINATION_PARM = NV_GPU_GET_ILLUMINATION_PARM_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_SET_ILLUMINATION_PARM_V1 {
    pub version: NvU32,
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    pub Attribute: NV_GPU_ILLUMINATION_ATTRIB,
    pub Value: NvU32,
}
pub type NV_GPU_SET_ILLUMINATION_PARM_V1 = _NV_GPU_SET_ILLUMINATION_PARM_V1;
pub type NV_GPU_SET_ILLUMINATION_PARM = NV_GPU_SET_ILLUMINATION_PARM_V1;
impl NV_GPU_CLIENT_ILLUM_CTRL_MODE {
    pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB: NV_GPU_CLIENT_ILLUM_CTRL_MODE =
        NV_GPU_CLIENT_ILLUM_CTRL_MODE(0);
}
impl NV_GPU_CLIENT_ILLUM_CTRL_MODE {
    pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB: NV_GPU_CLIENT_ILLUM_CTRL_MODE =
        NV_GPU_CLIENT_ILLUM_CTRL_MODE(1);
}
impl NV_GPU_CLIENT_ILLUM_CTRL_MODE {
    pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL: NV_GPU_CLIENT_ILLUM_CTRL_MODE =
        NV_GPU_CLIENT_ILLUM_CTRL_MODE(0);
}
impl NV_GPU_CLIENT_ILLUM_CTRL_MODE {
    pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR: NV_GPU_CLIENT_ILLUM_CTRL_MODE =
        NV_GPU_CLIENT_ILLUM_CTRL_MODE(1);
}
impl NV_GPU_CLIENT_ILLUM_CTRL_MODE {
    pub const NV_GPU_CLIENT_ILLUM_CTRL_MODE_INVALID: NV_GPU_CLIENT_ILLUM_CTRL_MODE =
        NV_GPU_CLIENT_ILLUM_CTRL_MODE(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_CLIENT_ILLUM_CTRL_MODE(pub ::std::os::raw::c_int);
impl NV_GPU_CLIENT_ILLUM_ZONE_LOCATION {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_TOP_0: NV_GPU_CLIENT_ILLUM_ZONE_LOCATION =
        NV_GPU_CLIENT_ILLUM_ZONE_LOCATION(0);
}
impl NV_GPU_CLIENT_ILLUM_ZONE_LOCATION {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_FRONT_0: NV_GPU_CLIENT_ILLUM_ZONE_LOCATION =
        NV_GPU_CLIENT_ILLUM_ZONE_LOCATION(8);
}
impl NV_GPU_CLIENT_ILLUM_ZONE_LOCATION {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_BACK_0: NV_GPU_CLIENT_ILLUM_ZONE_LOCATION =
        NV_GPU_CLIENT_ILLUM_ZONE_LOCATION(12);
}
impl NV_GPU_CLIENT_ILLUM_ZONE_LOCATION {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_SLI_TOP_0: NV_GPU_CLIENT_ILLUM_ZONE_LOCATION =
        NV_GPU_CLIENT_ILLUM_ZONE_LOCATION(32);
}
impl NV_GPU_CLIENT_ILLUM_ZONE_LOCATION {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_INVALID: NV_GPU_CLIENT_ILLUM_ZONE_LOCATION =
        NV_GPU_CLIENT_ILLUM_ZONE_LOCATION(-1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_CLIENT_ILLUM_ZONE_LOCATION(pub ::std::os::raw::c_int);
impl NV_GPU_CLIENT_ILLUM_DEVICE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_INVALID: NV_GPU_CLIENT_ILLUM_DEVICE_TYPE =
        NV_GPU_CLIENT_ILLUM_DEVICE_TYPE(0);
}
impl NV_GPU_CLIENT_ILLUM_DEVICE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_MCUV10: NV_GPU_CLIENT_ILLUM_DEVICE_TYPE =
        NV_GPU_CLIENT_ILLUM_DEVICE_TYPE(1);
}
impl NV_GPU_CLIENT_ILLUM_DEVICE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_GPIO_PWM_RGBW_V10: NV_GPU_CLIENT_ILLUM_DEVICE_TYPE =
        NV_GPU_CLIENT_ILLUM_DEVICE_TYPE(2);
}
impl NV_GPU_CLIENT_ILLUM_DEVICE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_GPIO_PWM_SINGLE_COLOR_V10:
        NV_GPU_CLIENT_ILLUM_DEVICE_TYPE = NV_GPU_CLIENT_ILLUM_DEVICE_TYPE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_TYPE(pub ::std::os::raw::c_int);
impl NV_GPU_CLIENT_ILLUM_ZONE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_INVALID: NV_GPU_CLIENT_ILLUM_ZONE_TYPE =
        NV_GPU_CLIENT_ILLUM_ZONE_TYPE(0);
}
impl NV_GPU_CLIENT_ILLUM_ZONE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB: NV_GPU_CLIENT_ILLUM_ZONE_TYPE =
        NV_GPU_CLIENT_ILLUM_ZONE_TYPE(1);
}
impl NV_GPU_CLIENT_ILLUM_ZONE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED: NV_GPU_CLIENT_ILLUM_ZONE_TYPE =
        NV_GPU_CLIENT_ILLUM_ZONE_TYPE(2);
}
impl NV_GPU_CLIENT_ILLUM_ZONE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGBW: NV_GPU_CLIENT_ILLUM_ZONE_TYPE =
        NV_GPU_CLIENT_ILLUM_ZONE_TYPE(3);
}
impl NV_GPU_CLIENT_ILLUM_ZONE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_ZONE_TYPE_SINGLE_COLOR: NV_GPU_CLIENT_ILLUM_ZONE_TYPE =
        NV_GPU_CLIENT_ILLUM_ZONE_TYPE(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_CLIENT_ILLUM_ZONE_TYPE(pub ::std::os::raw::c_int);
impl NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_HALF_HALT:
        NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE =
        NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE(0);
}
impl NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_HALT:
        NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE =
        NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE(1);
}
impl NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_REPEAT:
        NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE =
        NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE(2);
}
impl NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE {
    pub const NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_INVALID:
        NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE =
        NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10 {
    pub i2cDevIdx: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10 = _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW {
    pub gpioPinRed: NvU8,
    pub gpioPinGreen: NvU8,
    pub gpioPinBlue: NvU8,
    pub gpioPinWhite: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW =
    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR {
    pub gpioPinSingleColor: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1 {
    pub type_: NV_GPU_CLIENT_ILLUM_DEVICE_TYPE,
    pub ctrlModeMask: NvU32,
    pub data: _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1__bindgen_ty_1 {
    pub mcuv10: NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10,
    pub gpioPwmRgbwv10: NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW,
    pub gpioPwmSingleColorv10: NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1 = _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1 {
    pub version: NvU32,
    pub numIllumDevices: NvU32,
    pub rsvd: [NvU8; 64usize],
    pub devices: [NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1; 32usize],
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1 = _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1;
pub type NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS = NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1 {
    pub bSync: NvBool,
    pub timeStampms: NvU64,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1 {
    pub type_: NV_GPU_CLIENT_ILLUM_DEVICE_TYPE,
    pub syncData: NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL = NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1 {
    pub version: NvU32,
    pub numIllumDevices: NvU32,
    pub rsvd: [NvU8; 64usize],
    pub devices: [NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1; 32usize],
}
pub type NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS = NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB {
    pub rsvd: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW {
    pub rsvd: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR {
    pub rsvd: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1 {
    pub type_: NV_GPU_CLIENT_ILLUM_ZONE_TYPE,
    pub illumDeviceIdx: NvU8,
    pub provIdx: NvU8,
    pub zoneLocation: NV_GPU_CLIENT_ILLUM_ZONE_LOCATION,
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1__bindgen_ty_1 {
    pub rgb: NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB,
    pub rgbw: NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW,
    pub singleColor: NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1 {
    pub version: NvU32,
    pub numIllumZones: NvU32,
    pub rsvd: [NvU8; 64usize],
    pub zones: [NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1; 32usize],
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1;
pub type NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS = NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS {
    pub colorR: NvU8,
    pub colorG: NvU8,
    pub colorB: NvU8,
    pub brightnessPct: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB {
    pub rgbParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR {
    pub cycleType: NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE,
    pub grpCount: NvU8,
    pub riseTimems: NvU16,
    pub fallTimems: NvU16,
    pub ATimems: NvU16,
    pub BTimems: NvU16,
    pub grpIdleTimems: NvU16,
    pub phaseOffsetms: NvU16,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB {
    pub rgbParams: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB__bindgen_ty_1 {
    pub manualRGB: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB,
    pub piecewiseLinearRGB: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS {
    pub brightnessPct: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED {
    pub colorFixedParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED {
    pub colorFixedParams: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED__bindgen_ty_1 {
    pub manualColorFixed: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED,
    pub piecewiseLinearColorFixed:
        NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS {
    pub colorR: NvU8,
    pub colorG: NvU8,
    pub colorB: NvU8,
    pub colorW: NvU8,
    pub brightnessPct: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW {
    pub rgbwParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW {
    pub rgbwParams: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW__bindgen_ty_1 {
    pub manualRGBW: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW,
    pub piecewiseLinearRGBW: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS {
    pub brightnessPct: NvU8,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR {
    pub singleColorParams: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR {
    pub singleColorParams:
        [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS; 2usize],
    pub piecewiseLinearData: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR,
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR {
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR__bindgen_ty_1 {
    pub manualSingleColor: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR,
    pub piecewiseLinearSingleColor:
        NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR =
    _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1 {
    pub type_: NV_GPU_CLIENT_ILLUM_ZONE_TYPE,
    pub ctrlMode: NV_GPU_CLIENT_ILLUM_CTRL_MODE,
    pub data: _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1,
    pub rsvd: [NvU8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1__bindgen_ty_1 {
    pub rgb: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB,
    pub colorFixed: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED,
    pub rgbw: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW,
    pub singleColor: NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub numIllumZonesControl: NvU32,
    pub rsvd: [NvU8; 64usize],
    pub zones: [NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1; 32usize],
}
impl _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 {
    #[inline]
    pub fn bDefault(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDefault(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvdField(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_rsvdField(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDefault: NvU32,
        rsvdField: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDefault: u32 = unsafe { ::std::mem::transmute(bDefault) };
            bDefault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let rsvdField: u32 = unsafe { ::std::mem::transmute(rsvdField) };
            rsvdField as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 = _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1;
pub type NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS = NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAY_PORT_INFO_V1 {
    pub version: NvU32,
    pub dpcd_ver: NvU32,
    pub maxLinkRate: NV_DP_LINK_RATE,
    pub maxLaneCount: NV_DP_LANE_COUNT,
    pub curLinkRate: NV_DP_LINK_RATE,
    pub curLaneCount: NV_DP_LANE_COUNT,
    pub colorFormat: NV_DP_COLOR_FORMAT,
    pub dynamicRange: NV_DP_DYNAMIC_RANGE,
    pub colorimetry: NV_DP_COLORIMETRY,
    pub bpc: NV_DP_BPC,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NV_DISPLAY_PORT_INFO_V1 {
    #[inline]
    pub fn isDp(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDp(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isInternalDp(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isInternalDp(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isColorCtrlSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isColorCtrlSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is6BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is6BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is8BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is8BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is10BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is10BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is12BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is12BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is16BPCSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is16BPCSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCrCb420Supported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCrCb420Supported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCrCb422Supported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCrCb422Supported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCrCb444Supported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCrCb444Supported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isRgb444SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isRgb444SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCbCr444SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCbCr444SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCbCr422SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCbCr422SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isYCbCr420SupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isYCbCr420SupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is6BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is6BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is8BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is8BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is10BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is10BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is12BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is12BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is16BPCSupportedOnCurrentMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is16BPCSupportedOnCurrentMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC709Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC709Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonsYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonsYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeRGBCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeRGBCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBT2020RGBCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBT2020RGBCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBT2020YCCCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBT2020YCCCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBT2020cYCCCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBT2020cYCCCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isDp: NvU32,
        isInternalDp: NvU32,
        isColorCtrlSupported: NvU32,
        is6BPCSupported: NvU32,
        is8BPCSupported: NvU32,
        is10BPCSupported: NvU32,
        is12BPCSupported: NvU32,
        is16BPCSupported: NvU32,
        isYCrCb420Supported: NvU32,
        isYCrCb422Supported: NvU32,
        isYCrCb444Supported: NvU32,
        isRgb444SupportedOnCurrentMode: NvU32,
        isYCbCr444SupportedOnCurrentMode: NvU32,
        isYCbCr422SupportedOnCurrentMode: NvU32,
        isYCbCr420SupportedOnCurrentMode: NvU32,
        is6BPCSupportedOnCurrentMode: NvU32,
        is8BPCSupportedOnCurrentMode: NvU32,
        is10BPCSupportedOnCurrentMode: NvU32,
        is12BPCSupportedOnCurrentMode: NvU32,
        is16BPCSupportedOnCurrentMode: NvU32,
        isMonxvYCC601Capable: NvU32,
        isMonxvYCC709Capable: NvU32,
        isMonsYCC601Capable: NvU32,
        isMonAdobeYCC601Capable: NvU32,
        isMonAdobeRGBCapable: NvU32,
        isMonBT2020RGBCapable: NvU32,
        isMonBT2020YCCCapable: NvU32,
        isMonBT2020cYCCCapable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isDp: u32 = unsafe { ::std::mem::transmute(isDp) };
            isDp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isInternalDp: u32 = unsafe { ::std::mem::transmute(isInternalDp) };
            isInternalDp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isColorCtrlSupported: u32 = unsafe { ::std::mem::transmute(isColorCtrlSupported) };
            isColorCtrlSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is6BPCSupported: u32 = unsafe { ::std::mem::transmute(is6BPCSupported) };
            is6BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is8BPCSupported: u32 = unsafe { ::std::mem::transmute(is8BPCSupported) };
            is8BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is10BPCSupported: u32 = unsafe { ::std::mem::transmute(is10BPCSupported) };
            is10BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is12BPCSupported: u32 = unsafe { ::std::mem::transmute(is12BPCSupported) };
            is12BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is16BPCSupported: u32 = unsafe { ::std::mem::transmute(is16BPCSupported) };
            is16BPCSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let isYCrCb420Supported: u32 = unsafe { ::std::mem::transmute(isYCrCb420Supported) };
            isYCrCb420Supported as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let isYCrCb422Supported: u32 = unsafe { ::std::mem::transmute(isYCrCb422Supported) };
            isYCrCb422Supported as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let isYCrCb444Supported: u32 = unsafe { ::std::mem::transmute(isYCrCb444Supported) };
            isYCrCb444Supported as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let isRgb444SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isRgb444SupportedOnCurrentMode) };
            isRgb444SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let isYCbCr444SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isYCbCr444SupportedOnCurrentMode) };
            isYCbCr444SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let isYCbCr422SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isYCbCr422SupportedOnCurrentMode) };
            isYCbCr422SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let isYCbCr420SupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(isYCbCr420SupportedOnCurrentMode) };
            isYCbCr420SupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let is6BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is6BPCSupportedOnCurrentMode) };
            is6BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is8BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is8BPCSupportedOnCurrentMode) };
            is8BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let is10BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is10BPCSupportedOnCurrentMode) };
            is10BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let is12BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is12BPCSupportedOnCurrentMode) };
            is12BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let is16BPCSupportedOnCurrentMode: u32 =
                unsafe { ::std::mem::transmute(is16BPCSupportedOnCurrentMode) };
            is16BPCSupportedOnCurrentMode as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let isMonxvYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC601Capable) };
            isMonxvYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let isMonxvYCC709Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC709Capable) };
            isMonxvYCC709Capable as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let isMonsYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonsYCC601Capable) };
            isMonsYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let isMonAdobeYCC601Capable: u32 =
                unsafe { ::std::mem::transmute(isMonAdobeYCC601Capable) };
            isMonAdobeYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let isMonAdobeRGBCapable: u32 = unsafe { ::std::mem::transmute(isMonAdobeRGBCapable) };
            isMonAdobeRGBCapable as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let isMonBT2020RGBCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBT2020RGBCapable) };
            isMonBT2020RGBCapable as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let isMonBT2020YCCCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBT2020YCCCapable) };
            isMonBT2020YCCCapable as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let isMonBT2020cYCCCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBT2020cYCCCapable) };
            isMonBT2020cYCCCapable as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_DISPLAY_PORT_INFO_V1 = _NV_DISPLAY_PORT_INFO_V1;
pub type NV_DISPLAY_PORT_INFO = NV_DISPLAY_PORT_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_DISPLAY_PORT_CONFIG {
    pub version: NvU32,
    pub linkRate: NV_DP_LINK_RATE,
    pub laneCount: NV_DP_LANE_COUNT,
    pub colorFormat: NV_DP_COLOR_FORMAT,
    pub dynamicRange: NV_DP_DYNAMIC_RANGE,
    pub colorimetry: NV_DP_COLORIMETRY,
    pub bpc: NV_DP_BPC,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl NV_DISPLAY_PORT_CONFIG {
    #[inline]
    pub fn isHPD(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isHPD(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isSetDeferred(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSetDeferred(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isChromaLpfOff(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isChromaLpfOff(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isDitherOff(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDitherOff(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn testLinkTrain(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_testLinkTrain(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn testColorChange(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_testColorChange(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isHPD: NvU32,
        isSetDeferred: NvU32,
        isChromaLpfOff: NvU32,
        isDitherOff: NvU32,
        testLinkTrain: NvU32,
        testColorChange: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isHPD: u32 = unsafe { ::std::mem::transmute(isHPD) };
            isHPD as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isSetDeferred: u32 = unsafe { ::std::mem::transmute(isSetDeferred) };
            isSetDeferred as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isChromaLpfOff: u32 = unsafe { ::std::mem::transmute(isChromaLpfOff) };
            isChromaLpfOff as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isDitherOff: u32 = unsafe { ::std::mem::transmute(isDitherOff) };
            isDitherOff as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let testLinkTrain: u32 = unsafe { ::std::mem::transmute(testLinkTrain) };
            testLinkTrain as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let testColorChange: u32 = unsafe { ::std::mem::transmute(testColorChange) };
            testColorChange as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDMI_SUPPORT_INFO_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub EDID861ExtRev: NvU32,
}
impl _NV_HDMI_SUPPORT_INFO_V1 {
    #[inline]
    pub fn isGpuHDMICapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isGpuHDMICapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonUnderscanCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonUnderscanCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBasicAudioCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBasicAudioCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr444Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr444Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr422Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr422Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC709Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC709Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonHDMI(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonHDMI(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isGpuHDMICapable: NvU32,
        isMonUnderscanCapable: NvU32,
        isMonBasicAudioCapable: NvU32,
        isMonYCbCr444Capable: NvU32,
        isMonYCbCr422Capable: NvU32,
        isMonxvYCC601Capable: NvU32,
        isMonxvYCC709Capable: NvU32,
        isMonHDMI: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isGpuHDMICapable: u32 = unsafe { ::std::mem::transmute(isGpuHDMICapable) };
            isGpuHDMICapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMonUnderscanCapable: u32 =
                unsafe { ::std::mem::transmute(isMonUnderscanCapable) };
            isMonUnderscanCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isMonBasicAudioCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBasicAudioCapable) };
            isMonBasicAudioCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isMonYCbCr444Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr444Capable) };
            isMonYCbCr444Capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isMonYCbCr422Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr422Capable) };
            isMonYCbCr422Capable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isMonxvYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC601Capable) };
            isMonxvYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isMonxvYCC709Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC709Capable) };
            isMonxvYCC709Capable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isMonHDMI: u32 = unsafe { ::std::mem::transmute(isMonHDMI) };
            isMonHDMI as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDMI_SUPPORT_INFO_V1 = _NV_HDMI_SUPPORT_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDMI_SUPPORT_INFO_V2 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub EDID861ExtRev: NvU32,
}
impl _NV_HDMI_SUPPORT_INFO_V2 {
    #[inline]
    pub fn isGpuHDMICapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isGpuHDMICapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonUnderscanCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonUnderscanCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonBasicAudioCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonBasicAudioCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr444Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr444Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonYCbCr422Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonYCbCr422Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonxvYCC709Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonxvYCC709Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonHDMI(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonHDMI(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonsYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonsYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeYCC601Capable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeYCC601Capable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMonAdobeRGBCapable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMonAdobeRGBCapable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isGpuHDMICapable: NvU32,
        isMonUnderscanCapable: NvU32,
        isMonBasicAudioCapable: NvU32,
        isMonYCbCr444Capable: NvU32,
        isMonYCbCr422Capable: NvU32,
        isMonxvYCC601Capable: NvU32,
        isMonxvYCC709Capable: NvU32,
        isMonHDMI: NvU32,
        isMonsYCC601Capable: NvU32,
        isMonAdobeYCC601Capable: NvU32,
        isMonAdobeRGBCapable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isGpuHDMICapable: u32 = unsafe { ::std::mem::transmute(isGpuHDMICapable) };
            isGpuHDMICapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMonUnderscanCapable: u32 =
                unsafe { ::std::mem::transmute(isMonUnderscanCapable) };
            isMonUnderscanCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isMonBasicAudioCapable: u32 =
                unsafe { ::std::mem::transmute(isMonBasicAudioCapable) };
            isMonBasicAudioCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isMonYCbCr444Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr444Capable) };
            isMonYCbCr444Capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isMonYCbCr422Capable: u32 = unsafe { ::std::mem::transmute(isMonYCbCr422Capable) };
            isMonYCbCr422Capable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isMonxvYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC601Capable) };
            isMonxvYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isMonxvYCC709Capable: u32 = unsafe { ::std::mem::transmute(isMonxvYCC709Capable) };
            isMonxvYCC709Capable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isMonHDMI: u32 = unsafe { ::std::mem::transmute(isMonHDMI) };
            isMonHDMI as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let isMonsYCC601Capable: u32 = unsafe { ::std::mem::transmute(isMonsYCC601Capable) };
            isMonsYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let isMonAdobeYCC601Capable: u32 =
                unsafe { ::std::mem::transmute(isMonAdobeYCC601Capable) };
            isMonAdobeYCC601Capable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let isMonAdobeRGBCapable: u32 = unsafe { ::std::mem::transmute(isMonAdobeRGBCapable) };
            isMonAdobeRGBCapable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDMI_SUPPORT_INFO_V2 = _NV_HDMI_SUPPORT_INFO_V2;
pub type NV_HDMI_SUPPORT_INFO = NV_HDMI_SUPPORT_INFO_V2;
impl NV_INFOFRAME_CMD {
    pub const NV_INFOFRAME_CMD_GET_DEFAULT: NV_INFOFRAME_CMD = NV_INFOFRAME_CMD(0);
}
impl NV_INFOFRAME_CMD {
    pub const NV_INFOFRAME_CMD_RESET: NV_INFOFRAME_CMD = NV_INFOFRAME_CMD(1);
}
impl NV_INFOFRAME_CMD {
    pub const NV_INFOFRAME_CMD_GET: NV_INFOFRAME_CMD = NV_INFOFRAME_CMD(2);
}
impl NV_INFOFRAME_CMD {
    pub const NV_INFOFRAME_CMD_SET: NV_INFOFRAME_CMD = NV_INFOFRAME_CMD(3);
}
impl NV_INFOFRAME_CMD {
    pub const NV_INFOFRAME_CMD_GET_OVERRIDE: NV_INFOFRAME_CMD = NV_INFOFRAME_CMD(4);
}
impl NV_INFOFRAME_CMD {
    pub const NV_INFOFRAME_CMD_SET_OVERRIDE: NV_INFOFRAME_CMD = NV_INFOFRAME_CMD(5);
}
impl NV_INFOFRAME_CMD {
    pub const NV_INFOFRAME_CMD_GET_PROPERTY: NV_INFOFRAME_CMD = NV_INFOFRAME_CMD(6);
}
impl NV_INFOFRAME_CMD {
    pub const NV_INFOFRAME_CMD_SET_PROPERTY: NV_INFOFRAME_CMD = NV_INFOFRAME_CMD(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_CMD(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_PROPERTY_MODE {
    pub const NV_INFOFRAME_PROPERTY_MODE_AUTO: NV_INFOFRAME_PROPERTY_MODE =
        NV_INFOFRAME_PROPERTY_MODE(0);
}
impl NV_INFOFRAME_PROPERTY_MODE {
    pub const NV_INFOFRAME_PROPERTY_MODE_ENABLE: NV_INFOFRAME_PROPERTY_MODE =
        NV_INFOFRAME_PROPERTY_MODE(1);
}
impl NV_INFOFRAME_PROPERTY_MODE {
    pub const NV_INFOFRAME_PROPERTY_MODE_DISABLE: NV_INFOFRAME_PROPERTY_MODE =
        NV_INFOFRAME_PROPERTY_MODE(2);
}
impl NV_INFOFRAME_PROPERTY_MODE {
    pub const NV_INFOFRAME_PROPERTY_MODE_ALLOW_OVERRIDE: NV_INFOFRAME_PROPERTY_MODE =
        NV_INFOFRAME_PROPERTY_MODE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_PROPERTY_MODE(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_PROPERTY_BLACKLIST {
    pub const NV_INFOFRAME_PROPERTY_BLACKLIST_FALSE: NV_INFOFRAME_PROPERTY_BLACKLIST =
        NV_INFOFRAME_PROPERTY_BLACKLIST(0);
}
impl NV_INFOFRAME_PROPERTY_BLACKLIST {
    pub const NV_INFOFRAME_PROPERTY_BLACKLIST_TRUE: NV_INFOFRAME_PROPERTY_BLACKLIST =
        NV_INFOFRAME_PROPERTY_BLACKLIST(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_PROPERTY_BLACKLIST(pub ::std::os::raw::c_int);
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct NV_INFOFRAME_PROPERTY {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl NV_INFOFRAME_PROPERTY {
    #[inline]
    pub fn mode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn blackList(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_blackList(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mode: NvU32,
        blackList: NvU32,
        reserved: NvU32,
        version: NvU32,
        length: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mode: u32 = unsafe { ::std::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let blackList: u32 = unsafe { ::std::mem::transmute(blackList) };
            blackList as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit
    }
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NODATA: NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO =
        NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_OVERSCAN:
        NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_UNDERSCAN:
        NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO = NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_FUTURE: NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO =
        NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_AUTO: NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO =
        NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NOT_PRESENT:
        NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_VERTICAL_PRESENT:
        NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_HORIZONTAL_PRESENT:
        NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_BOTH_PRESENT:
        NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA = NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_AUTO: NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA =
        NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_AFI_ABSENT:
        NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO =
        NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_AFI_PRESENT:
        NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO =
        NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_AFI_AUTO: NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO =
        NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_RGB:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr422:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr444:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_FUTURE:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT = NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_F17 {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_F17_FALSE: NV_INFOFRAME_FIELD_VALUE_AVI_F17 =
        NV_INFOFRAME_FIELD_VALUE_AVI_F17(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_F17 {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_F17_TRUE: NV_INFOFRAME_FIELD_VALUE_AVI_F17 =
        NV_INFOFRAME_FIELD_VALUE_AVI_F17(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_F17 {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_F17_AUTO: NV_INFOFRAME_FIELD_VALUE_AVI_F17 =
        NV_INFOFRAME_FIELD_VALUE_AVI_F17(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_F17(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NO_AFD:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE01:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE02:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE03:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_LETTERBOX_GT16x9:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(4);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE05:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(5);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE06:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(6);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE07:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(7);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_EQUAL_CODEDFRAME:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(8);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_4x3:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(9);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_16x9:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(10);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_14x9:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(11);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE12:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(12);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_4x3_ON_14x9:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(13);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_14x9:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(14);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_4x3:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(15);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(31);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NO_DATA:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_4x3:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_16x9:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_FUTURE:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME =
        NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NO_DATA:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_SMPTE_170M:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_ITUR_BT709:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_USE_EXTENDED_COLORIMETRY:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY = NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NO_DATA:
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING =
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_HORIZONTAL:
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING =
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_VERTICAL:
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING =
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_BOTH:
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING =
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING =
        NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_DEFAULT:
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_LIMITED_RANGE:
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_FULL_RANGE:
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_RESERVED:
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC601:
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY =
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC709:
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY =
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_SYCC601:
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY =
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBEYCC601:
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY =
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBERGB:
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY =
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(4);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED05:
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY =
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(5);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED06:
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY =
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(6);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED07:
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY =
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(7);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY =
        NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(15);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_ITC {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ITC_VIDEO_CONTENT: NV_INFOFRAME_FIELD_VALUE_AVI_ITC =
        NV_INFOFRAME_FIELD_VALUE_AVI_ITC(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ITC {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ITC_ITCONTENT: NV_INFOFRAME_FIELD_VALUE_AVI_ITC =
        NV_INFOFRAME_FIELD_VALUE_AVI_ITC(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_ITC {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_ITC_AUTO: NV_INFOFRAME_FIELD_VALUE_AVI_ITC =
        NV_INFOFRAME_FIELD_VALUE_AVI_ITC(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_ITC(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NONE:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X02:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X03:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X04:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X05:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(4);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X06:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(5);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X07:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(6);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X08:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(7);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X09:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(8);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X10:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(9);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED10:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(10);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED11:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(11);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED12:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(12);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED13:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(13);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED14:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(14);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED15:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(15);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION =
        NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(31);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GRAPHICS:
        NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_PHOTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_CINEMA:
        NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GAME:
        NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE = NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_LIMITED_RANGE:
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_FULL_RANGE:
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED02:
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED03:
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION =
        NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION(pub ::std::os::raw::c_int);
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct NV_INFOFRAME_VIDEO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 23usize]>,
}
impl NV_INFOFRAME_VIDEO {
    #[inline]
    pub fn vic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelRepeat(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_pixelRepeat(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn colorSpace(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_colorSpace(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn colorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_colorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn extendedColorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_extendedColorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rgbQuantizationRange(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rgbQuantizationRange(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn yccQuantizationRange(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_yccQuantizationRange(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn itContent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_itContent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn contentTypes(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_contentTypes(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfo(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_scanInfo(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn activeFormatInfoPresent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_activeFormatInfoPresent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn activeFormatAspectRatio(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_activeFormatAspectRatio(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn picAspectRatio(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_picAspectRatio(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn nonuniformScaling(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_nonuniformScaling(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn barInfo(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_barInfo(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn top_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_top_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn bottom_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_bottom_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn left_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(128usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_left_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(128usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn right_bar(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(160usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_right_bar(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(160usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn Future17(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(177usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future17(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(177usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Future47(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(179usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future47(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(179usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vic: NvU32,
        pixelRepeat: NvU32,
        colorSpace: NvU32,
        colorimetry: NvU32,
        extendedColorimetry: NvU32,
        rgbQuantizationRange: NvU32,
        yccQuantizationRange: NvU32,
        itContent: NvU32,
        contentTypes: NvU32,
        scanInfo: NvU32,
        activeFormatInfoPresent: NvU32,
        activeFormatAspectRatio: NvU32,
        picAspectRatio: NvU32,
        nonuniformScaling: NvU32,
        barInfo: NvU32,
        top_bar: NvU32,
        bottom_bar: NvU32,
        left_bar: NvU32,
        right_bar: NvU32,
        Future17: NvU32,
        Future47: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 23usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 23usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vic: u32 = unsafe { ::std::mem::transmute(vic) };
            vic as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let pixelRepeat: u32 = unsafe { ::std::mem::transmute(pixelRepeat) };
            pixelRepeat as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let colorSpace: u32 = unsafe { ::std::mem::transmute(colorSpace) };
            colorSpace as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let colorimetry: u32 = unsafe { ::std::mem::transmute(colorimetry) };
            colorimetry as u64
        });
        __bindgen_bitfield_unit.set(19usize, 4u8, {
            let extendedColorimetry: u32 = unsafe { ::std::mem::transmute(extendedColorimetry) };
            extendedColorimetry as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let rgbQuantizationRange: u32 = unsafe { ::std::mem::transmute(rgbQuantizationRange) };
            rgbQuantizationRange as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let yccQuantizationRange: u32 = unsafe { ::std::mem::transmute(yccQuantizationRange) };
            yccQuantizationRange as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let itContent: u32 = unsafe { ::std::mem::transmute(itContent) };
            itContent as u64
        });
        __bindgen_bitfield_unit.set(32usize, 3u8, {
            let contentTypes: u32 = unsafe { ::std::mem::transmute(contentTypes) };
            contentTypes as u64
        });
        __bindgen_bitfield_unit.set(35usize, 3u8, {
            let scanInfo: u32 = unsafe { ::std::mem::transmute(scanInfo) };
            scanInfo as u64
        });
        __bindgen_bitfield_unit.set(38usize, 2u8, {
            let activeFormatInfoPresent: u32 =
                unsafe { ::std::mem::transmute(activeFormatInfoPresent) };
            activeFormatInfoPresent as u64
        });
        __bindgen_bitfield_unit.set(40usize, 5u8, {
            let activeFormatAspectRatio: u32 =
                unsafe { ::std::mem::transmute(activeFormatAspectRatio) };
            activeFormatAspectRatio as u64
        });
        __bindgen_bitfield_unit.set(45usize, 3u8, {
            let picAspectRatio: u32 = unsafe { ::std::mem::transmute(picAspectRatio) };
            picAspectRatio as u64
        });
        __bindgen_bitfield_unit.set(48usize, 3u8, {
            let nonuniformScaling: u32 = unsafe { ::std::mem::transmute(nonuniformScaling) };
            nonuniformScaling as u64
        });
        __bindgen_bitfield_unit.set(51usize, 3u8, {
            let barInfo: u32 = unsafe { ::std::mem::transmute(barInfo) };
            barInfo as u64
        });
        __bindgen_bitfield_unit.set(64usize, 17u8, {
            let top_bar: u32 = unsafe { ::std::mem::transmute(top_bar) };
            top_bar as u64
        });
        __bindgen_bitfield_unit.set(96usize, 17u8, {
            let bottom_bar: u32 = unsafe { ::std::mem::transmute(bottom_bar) };
            bottom_bar as u64
        });
        __bindgen_bitfield_unit.set(128usize, 17u8, {
            let left_bar: u32 = unsafe { ::std::mem::transmute(left_bar) };
            left_bar as u64
        });
        __bindgen_bitfield_unit.set(160usize, 17u8, {
            let right_bar: u32 = unsafe { ::std::mem::transmute(right_bar) };
            right_bar as u64
        });
        __bindgen_bitfield_unit.set(177usize, 2u8, {
            let Future17: u32 = unsafe { ::std::mem::transmute(Future17) };
            Future17 as u64
        });
        __bindgen_bitfield_unit.set(179usize, 2u8, {
            let Future47: u32 = unsafe { ::std::mem::transmute(Future47) };
            Future47 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_IN_HEADER:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_2:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_3:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_4:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_5:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(4);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_6:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(5);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_7:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(6);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_8:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(7);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(15);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_IN_HEADER:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_PCM:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AC3:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG1:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MP3:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(4);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG2:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(5);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AACLC:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(6);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTS:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(7);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_ATRAC:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(8);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DSD:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(9);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_EAC3:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(10);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTSHD:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(11);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MLP:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(12);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DST:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(13);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_WMAPRO:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(14);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_USE_CODING_EXTENSION_TYPE:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(15);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE = NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(31);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_IN_HEADER:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_16BITS:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_20BITS:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_24BITS:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE = NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_IN_HEADER:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_32000HZ:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_44100HZ:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_48000HZ:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_88200KHZ:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(4);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_96000KHZ:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(5);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_176400KHZ:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(6);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_192000KHZ:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(7);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(15);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_USE_CODING_TYPE:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAAC:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAACV2:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_MPEGSURROUND:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE04:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(4);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE05:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(5);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE06:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(6);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE07:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(7);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE08:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(8);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE09:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(9);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE10:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(10);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE11:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(11);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE12:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(12);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE13:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(13);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE14:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(14);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE15:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(15);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE16:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(16);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE17:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(17);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE18:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(18);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE19:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(19);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE20:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(20);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE21:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(21);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE22:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(22);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE23:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(23);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE24:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(24);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE25:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(25);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE26:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(26);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE27:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(27);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE28:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(28);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE29:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(29);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE30:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(30);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE31:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(31);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(63);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(4);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(5);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(6);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(7);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(8);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(9);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(10);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(11);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(12);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(13);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(14);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(15);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(16);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(17);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(18);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(19);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(20);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(21);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(22);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(23);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(24);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(25);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(26);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(27);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(28);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(29);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(30);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(31);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(32);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(33);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(34);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(35);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(36);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(37);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(38);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(39);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(40);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(41);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(42);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(43);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(44);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(45);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(46);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(47);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_X_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(48);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_LFE_FR_FL:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(49);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(511);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NO_DATA:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_0DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_PLUS10DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_RESERVED03:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_0DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_1DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_2DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(2);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_3DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(3);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_4DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(4);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_5DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(5);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_6DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(6);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_7DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(7);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_8DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(8);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_9DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(9);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_10DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(10);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_11DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(11);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_12DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(12);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_13DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(13);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_14DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(14);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_15DB:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(15);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_AUTO:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(31);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES(pub ::std::os::raw::c_int);
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PERMITTED:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX(0);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PROHIBITED:
        NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX = NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX(1);
}
impl NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX {
    pub const NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_AUTO: NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX =
        NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX(pub ::std::os::raw::c_int);
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct NV_INFOFRAME_AUDIO {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 14usize]>,
    pub __bindgen_padding_0: u16,
}
impl NV_INFOFRAME_AUDIO {
    #[inline]
    pub fn codingType(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_codingType(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn codingExtensionType(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_codingExtensionType(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn sampleSize(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sampleSize(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sampleRate(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sampleRate(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn channelCount(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channelCount(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn speakerPlacement(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_speakerPlacement(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn downmixInhibit(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_downmixInhibit(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lfePlaybackLevel(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_lfePlaybackLevel(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn levelShift(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_levelShift(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Future12(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future12(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Future2x(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Future2x(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Future3x(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Future3x(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Future52(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Future52(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Future6(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future6(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future7(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future7(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future8(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(73usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future8(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(73usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future9(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future9(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn Future10(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Future10(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        codingType: NvU32,
        codingExtensionType: NvU32,
        sampleSize: NvU32,
        sampleRate: NvU32,
        channelCount: NvU32,
        speakerPlacement: NvU32,
        downmixInhibit: NvU32,
        lfePlaybackLevel: NvU32,
        levelShift: NvU32,
        Future12: NvU32,
        Future2x: NvU32,
        Future3x: NvU32,
        Future52: NvU32,
        Future6: NvU32,
        Future7: NvU32,
        Future8: NvU32,
        Future9: NvU32,
        Future10: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 14usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 14usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let codingType: u32 = unsafe { ::std::mem::transmute(codingType) };
            codingType as u64
        });
        __bindgen_bitfield_unit.set(5usize, 6u8, {
            let codingExtensionType: u32 = unsafe { ::std::mem::transmute(codingExtensionType) };
            codingExtensionType as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let sampleSize: u32 = unsafe { ::std::mem::transmute(sampleSize) };
            sampleSize as u64
        });
        __bindgen_bitfield_unit.set(14usize, 4u8, {
            let sampleRate: u32 = unsafe { ::std::mem::transmute(sampleRate) };
            sampleRate as u64
        });
        __bindgen_bitfield_unit.set(18usize, 4u8, {
            let channelCount: u32 = unsafe { ::std::mem::transmute(channelCount) };
            channelCount as u64
        });
        __bindgen_bitfield_unit.set(22usize, 9u8, {
            let speakerPlacement: u32 = unsafe { ::std::mem::transmute(speakerPlacement) };
            speakerPlacement as u64
        });
        __bindgen_bitfield_unit.set(32usize, 2u8, {
            let downmixInhibit: u32 = unsafe { ::std::mem::transmute(downmixInhibit) };
            downmixInhibit as u64
        });
        __bindgen_bitfield_unit.set(34usize, 3u8, {
            let lfePlaybackLevel: u32 = unsafe { ::std::mem::transmute(lfePlaybackLevel) };
            lfePlaybackLevel as u64
        });
        __bindgen_bitfield_unit.set(37usize, 5u8, {
            let levelShift: u32 = unsafe { ::std::mem::transmute(levelShift) };
            levelShift as u64
        });
        __bindgen_bitfield_unit.set(42usize, 2u8, {
            let Future12: u32 = unsafe { ::std::mem::transmute(Future12) };
            Future12 as u64
        });
        __bindgen_bitfield_unit.set(44usize, 4u8, {
            let Future2x: u32 = unsafe { ::std::mem::transmute(Future2x) };
            Future2x as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let Future3x: u32 = unsafe { ::std::mem::transmute(Future3x) };
            Future3x as u64
        });
        __bindgen_bitfield_unit.set(52usize, 2u8, {
            let Future52: u32 = unsafe { ::std::mem::transmute(Future52) };
            Future52 as u64
        });
        __bindgen_bitfield_unit.set(54usize, 9u8, {
            let Future6: u32 = unsafe { ::std::mem::transmute(Future6) };
            Future6 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 9u8, {
            let Future7: u32 = unsafe { ::std::mem::transmute(Future7) };
            Future7 as u64
        });
        __bindgen_bitfield_unit.set(73usize, 9u8, {
            let Future8: u32 = unsafe { ::std::mem::transmute(Future8) };
            Future8 as u64
        });
        __bindgen_bitfield_unit.set(82usize, 9u8, {
            let Future9: u32 = unsafe { ::std::mem::transmute(Future9) };
            Future9 as u64
        });
        __bindgen_bitfield_unit.set(96usize, 9u8, {
            let Future10: u32 = unsafe { ::std::mem::transmute(Future10) };
            Future10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_INFOFRAME_DATA {
    pub version: NvU32,
    pub size: NvU16,
    pub cmd: NvU8,
    pub type_: NvU8,
    pub infoframe: NV_INFOFRAME_DATA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NV_INFOFRAME_DATA__bindgen_ty_1 {
    pub property: NV_INFOFRAME_PROPERTY,
    pub audio: NV_INFOFRAME_AUDIO,
    pub video: NV_INFOFRAME_VIDEO,
}
impl NV_COLOR_CMD {
    pub const NV_COLOR_CMD_GET: NV_COLOR_CMD = NV_COLOR_CMD(1);
}
impl NV_COLOR_CMD {
    pub const NV_COLOR_CMD_SET: NV_COLOR_CMD = NV_COLOR_CMD(2);
}
impl NV_COLOR_CMD {
    pub const NV_COLOR_CMD_IS_SUPPORTED_COLOR: NV_COLOR_CMD = NV_COLOR_CMD(3);
}
impl NV_COLOR_CMD {
    pub const NV_COLOR_CMD_GET_DEFAULT: NV_COLOR_CMD = NV_COLOR_CMD(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_COLOR_CMD(pub ::std::os::raw::c_int);
impl NV_COLOR_FORMAT {
    pub const NV_COLOR_FORMAT_RGB: NV_COLOR_FORMAT = NV_COLOR_FORMAT(0);
}
impl NV_COLOR_FORMAT {
    pub const NV_COLOR_FORMAT_YUV422: NV_COLOR_FORMAT = NV_COLOR_FORMAT(1);
}
impl NV_COLOR_FORMAT {
    pub const NV_COLOR_FORMAT_YUV444: NV_COLOR_FORMAT = NV_COLOR_FORMAT(2);
}
impl NV_COLOR_FORMAT {
    pub const NV_COLOR_FORMAT_YUV420: NV_COLOR_FORMAT = NV_COLOR_FORMAT(3);
}
impl NV_COLOR_FORMAT {
    pub const NV_COLOR_FORMAT_DEFAULT: NV_COLOR_FORMAT = NV_COLOR_FORMAT(254);
}
impl NV_COLOR_FORMAT {
    pub const NV_COLOR_FORMAT_AUTO: NV_COLOR_FORMAT = NV_COLOR_FORMAT(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_COLOR_FORMAT(pub ::std::os::raw::c_int);
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_RGB: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(0);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_YCC601: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(1);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_YCC709: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(2);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_XVYCC601: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(3);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_XVYCC709: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(4);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_SYCC601: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(5);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_ADOBEYCC601: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(6);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_ADOBERGB: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(7);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_BT2020RGB: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(8);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_BT2020YCC: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(9);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_BT2020cYCC: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(10);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_DEFAULT: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(254);
}
impl NV_COLOR_COLORIMETRY {
    pub const NV_COLOR_COLORIMETRY_AUTO: NV_COLOR_COLORIMETRY = NV_COLOR_COLORIMETRY(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_COLOR_COLORIMETRY(pub ::std::os::raw::c_int);
impl _NV_DYNAMIC_RANGE {
    pub const NV_DYNAMIC_RANGE_VESA: _NV_DYNAMIC_RANGE = _NV_DYNAMIC_RANGE(0);
}
impl _NV_DYNAMIC_RANGE {
    pub const NV_DYNAMIC_RANGE_CEA: _NV_DYNAMIC_RANGE = _NV_DYNAMIC_RANGE(1);
}
impl _NV_DYNAMIC_RANGE {
    pub const NV_DYNAMIC_RANGE_AUTO: _NV_DYNAMIC_RANGE = _NV_DYNAMIC_RANGE(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DYNAMIC_RANGE(pub ::std::os::raw::c_int);
pub use self::_NV_DYNAMIC_RANGE as NV_DYNAMIC_RANGE;
impl _NV_BPC {
    pub const NV_BPC_DEFAULT: _NV_BPC = _NV_BPC(0);
}
impl _NV_BPC {
    pub const NV_BPC_6: _NV_BPC = _NV_BPC(1);
}
impl _NV_BPC {
    pub const NV_BPC_8: _NV_BPC = _NV_BPC(2);
}
impl _NV_BPC {
    pub const NV_BPC_10: _NV_BPC = _NV_BPC(3);
}
impl _NV_BPC {
    pub const NV_BPC_12: _NV_BPC = _NV_BPC(4);
}
impl _NV_BPC {
    pub const NV_BPC_16: _NV_BPC = _NV_BPC(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_BPC(pub ::std::os::raw::c_int);
pub use self::_NV_BPC as NV_BPC;
impl _NV_COLOR_SELECTION_POLICY {
    pub const NV_COLOR_SELECTION_POLICY_USER: _NV_COLOR_SELECTION_POLICY =
        _NV_COLOR_SELECTION_POLICY(0);
}
impl _NV_COLOR_SELECTION_POLICY {
    pub const NV_COLOR_SELECTION_POLICY_BEST_QUALITY: _NV_COLOR_SELECTION_POLICY =
        _NV_COLOR_SELECTION_POLICY(1);
}
impl _NV_COLOR_SELECTION_POLICY {
    pub const NV_COLOR_SELECTION_POLICY_DEFAULT: _NV_COLOR_SELECTION_POLICY =
        _NV_COLOR_SELECTION_POLICY(1);
}
impl _NV_COLOR_SELECTION_POLICY {
    pub const NV_COLOR_SELECTION_POLICY_UNKNOWN: _NV_COLOR_SELECTION_POLICY =
        _NV_COLOR_SELECTION_POLICY(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_COLOR_SELECTION_POLICY(pub ::std::os::raw::c_int);
pub use self::_NV_COLOR_SELECTION_POLICY as NV_COLOR_SELECTION_POLICY;
impl _NV_DESKTOP_COLOR_DEPTH {
    pub const NV_DESKTOP_COLOR_DEPTH_DEFAULT: _NV_DESKTOP_COLOR_DEPTH = _NV_DESKTOP_COLOR_DEPTH(0);
}
impl _NV_DESKTOP_COLOR_DEPTH {
    pub const NV_DESKTOP_COLOR_DEPTH_8BPC: _NV_DESKTOP_COLOR_DEPTH = _NV_DESKTOP_COLOR_DEPTH(1);
}
impl _NV_DESKTOP_COLOR_DEPTH {
    pub const NV_DESKTOP_COLOR_DEPTH_10BPC: _NV_DESKTOP_COLOR_DEPTH = _NV_DESKTOP_COLOR_DEPTH(2);
}
impl _NV_DESKTOP_COLOR_DEPTH {
    pub const NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT: _NV_DESKTOP_COLOR_DEPTH =
        _NV_DESKTOP_COLOR_DEPTH(3);
}
impl _NV_DESKTOP_COLOR_DEPTH {
    pub const NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT_WCG: _NV_DESKTOP_COLOR_DEPTH =
        _NV_DESKTOP_COLOR_DEPTH(4);
}
impl _NV_DESKTOP_COLOR_DEPTH {
    pub const NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT_HDR: _NV_DESKTOP_COLOR_DEPTH =
        _NV_DESKTOP_COLOR_DEPTH(5);
}
impl _NV_DESKTOP_COLOR_DEPTH {
    pub const NV_DESKTOP_COLOR_DEPTH_MAX_VALUE: _NV_DESKTOP_COLOR_DEPTH =
        _NV_DESKTOP_COLOR_DEPTH(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DESKTOP_COLOR_DEPTH(pub ::std::os::raw::c_int);
pub use self::_NV_DESKTOP_COLOR_DEPTH as NV_DESKTOP_COLOR_DEPTH;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V1 {
    pub version: NvU32,
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V1__bindgen_ty_1 {
    pub colorFormat: NvU8,
    pub colorimetry: NvU8,
}
pub type NV_COLOR_DATA_V1 = _NV_COLOR_DATA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V2 {
    pub version: NvU32,
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V2__bindgen_ty_1 {
    pub colorFormat: NvU8,
    pub colorimetry: NvU8,
    pub dynamicRange: NvU8,
}
pub type NV_COLOR_DATA_V2 = _NV_COLOR_DATA_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V3 {
    pub version: NvU32,
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V3__bindgen_ty_1 {
    pub colorFormat: NvU8,
    pub colorimetry: NvU8,
    pub dynamicRange: NvU8,
    pub bpc: NV_BPC,
}
pub type NV_COLOR_DATA_V3 = _NV_COLOR_DATA_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V4 {
    pub version: NvU32,
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V4__bindgen_ty_1 {
    pub colorFormat: NvU8,
    pub colorimetry: NvU8,
    pub dynamicRange: NvU8,
    pub bpc: NV_BPC,
    pub colorSelectionPolicy: NV_COLOR_SELECTION_POLICY,
}
pub type NV_COLOR_DATA_V4 = _NV_COLOR_DATA_V4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V5 {
    pub version: NvU32,
    pub size: NvU16,
    pub cmd: NvU8,
    pub data: _NV_COLOR_DATA_V5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_COLOR_DATA_V5__bindgen_ty_1 {
    pub colorFormat: NvU8,
    pub colorimetry: NvU8,
    pub dynamicRange: NvU8,
    pub bpc: NV_BPC,
    pub colorSelectionPolicy: NV_COLOR_SELECTION_POLICY,
    pub depth: NV_DESKTOP_COLOR_DEPTH,
}
pub type NV_COLOR_DATA_V5 = _NV_COLOR_DATA_V5;
pub type NV_COLOR_DATA = NV_COLOR_DATA_V5;
impl NV_STATIC_METADATA_DESCRIPTOR_ID {
    pub const NV_STATIC_METADATA_TYPE_1: NV_STATIC_METADATA_DESCRIPTOR_ID =
        NV_STATIC_METADATA_DESCRIPTOR_ID(0);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_STATIC_METADATA_DESCRIPTOR_ID(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub display_data: _NV_HDR_CAPABILITIES_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V1__bindgen_ty_1 {
    pub displayPrimary_x0: NvU16,
    pub displayPrimary_y0: NvU16,
    pub displayPrimary_x1: NvU16,
    pub displayPrimary_y1: NvU16,
    pub displayPrimary_x2: NvU16,
    pub displayPrimary_y2: NvU16,
    pub displayWhitePoint_x: NvU16,
    pub displayWhitePoint_y: NvU16,
    pub desired_content_max_luminance: NvU16,
    pub desired_content_min_luminance: NvU16,
    pub desired_content_max_frame_average_luminance: NvU16,
}
impl _NV_HDR_CAPABILITIES_V1 {
    #[inline]
    pub fn isST2084EotfSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isST2084EotfSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalHdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalHdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEdrSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEdrSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverExpandDefaultHdrParameters(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverExpandDefaultHdrParameters(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalSdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalSdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isST2084EotfSupported: NvU32,
        isTraditionalHdrGammaSupported: NvU32,
        isEdrSupported: NvU32,
        driverExpandDefaultHdrParameters: NvU32,
        isTraditionalSdrGammaSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isST2084EotfSupported: u32 =
                unsafe { ::std::mem::transmute(isST2084EotfSupported) };
            isST2084EotfSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isTraditionalHdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalHdrGammaSupported) };
            isTraditionalHdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isEdrSupported: u32 = unsafe { ::std::mem::transmute(isEdrSupported) };
            isEdrSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverExpandDefaultHdrParameters: u32 =
                unsafe { ::std::mem::transmute(driverExpandDefaultHdrParameters) };
            driverExpandDefaultHdrParameters as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isTraditionalSdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalSdrGammaSupported) };
            isTraditionalSdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDR_CAPABILITIES_V1 = _NV_HDR_CAPABILITIES_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V2 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub display_data: _NV_HDR_CAPABILITIES_V2__bindgen_ty_1,
    pub dv_static_metadata: _NV_HDR_CAPABILITIES_V2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V2__bindgen_ty_1 {
    pub displayPrimary_x0: NvU16,
    pub displayPrimary_y0: NvU16,
    pub displayPrimary_x1: NvU16,
    pub displayPrimary_y1: NvU16,
    pub displayPrimary_x2: NvU16,
    pub displayPrimary_y2: NvU16,
    pub displayWhitePoint_x: NvU16,
    pub displayWhitePoint_y: NvU16,
    pub desired_content_max_luminance: NvU16,
    pub desired_content_min_luminance: NvU16,
    pub desired_content_max_frame_average_luminance: NvU16,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V2__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub target_min_luminance: NvU16,
    pub target_max_luminance: NvU16,
    pub cc_red_x: NvU16,
    pub cc_red_y: NvU16,
    pub cc_green_x: NvU16,
    pub cc_green_y: NvU16,
    pub cc_blue_x: NvU16,
    pub cc_blue_y: NvU16,
    pub cc_white_x: NvU16,
    pub cc_white_y: NvU16,
}
impl _NV_HDR_CAPABILITIES_V2__bindgen_ty_2 {
    #[inline]
    pub fn VSVDB_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VSVDB_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dm_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dm_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_2160p60hz(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_2160p60hz(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_YUV422_12bit(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_YUV422_12bit(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_global_dimming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_global_dimming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_backlight_control(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_backlight_control(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn backlt_min_luma(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_backlt_min_luma(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn interface_supported_by_sink(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_interface_supported_by_sink(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_10b_12b_444(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_10b_12b_444(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VSVDB_version: NvU32,
        dm_version: NvU32,
        supports_2160p60hz: NvU32,
        supports_YUV422_12bit: NvU32,
        supports_global_dimming: NvU32,
        colorimetry: NvU32,
        supports_backlight_control: NvU32,
        backlt_min_luma: NvU32,
        interface_supported_by_sink: NvU32,
        supports_10b_12b_444: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let VSVDB_version: u32 = unsafe { ::std::mem::transmute(VSVDB_version) };
            VSVDB_version as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let dm_version: u32 = unsafe { ::std::mem::transmute(dm_version) };
            dm_version as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let supports_2160p60hz: u32 = unsafe { ::std::mem::transmute(supports_2160p60hz) };
            supports_2160p60hz as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let supports_YUV422_12bit: u32 =
                unsafe { ::std::mem::transmute(supports_YUV422_12bit) };
            supports_YUV422_12bit as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let supports_global_dimming: u32 =
                unsafe { ::std::mem::transmute(supports_global_dimming) };
            supports_global_dimming as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let colorimetry: u32 = unsafe { ::std::mem::transmute(colorimetry) };
            colorimetry as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let supports_backlight_control: u32 =
                unsafe { ::std::mem::transmute(supports_backlight_control) };
            supports_backlight_control as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let backlt_min_luma: u32 = unsafe { ::std::mem::transmute(backlt_min_luma) };
            backlt_min_luma as u64
        });
        __bindgen_bitfield_unit.set(19usize, 2u8, {
            let interface_supported_by_sink: u32 =
                unsafe { ::std::mem::transmute(interface_supported_by_sink) };
            interface_supported_by_sink as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let supports_10b_12b_444: u32 = unsafe { ::std::mem::transmute(supports_10b_12b_444) };
            supports_10b_12b_444 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NV_HDR_CAPABILITIES_V2 {
    #[inline]
    pub fn isST2084EotfSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isST2084EotfSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalHdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalHdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEdrSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEdrSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverExpandDefaultHdrParameters(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverExpandDefaultHdrParameters(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalSdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalSdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isDolbyVisionSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDolbyVisionSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isST2084EotfSupported: NvU32,
        isTraditionalHdrGammaSupported: NvU32,
        isEdrSupported: NvU32,
        driverExpandDefaultHdrParameters: NvU32,
        isTraditionalSdrGammaSupported: NvU32,
        isDolbyVisionSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isST2084EotfSupported: u32 =
                unsafe { ::std::mem::transmute(isST2084EotfSupported) };
            isST2084EotfSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isTraditionalHdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalHdrGammaSupported) };
            isTraditionalHdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isEdrSupported: u32 = unsafe { ::std::mem::transmute(isEdrSupported) };
            isEdrSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverExpandDefaultHdrParameters: u32 =
                unsafe { ::std::mem::transmute(driverExpandDefaultHdrParameters) };
            driverExpandDefaultHdrParameters as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isTraditionalSdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalSdrGammaSupported) };
            isTraditionalSdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isDolbyVisionSupported: u32 =
                unsafe { ::std::mem::transmute(isDolbyVisionSupported) };
            isDolbyVisionSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDR_CAPABILITIES_V2 = _NV_HDR_CAPABILITIES_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V3 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub display_data: _NV_HDR_CAPABILITIES_V3__bindgen_ty_1,
    pub dv_static_metadata: _NV_HDR_CAPABILITIES_V3__bindgen_ty_2,
    pub hdr10plus_vsvdb: _NV_HDR_CAPABILITIES_V3__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V3__bindgen_ty_1 {
    pub displayPrimary_x0: NvU16,
    pub displayPrimary_y0: NvU16,
    pub displayPrimary_x1: NvU16,
    pub displayPrimary_y1: NvU16,
    pub displayPrimary_x2: NvU16,
    pub displayPrimary_y2: NvU16,
    pub displayWhitePoint_x: NvU16,
    pub displayWhitePoint_y: NvU16,
    pub desired_content_max_luminance: NvU16,
    pub desired_content_min_luminance: NvU16,
    pub desired_content_max_frame_average_luminance: NvU16,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V3__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub target_min_luminance: NvU16,
    pub target_max_luminance: NvU16,
    pub cc_red_x: NvU16,
    pub cc_red_y: NvU16,
    pub cc_green_x: NvU16,
    pub cc_green_y: NvU16,
    pub cc_blue_x: NvU16,
    pub cc_blue_y: NvU16,
    pub cc_white_x: NvU16,
    pub cc_white_y: NvU16,
}
impl _NV_HDR_CAPABILITIES_V3__bindgen_ty_2 {
    #[inline]
    pub fn VSVDB_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VSVDB_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dm_version(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dm_version(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_2160p60hz(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_2160p60hz(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_YUV422_12bit(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_YUV422_12bit(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_global_dimming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_global_dimming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colorimetry(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colorimetry(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_backlight_control(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_backlight_control(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn backlt_min_luma(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_backlt_min_luma(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn interface_supported_by_sink(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_interface_supported_by_sink(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_10b_12b_444(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supports_10b_12b_444(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn parity(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VSVDB_version: NvU32,
        dm_version: NvU32,
        supports_2160p60hz: NvU32,
        supports_YUV422_12bit: NvU32,
        supports_global_dimming: NvU32,
        colorimetry: NvU32,
        supports_backlight_control: NvU32,
        backlt_min_luma: NvU32,
        interface_supported_by_sink: NvU32,
        supports_10b_12b_444: NvU32,
        parity: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let VSVDB_version: u32 = unsafe { ::std::mem::transmute(VSVDB_version) };
            VSVDB_version as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let dm_version: u32 = unsafe { ::std::mem::transmute(dm_version) };
            dm_version as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let supports_2160p60hz: u32 = unsafe { ::std::mem::transmute(supports_2160p60hz) };
            supports_2160p60hz as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let supports_YUV422_12bit: u32 =
                unsafe { ::std::mem::transmute(supports_YUV422_12bit) };
            supports_YUV422_12bit as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let supports_global_dimming: u32 =
                unsafe { ::std::mem::transmute(supports_global_dimming) };
            supports_global_dimming as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let colorimetry: u32 = unsafe { ::std::mem::transmute(colorimetry) };
            colorimetry as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let supports_backlight_control: u32 =
                unsafe { ::std::mem::transmute(supports_backlight_control) };
            supports_backlight_control as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let backlt_min_luma: u32 = unsafe { ::std::mem::transmute(backlt_min_luma) };
            backlt_min_luma as u64
        });
        __bindgen_bitfield_unit.set(19usize, 2u8, {
            let interface_supported_by_sink: u32 =
                unsafe { ::std::mem::transmute(interface_supported_by_sink) };
            interface_supported_by_sink as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let supports_10b_12b_444: u32 = unsafe { ::std::mem::transmute(supports_10b_12b_444) };
            supports_10b_12b_444 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let parity: u32 = unsafe { ::std::mem::transmute(parity) };
            parity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub struct _NV_HDR_CAPABILITIES_V3__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _NV_HDR_CAPABILITIES_V3__bindgen_ty_3 {
    #[inline]
    pub fn application_version(&self) -> NvU16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_application_version(&mut self, val: NvU16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn full_frame_peak_luminance_index(&self) -> NvU16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_full_frame_peak_luminance_index(&mut self, val: NvU16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn peak_luminance_index(&self) -> NvU16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_peak_luminance_index(&mut self, val: NvU16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        application_version: NvU16,
        full_frame_peak_luminance_index: NvU16,
        peak_luminance_index: NvU16,
        reserved: NvU16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let application_version: u16 = unsafe { ::std::mem::transmute(application_version) };
            application_version as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let full_frame_peak_luminance_index: u16 =
                unsafe { ::std::mem::transmute(full_frame_peak_luminance_index) };
            full_frame_peak_luminance_index as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let peak_luminance_index: u16 = unsafe { ::std::mem::transmute(peak_luminance_index) };
            peak_luminance_index as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NV_HDR_CAPABILITIES_V3 {
    #[inline]
    pub fn isST2084EotfSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isST2084EotfSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalHdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalHdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isEdrSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEdrSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverExpandDefaultHdrParameters(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverExpandDefaultHdrParameters(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTraditionalSdrGammaSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTraditionalSdrGammaSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isDolbyVisionSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isDolbyVisionSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isHdr10PlusSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isHdr10PlusSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isHdr10PlusGamingSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isHdr10PlusGamingSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isST2084EotfSupported: NvU32,
        isTraditionalHdrGammaSupported: NvU32,
        isEdrSupported: NvU32,
        driverExpandDefaultHdrParameters: NvU32,
        isTraditionalSdrGammaSupported: NvU32,
        isDolbyVisionSupported: NvU32,
        isHdr10PlusSupported: NvU32,
        isHdr10PlusGamingSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isST2084EotfSupported: u32 =
                unsafe { ::std::mem::transmute(isST2084EotfSupported) };
            isST2084EotfSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isTraditionalHdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalHdrGammaSupported) };
            isTraditionalHdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isEdrSupported: u32 = unsafe { ::std::mem::transmute(isEdrSupported) };
            isEdrSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverExpandDefaultHdrParameters: u32 =
                unsafe { ::std::mem::transmute(driverExpandDefaultHdrParameters) };
            driverExpandDefaultHdrParameters as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isTraditionalSdrGammaSupported: u32 =
                unsafe { ::std::mem::transmute(isTraditionalSdrGammaSupported) };
            isTraditionalSdrGammaSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isDolbyVisionSupported: u32 =
                unsafe { ::std::mem::transmute(isDolbyVisionSupported) };
            isDolbyVisionSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isHdr10PlusSupported: u32 = unsafe { ::std::mem::transmute(isHdr10PlusSupported) };
            isHdr10PlusSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isHdr10PlusGamingSupported: u32 =
                unsafe { ::std::mem::transmute(isHdr10PlusGamingSupported) };
            isHdr10PlusGamingSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_HDR_CAPABILITIES_V3 = _NV_HDR_CAPABILITIES_V3;
pub type NV_HDR_CAPABILITIES = NV_HDR_CAPABILITIES_V3;
impl NV_HDR_CMD {
    pub const NV_HDR_CMD_GET: NV_HDR_CMD = NV_HDR_CMD(0);
}
impl NV_HDR_CMD {
    pub const NV_HDR_CMD_SET: NV_HDR_CMD = NV_HDR_CMD(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_HDR_CMD(pub ::std::os::raw::c_int);
impl NV_HDR_MODE {
    pub const NV_HDR_MODE_OFF: NV_HDR_MODE = NV_HDR_MODE(0);
}
impl NV_HDR_MODE {
    pub const NV_HDR_MODE_UHDA: NV_HDR_MODE = NV_HDR_MODE(2);
}
impl NV_HDR_MODE {
    pub const NV_HDR_MODE_UHDA_PASSTHROUGH: NV_HDR_MODE = NV_HDR_MODE(5);
}
impl NV_HDR_MODE {
    pub const NV_HDR_MODE_DOLBY_VISION: NV_HDR_MODE = NV_HDR_MODE(7);
}
impl NV_HDR_MODE {
    pub const NV_HDR_MODE_EDR: NV_HDR_MODE = NV_HDR_MODE(3);
}
impl NV_HDR_MODE {
    pub const NV_HDR_MODE_SDR: NV_HDR_MODE = NV_HDR_MODE(4);
}
impl NV_HDR_MODE {
    pub const NV_HDR_MODE_UHDA_NB: NV_HDR_MODE = NV_HDR_MODE(6);
}
impl NV_HDR_MODE {
    pub const NV_HDR_MODE_UHDBD: NV_HDR_MODE = NV_HDR_MODE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_HDR_MODE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V1 {
    pub version: NvU32,
    pub cmd: NV_HDR_CMD,
    pub hdrMode: NV_HDR_MODE,
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub mastering_display_data: _NV_HDR_COLOR_DATA_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V1__bindgen_ty_1 {
    pub displayPrimary_x0: NvU16,
    pub displayPrimary_y0: NvU16,
    pub displayPrimary_x1: NvU16,
    pub displayPrimary_y1: NvU16,
    pub displayPrimary_x2: NvU16,
    pub displayPrimary_y2: NvU16,
    pub displayWhitePoint_x: NvU16,
    pub displayWhitePoint_y: NvU16,
    pub max_display_mastering_luminance: NvU16,
    pub min_display_mastering_luminance: NvU16,
    pub max_content_light_level: NvU16,
    pub max_frame_average_light_level: NvU16,
}
pub type NV_HDR_COLOR_DATA_V1 = _NV_HDR_COLOR_DATA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V2 {
    pub version: NvU32,
    pub cmd: NV_HDR_CMD,
    pub hdrMode: NV_HDR_MODE,
    pub static_metadata_descriptor_id: NV_STATIC_METADATA_DESCRIPTOR_ID,
    pub mastering_display_data: _NV_HDR_COLOR_DATA_V2__bindgen_ty_1,
    pub hdrColorFormat: NV_COLOR_FORMAT,
    pub hdrDynamicRange: NV_DYNAMIC_RANGE,
    pub hdrBpc: NV_BPC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_COLOR_DATA_V2__bindgen_ty_1 {
    pub displayPrimary_x0: NvU16,
    pub displayPrimary_y0: NvU16,
    pub displayPrimary_x1: NvU16,
    pub displayPrimary_y1: NvU16,
    pub displayPrimary_x2: NvU16,
    pub displayPrimary_y2: NvU16,
    pub displayWhitePoint_x: NvU16,
    pub displayWhitePoint_y: NvU16,
    pub max_display_mastering_luminance: NvU16,
    pub min_display_mastering_luminance: NvU16,
    pub max_content_light_level: NvU16,
    pub max_frame_average_light_level: NvU16,
}
pub type NV_HDR_COLOR_DATA_V2 = _NV_HDR_COLOR_DATA_V2;
pub type NV_HDR_COLOR_DATA = NV_HDR_COLOR_DATA_V2;
impl _NV_COLORSPACE_TYPE {
    pub const NV_COLORSPACE_sRGB: _NV_COLORSPACE_TYPE = _NV_COLORSPACE_TYPE(0);
}
impl _NV_COLORSPACE_TYPE {
    pub const NV_COLORSPACE_xRGB: _NV_COLORSPACE_TYPE = _NV_COLORSPACE_TYPE(1);
}
impl _NV_COLORSPACE_TYPE {
    pub const NV_COLORSPACE_REC2100: _NV_COLORSPACE_TYPE = _NV_COLORSPACE_TYPE(12);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_COLORSPACE_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_COLORSPACE_TYPE as NV_COLORSPACE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HDR_METADATA_V1 {
    pub version: NvU32,
    pub displayPrimary_x0: NvU16,
    pub displayPrimary_y0: NvU16,
    pub displayPrimary_x1: NvU16,
    pub displayPrimary_y1: NvU16,
    pub displayPrimary_x2: NvU16,
    pub displayPrimary_y2: NvU16,
    pub displayWhitePoint_x: NvU16,
    pub displayWhitePoint_y: NvU16,
    pub max_display_mastering_luminance: NvU16,
    pub min_display_mastering_luminance: NvU16,
    pub max_content_light_level: NvU16,
    pub max_frame_average_light_level: NvU16,
}
pub type NV_HDR_METADATA_V1 = _NV_HDR_METADATA_V1;
pub type NV_HDR_METADATA = NV_HDR_METADATA_V1;
impl _NV_DISPLAY_OUTPUT_MODE {
    pub const NV_DISPLAY_OUTPUT_MODE_SDR: _NV_DISPLAY_OUTPUT_MODE = _NV_DISPLAY_OUTPUT_MODE(0);
}
impl _NV_DISPLAY_OUTPUT_MODE {
    pub const NV_DISPLAY_OUTPUT_MODE_HDR10: _NV_DISPLAY_OUTPUT_MODE = _NV_DISPLAY_OUTPUT_MODE(1);
}
impl _NV_DISPLAY_OUTPUT_MODE {
    pub const NV_DISPLAY_OUTPUT_MODE_HDR10PLUS_GAMING: _NV_DISPLAY_OUTPUT_MODE =
        _NV_DISPLAY_OUTPUT_MODE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_DISPLAY_OUTPUT_MODE(pub ::std::os::raw::c_int);
pub use self::_NV_DISPLAY_OUTPUT_MODE as NV_DISPLAY_OUTPUT_MODE;
impl _NV_HDR_TONEMAPPING_METHOD {
    pub const NV_HDR_TONEMAPPING_APP: _NV_HDR_TONEMAPPING_METHOD = _NV_HDR_TONEMAPPING_METHOD(0);
}
impl _NV_HDR_TONEMAPPING_METHOD {
    pub const NV_HDR_TONEMAPPING_GPU: _NV_HDR_TONEMAPPING_METHOD = _NV_HDR_TONEMAPPING_METHOD(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_HDR_TONEMAPPING_METHOD(pub ::std::os::raw::c_int);
pub use self::_NV_HDR_TONEMAPPING_METHOD as NV_HDR_TONEMAPPING_METHOD;
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct NV_TIMING_FLAG {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1: NV_TIMING_FLAG__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union NV_TIMING_FLAG__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl NV_TIMING_FLAG__bindgen_ty_1 {
    #[inline]
    pub fn tvFormat(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tvFormat(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ceaId(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ceaId(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn nvPsfId(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nvPsfId(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tvFormat: NvU32,
        ceaId: NvU32,
        nvPsfId: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tvFormat: u32 = unsafe { ::std::mem::transmute(tvFormat) };
            tvFormat as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let ceaId: u32 = unsafe { ::std::mem::transmute(ceaId) };
            ceaId as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let nvPsfId: u32 = unsafe { ::std::mem::transmute(nvPsfId) };
            nvPsfId as u64
        });
        __bindgen_bitfield_unit
    }
}
impl NV_TIMING_FLAG {
    #[inline]
    pub fn isInterlaced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_isInterlaced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isInterlaced: NvU32,
        reserved0: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let isInterlaced: u32 = unsafe { ::std::mem::transmute(isInterlaced) };
            isInterlaced as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn scaling(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_scaling(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(scaling: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let scaling: u32 = unsafe { ::std::mem::transmute(scaling) };
            scaling as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_TIMING_INPUT {
    pub version: NvU32,
    pub width: NvU32,
    pub height: NvU32,
    pub rr: f32,
    pub flag: NV_TIMING_FLAG,
    pub type_: NV_TIMING_OVERRIDE,
}
pub type NV_TIMING_INPUT = _NV_TIMING_INPUT;
impl NV_MONITOR_CAPS_TYPE {
    pub const NV_MONITOR_CAPS_TYPE_HDMI_VSDB: NV_MONITOR_CAPS_TYPE = NV_MONITOR_CAPS_TYPE(4096);
}
impl NV_MONITOR_CAPS_TYPE {
    pub const NV_MONITOR_CAPS_TYPE_HDMI_VCDB: NV_MONITOR_CAPS_TYPE = NV_MONITOR_CAPS_TYPE(4097);
}
impl NV_MONITOR_CAPS_TYPE {
    pub const NV_MONITOR_CAPS_TYPE_GENERIC: NV_MONITOR_CAPS_TYPE = NV_MONITOR_CAPS_TYPE(4098);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_MONITOR_CAPS_TYPE(pub ::std::os::raw::c_int);
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _NV_MONITOR_CAPS_VCDB {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _NV_MONITOR_CAPS_VCDB {
    #[inline]
    pub fn quantizationRangeYcc(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_quantizationRangeYcc(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quantizationRangeRgb(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_quantizationRangeRgb(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfoPreferredVideoFormat(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_scanInfoPreferredVideoFormat(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfoITVideoFormats(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_scanInfoITVideoFormats(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn scanInfoCEVideoFormats(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_scanInfoCEVideoFormats(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        quantizationRangeYcc: NvU8,
        quantizationRangeRgb: NvU8,
        scanInfoPreferredVideoFormat: NvU8,
        scanInfoITVideoFormats: NvU8,
        scanInfoCEVideoFormats: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let quantizationRangeYcc: u8 = unsafe { ::std::mem::transmute(quantizationRangeYcc) };
            quantizationRangeYcc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let quantizationRangeRgb: u8 = unsafe { ::std::mem::transmute(quantizationRangeRgb) };
            quantizationRangeRgb as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let scanInfoPreferredVideoFormat: u8 =
                unsafe { ::std::mem::transmute(scanInfoPreferredVideoFormat) };
            scanInfoPreferredVideoFormat as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let scanInfoITVideoFormats: u8 =
                unsafe { ::std::mem::transmute(scanInfoITVideoFormats) };
            scanInfoITVideoFormats as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let scanInfoCEVideoFormats: u8 =
                unsafe { ::std::mem::transmute(scanInfoCEVideoFormats) };
            scanInfoCEVideoFormats as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MONITOR_CAPS_VCDB = _NV_MONITOR_CAPS_VCDB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MONITOR_CAPS_VSDB {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub maxTmdsClock: NvU8,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub videoLatency: NvU8,
    pub audioLatency: NvU8,
    pub interlacedVideoLatency: NvU8,
    pub interlacedAudioLatency: NvU8,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub hdmi_vic: [NvU8; 7usize],
    pub hdmi_3d: [NvU8; 31usize],
}
impl _NV_MONITOR_CAPS_VSDB {
    #[inline]
    pub fn sourcePhysicalAddressB(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressB(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sourcePhysicalAddressA(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressA(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sourcePhysicalAddressD(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressD(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sourcePhysicalAddressC(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sourcePhysicalAddressC(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDualDviOperation(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDualDviOperation(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColorYCbCr444(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColorYCbCr444(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColor30bits(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColor30bits(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColor36bits(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColor36bits(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportDeepColor48bits(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportDeepColor48bits(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportAI(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportAI(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sourcePhysicalAddressB: NvU8,
        sourcePhysicalAddressA: NvU8,
        sourcePhysicalAddressD: NvU8,
        sourcePhysicalAddressC: NvU8,
        supportDualDviOperation: NvU8,
        reserved6: NvU8,
        supportDeepColorYCbCr444: NvU8,
        supportDeepColor30bits: NvU8,
        supportDeepColor36bits: NvU8,
        supportDeepColor48bits: NvU8,
        supportAI: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sourcePhysicalAddressB: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressB) };
            sourcePhysicalAddressB as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let sourcePhysicalAddressA: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressA) };
            sourcePhysicalAddressA as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let sourcePhysicalAddressD: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressD) };
            sourcePhysicalAddressD as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let sourcePhysicalAddressC: u8 =
                unsafe { ::std::mem::transmute(sourcePhysicalAddressC) };
            sourcePhysicalAddressC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let supportDualDviOperation: u8 =
                unsafe { ::std::mem::transmute(supportDualDviOperation) };
            supportDualDviOperation as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let reserved6: u8 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let supportDeepColorYCbCr444: u8 =
                unsafe { ::std::mem::transmute(supportDeepColorYCbCr444) };
            supportDeepColorYCbCr444 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let supportDeepColor30bits: u8 =
                unsafe { ::std::mem::transmute(supportDeepColor30bits) };
            supportDeepColor30bits as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let supportDeepColor36bits: u8 =
                unsafe { ::std::mem::transmute(supportDeepColor36bits) };
            supportDeepColor36bits as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let supportDeepColor48bits: u8 =
                unsafe { ::std::mem::transmute(supportDeepColor48bits) };
            supportDeepColor48bits as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let supportAI: u8 = unsafe { ::std::mem::transmute(supportAI) };
            supportAI as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cnc0SupportGraphicsTextContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc0SupportGraphicsTextContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnc1SupportPhotoContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc1SupportPhotoContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnc2SupportCinemaContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc2SupportCinemaContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnc3SupportGameContent(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cnc3SupportGameContent(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasVicEntries(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasVicEntries(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasInterlacedLatencyField(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasInterlacedLatencyField(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasLatencyField(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasLatencyField(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        cnc0SupportGraphicsTextContent: NvU8,
        cnc1SupportPhotoContent: NvU8,
        cnc2SupportCinemaContent: NvU8,
        cnc3SupportGameContent: NvU8,
        reserved8: NvU8,
        hasVicEntries: NvU8,
        hasInterlacedLatencyField: NvU8,
        hasLatencyField: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cnc0SupportGraphicsTextContent: u8 =
                unsafe { ::std::mem::transmute(cnc0SupportGraphicsTextContent) };
            cnc0SupportGraphicsTextContent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cnc1SupportPhotoContent: u8 =
                unsafe { ::std::mem::transmute(cnc1SupportPhotoContent) };
            cnc1SupportPhotoContent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cnc2SupportCinemaContent: u8 =
                unsafe { ::std::mem::transmute(cnc2SupportCinemaContent) };
            cnc2SupportCinemaContent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cnc3SupportGameContent: u8 =
                unsafe { ::std::mem::transmute(cnc3SupportGameContent) };
            cnc3SupportGameContent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved8: u8 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasVicEntries: u8 = unsafe { ::std::mem::transmute(hasVicEntries) };
            hasVicEntries as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasInterlacedLatencyField: u8 =
                unsafe { ::std::mem::transmute(hasInterlacedLatencyField) };
            hasInterlacedLatencyField as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasLatencyField: u8 = unsafe { ::std::mem::transmute(hasLatencyField) };
            hasLatencyField as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn reserved13(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn has3dEntries(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has3dEntries(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hdmi3dLength(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(8usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_hdmi3dLength(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hdmiVicLength(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(13usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_hdmiVicLength(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        reserved13: NvU8,
        has3dEntries: NvU8,
        hdmi3dLength: NvU8,
        hdmiVicLength: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved13: u8 = unsafe { ::std::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has3dEntries: u8 = unsafe { ::std::mem::transmute(has3dEntries) };
            has3dEntries as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let hdmi3dLength: u8 = unsafe { ::std::mem::transmute(hdmi3dLength) };
            hdmi3dLength as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let hdmiVicLength: u8 = unsafe { ::std::mem::transmute(hdmiVicLength) };
            hdmiVicLength as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MONITOR_CAPS_VSDB = _NV_MONITOR_CAPS_VSDB;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _NV_MONITOR_CAPS_GENERIC {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _NV_MONITOR_CAPS_GENERIC {
    #[inline]
    pub fn supportVRR(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportVRR(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportULMB(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supportULMB(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isTrueGsync(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isTrueGsync(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isRLACapable(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isRLACapable(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn currentlyCapableOfVRR(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_currentlyCapableOfVRR(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supportVRR: NvU8,
        supportULMB: NvU8,
        isTrueGsync: NvU8,
        isRLACapable: NvU8,
        currentlyCapableOfVRR: NvU8,
        reserved: NvU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supportVRR: u8 = unsafe { ::std::mem::transmute(supportVRR) };
            supportVRR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let supportULMB: u8 = unsafe { ::std::mem::transmute(supportULMB) };
            supportULMB as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isTrueGsync: u8 = unsafe { ::std::mem::transmute(isTrueGsync) };
            isTrueGsync as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isRLACapable: u8 = unsafe { ::std::mem::transmute(isRLACapable) };
            isRLACapable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let currentlyCapableOfVRR: u8 = unsafe { ::std::mem::transmute(currentlyCapableOfVRR) };
            currentlyCapableOfVRR as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MONITOR_CAPS_GENERIC = _NV_MONITOR_CAPS_GENERIC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MONITOR_CAPABILITIES_V1 {
    pub version: NvU32,
    pub size: NvU16,
    pub infoType: NvU32,
    pub connectorType: NvU32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: _NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_MONITOR_CAPABILITIES_V1__bindgen_ty_1 {
    pub vsdb: NV_MONITOR_CAPS_VSDB,
    pub vcdb: NV_MONITOR_CAPS_VCDB,
    pub caps: NV_MONITOR_CAPS_GENERIC,
}
impl _NV_MONITOR_CAPABILITIES_V1 {
    #[inline]
    pub fn bIsValidInfo(&self) -> NvU8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bIsValidInfo(&mut self, val: NvU8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bIsValidInfo: NvU8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsValidInfo: u8 = unsafe { ::std::mem::transmute(bIsValidInfo) };
            bIsValidInfo as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MONITOR_CAPABILITIES_V1 = _NV_MONITOR_CAPABILITIES_V1;
pub type NV_MONITOR_CAPABILITIES = NV_MONITOR_CAPABILITIES_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MONITOR_COLOR_DATA {
    pub version: NvU32,
    pub colorFormat: NV_DP_COLOR_FORMAT,
    pub backendBitDepths: NV_DP_BPC,
}
pub type NV_MONITOR_COLOR_CAPS_V1 = _NV_MONITOR_COLOR_DATA;
pub type NV_MONITOR_COLOR_CAPS = NV_MONITOR_COLOR_CAPS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_CUSTOM_DISPLAY {
    pub version: NvU32,
    pub width: NvU32,
    pub height: NvU32,
    pub depth: NvU32,
    pub colorFormat: NV_FORMAT,
    pub srcPartition: NV_VIEWPORTF,
    pub xRatio: f32,
    pub yRatio: f32,
    pub timing: NV_TIMING,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl NV_CUSTOM_DISPLAY {
    #[inline]
    pub fn hwModeSetOnly(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hwModeSetOnly(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hwModeSetOnly: NvU32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hwModeSetOnly: u32 = unsafe { ::std::mem::transmute(hwModeSetOnly) };
            hwModeSetOnly as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GET_ADAPTIVE_SYNC_DATA_V1 {
    pub version: NvU32,
    pub maxFrameInterval: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub lastFlipRefreshCount: NvU32,
    pub lastFlipTimeStamp: NvU64,
    pub reservedEx: [NvU32; 4usize],
}
impl _NV_GET_ADAPTIVE_SYNC_DATA_V1 {
    #[inline]
    pub fn bDisableAdaptiveSync(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableAdaptiveSync(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bDisableFrameSplitting(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableFrameSplitting(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDisableAdaptiveSync: NvU32,
        bDisableFrameSplitting: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDisableAdaptiveSync: u32 = unsafe { ::std::mem::transmute(bDisableAdaptiveSync) };
            bDisableAdaptiveSync as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bDisableFrameSplitting: u32 =
                unsafe { ::std::mem::transmute(bDisableFrameSplitting) };
            bDisableFrameSplitting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GET_ADAPTIVE_SYNC_DATA_V1 = _NV_GET_ADAPTIVE_SYNC_DATA_V1;
pub type NV_GET_ADAPTIVE_SYNC_DATA = NV_GET_ADAPTIVE_SYNC_DATA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SET_ADAPTIVE_SYNC_DATA_V1 {
    pub version: NvU32,
    pub maxFrameInterval: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reservedEx: [NvU32; 7usize],
}
impl _NV_SET_ADAPTIVE_SYNC_DATA_V1 {
    #[inline]
    pub fn bDisableAdaptiveSync(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableAdaptiveSync(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bDisableFrameSplitting(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisableFrameSplitting(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDisableAdaptiveSync: NvU32,
        bDisableFrameSplitting: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDisableAdaptiveSync: u32 = unsafe { ::std::mem::transmute(bDisableAdaptiveSync) };
            bDisableAdaptiveSync as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bDisableFrameSplitting: u32 =
                unsafe { ::std::mem::transmute(bDisableFrameSplitting) };
            bDisableFrameSplitting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_SET_ADAPTIVE_SYNC_DATA_V1 = _NV_SET_ADAPTIVE_SYNC_DATA_V1;
pub type NV_SET_ADAPTIVE_SYNC_DATA = NV_SET_ADAPTIVE_SYNC_DATA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1 {
    pub version: NvU32,
    pub frameIntervalUs: NvU32,
    pub reservedEx: [NvU32; 8usize],
}
pub type NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1 = _NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1;
pub type NV_GET_VIRTUAL_REFRESH_RATE_DATA = NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1 {
    pub version: NvU32,
    pub frameIntervalUs: NvU32,
    pub reservedEx: [NvU32; 8usize],
}
pub type NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1 = _NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1;
pub type NV_SET_VIRTUAL_REFRESH_RATE_DATA = NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_SET_PREFERRED_STEREO_DISPLAY_V1 {
    pub version: NvU32,
    pub displayId: NvU32,
    pub reserved: NvU32,
}
pub type NV_SET_PREFERRED_STEREO_DISPLAY = NV_SET_PREFERRED_STEREO_DISPLAY_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GET_PREFERRED_STEREO_DISPLAY_V1 {
    pub version: NvU32,
    pub displayId: NvU32,
    pub reserved: NvU32,
}
pub type NV_GET_PREFERRED_STEREO_DISPLAY = NV_GET_PREFERRED_STEREO_DISPLAY_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MANAGED_DEDICATED_DISPLAY_INFO {
    pub version: NvU32,
    pub displayId: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NV_MANAGED_DEDICATED_DISPLAY_INFO {
    #[inline]
    pub fn isAcquired(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isAcquired(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMosaic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMosaic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isAcquired: NvU32,
        isMosaic: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isAcquired: u32 = unsafe { ::std::mem::transmute(isAcquired) };
            isAcquired as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isMosaic: u32 = unsafe { ::std::mem::transmute(isMosaic) };
            isMosaic as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MANAGED_DEDICATED_DISPLAY_INFO_V1 = _NV_MANAGED_DEDICATED_DISPLAY_INFO;
pub type NV_MANAGED_DEDICATED_DISPLAY_INFO = NV_MANAGED_DEDICATED_DISPLAY_INFO_V1;
#[repr(C)]
pub struct _NV_DISPLAY_ID_INFO_DATA_V1 {
    pub version: NvU32,
    pub adapterId: LUID,
    pub targetId: NvU32,
    pub reserved: [NvU32; 4usize],
}
pub type NV_DISPLAY_ID_INFO_DATA_V1 = _NV_DISPLAY_ID_INFO_DATA_V1;
pub type NV_DISPLAY_ID_INFO_DATA = NV_DISPLAY_ID_INFO_DATA_V1;
#[repr(C)]
pub struct _NV_TARGET_INFO_DATA_V1 {
    pub version: NvU32,
    pub adapterId: LUID,
    pub targetId: NvU32,
    pub displayId: [NvU32; 128usize],
    pub displayIdCount: NvU32,
    pub reserved: [NvU32; 4usize],
}
pub type NV_TARGET_INFO_DATA_V1 = _NV_TARGET_INFO_DATA_V1;
pub type NV_TARGET_INFO_DATA = NV_TARGET_INFO_DATA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GET_VRR_INFO_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reservedEx: [NvU32; 4usize],
}
impl _NV_GET_VRR_INFO_V1 {
    #[inline]
    pub fn bIsVRREnabled(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsVRREnabled(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsVRREnabled: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsVRREnabled: u32 = unsafe { ::std::mem::transmute(bIsVRREnabled) };
            bIsVRREnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GET_VRR_INFO_V1 = _NV_GET_VRR_INFO_V1;
pub type NV_GET_VRR_INFO = NV_GET_VRR_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_TOPO_DETAILS {
    pub version: NvU32,
    pub hLogicalGPU: NvLogicalGpuHandle,
    pub validityMask: NvU32,
    pub rowCount: NvU32,
    pub colCount: NvU32,
    pub gpuLayout: [[NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1; 8usize]; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_TOPO_DETAILS__bindgen_ty_1 {
    pub hPhysicalGPU: NvPhysicalGpuHandle,
    pub displayOutputId: NvU32,
    pub overlapX: NvS32,
    pub overlapY: NvS32,
}
impl NV_MOSAIC_TOPO_TYPE {
    pub const NV_MOSAIC_TOPO_TYPE_ALL: NV_MOSAIC_TOPO_TYPE = NV_MOSAIC_TOPO_TYPE(0);
}
impl NV_MOSAIC_TOPO_TYPE {
    pub const NV_MOSAIC_TOPO_TYPE_BASIC: NV_MOSAIC_TOPO_TYPE = NV_MOSAIC_TOPO_TYPE(1);
}
impl NV_MOSAIC_TOPO_TYPE {
    pub const NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO: NV_MOSAIC_TOPO_TYPE = NV_MOSAIC_TOPO_TYPE(2);
}
impl NV_MOSAIC_TOPO_TYPE {
    pub const NV_MOSAIC_TOPO_TYPE_SCALED_CLONE: NV_MOSAIC_TOPO_TYPE = NV_MOSAIC_TOPO_TYPE(3);
}
impl NV_MOSAIC_TOPO_TYPE {
    pub const NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO_SCALED_CLONE: NV_MOSAIC_TOPO_TYPE =
        NV_MOSAIC_TOPO_TYPE(4);
}
impl NV_MOSAIC_TOPO_TYPE {
    pub const NV_MOSAIC_TOPO_TYPE_MAX: NV_MOSAIC_TOPO_TYPE = NV_MOSAIC_TOPO_TYPE(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_MOSAIC_TOPO_TYPE(pub ::std::os::raw::c_int);
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_NONE: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(0);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_BEGIN_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(1);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_1x2_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(1);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_2x1_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(2);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_1x3_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(3);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_3x1_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(4);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_1x4_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(5);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_4x1_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(6);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_2x2_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(7);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_2x3_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(8);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_2x4_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(9);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_3x2_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(10);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_4x2_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(11);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_1x5_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(12);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_1x6_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(13);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_7x1_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(14);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_END_BASIC: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(23);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(24);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_1x2_PASSIVE_STEREO: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(24);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_2x1_PASSIVE_STEREO: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(25);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_1x3_PASSIVE_STEREO: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(26);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_3x1_PASSIVE_STEREO: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(27);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_1x4_PASSIVE_STEREO: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(28);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_4x1_PASSIVE_STEREO: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(29);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_2x2_PASSIVE_STEREO: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(30);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_END_PASSIVE_STEREO: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(34);
}
impl NV_MOSAIC_TOPO {
    pub const NV_MOSAIC_TOPO_MAX: NV_MOSAIC_TOPO = NV_MOSAIC_TOPO(35);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_MOSAIC_TOPO(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_TOPO_BRIEF {
    pub version: NvU32,
    pub topo: NV_MOSAIC_TOPO,
    pub enabled: NvU32,
    pub isPossible: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MOSAIC_DISPLAY_SETTING_V1 {
    pub version: NvU32,
    pub width: NvU32,
    pub height: NvU32,
    pub bpp: NvU32,
    pub freq: NvU32,
}
pub type NV_MOSAIC_DISPLAY_SETTING_V1 = _NV_MOSAIC_DISPLAY_SETTING_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_DISPLAY_SETTING_V2 {
    pub version: NvU32,
    pub width: NvU32,
    pub height: NvU32,
    pub bpp: NvU32,
    pub freq: NvU32,
    pub rrx1k: NvU32,
}
pub type NV_MOSAIC_DISPLAY_SETTING = NV_MOSAIC_DISPLAY_SETTING_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V1 {
    pub version: NvU32,
    pub topoBriefsCount: NvU32,
    pub topoBriefs: [NV_MOSAIC_TOPO_BRIEF; 35usize],
    pub displaySettingsCount: NvU32,
    pub displaySettings: [NV_MOSAIC_DISPLAY_SETTING_V1; 40usize],
}
pub type NV_MOSAIC_SUPPORTED_TOPO_INFO_V1 = _NV_MOSAIC_SUPPORTED_TOPO_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 {
    pub version: NvU32,
    pub topoBriefsCount: NvU32,
    pub topoBriefs: [NV_MOSAIC_TOPO_BRIEF; 35usize],
    pub displaySettingsCount: NvU32,
    pub displaySettings: [NV_MOSAIC_DISPLAY_SETTING_V2; 40usize],
}
pub type NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 = _NV_MOSAIC_SUPPORTED_TOPO_INFO_V2;
pub type NV_MOSAIC_SUPPORTED_TOPO_INFO = NV_MOSAIC_SUPPORTED_TOPO_INFO_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_TOPO_GROUP {
    pub version: NvU32,
    pub brief: NV_MOSAIC_TOPO_BRIEF,
    pub count: NvU32,
    pub topos: [NV_MOSAIC_TOPO_DETAILS; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V1 {
    pub displayId: NvU32,
    pub overlapX: NvS32,
    pub overlapY: NvS32,
    pub rotation: NV_ROTATE,
    pub cloneGroup: NvU32,
}
pub type NV_MOSAIC_GRID_TOPO_DISPLAY_V1 = _NV_MOSAIC_GRID_TOPO_DISPLAY_V1;
impl _NV_PIXEL_SHIFT_TYPE {
    pub const NV_PIXEL_SHIFT_TYPE_NO_PIXEL_SHIFT: _NV_PIXEL_SHIFT_TYPE = _NV_PIXEL_SHIFT_TYPE(0);
}
impl _NV_PIXEL_SHIFT_TYPE {
    pub const NV_PIXEL_SHIFT_TYPE_2x2_TOP_LEFT_PIXELS: _NV_PIXEL_SHIFT_TYPE =
        _NV_PIXEL_SHIFT_TYPE(1);
}
impl _NV_PIXEL_SHIFT_TYPE {
    pub const NV_PIXEL_SHIFT_TYPE_2x2_BOTTOM_RIGHT_PIXELS: _NV_PIXEL_SHIFT_TYPE =
        _NV_PIXEL_SHIFT_TYPE(2);
}
impl _NV_PIXEL_SHIFT_TYPE {
    pub const NV_PIXEL_SHIFT_TYPE_2x2_TOP_RIGHT_PIXELS: _NV_PIXEL_SHIFT_TYPE =
        _NV_PIXEL_SHIFT_TYPE(4);
}
impl _NV_PIXEL_SHIFT_TYPE {
    pub const NV_PIXEL_SHIFT_TYPE_2x2_BOTTOM_LEFT_PIXELS: _NV_PIXEL_SHIFT_TYPE =
        _NV_PIXEL_SHIFT_TYPE(8);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_PIXEL_SHIFT_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_PIXEL_SHIFT_TYPE as NV_PIXEL_SHIFT_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V2 {
    pub version: NvU32,
    pub displayId: NvU32,
    pub overlapX: NvS32,
    pub overlapY: NvS32,
    pub rotation: NV_ROTATE,
    pub cloneGroup: NvU32,
    pub pixelShiftType: NV_PIXEL_SHIFT_TYPE,
}
pub type NV_MOSAIC_GRID_TOPO_DISPLAY_V2 = _NV_MOSAIC_GRID_TOPO_DISPLAY_V2;
pub type NV_MOSAIC_GRID_TOPO_DISPLAY = NV_MOSAIC_GRID_TOPO_DISPLAY_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_V1 {
    pub version: NvU32,
    pub rows: NvU32,
    pub columns: NvU32,
    pub displayCount: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub displays: [NV_MOSAIC_GRID_TOPO_DISPLAY_V1; 64usize],
    pub displaySettings: NV_MOSAIC_DISPLAY_SETTING_V1,
}
impl _NV_MOSAIC_GRID_TOPO_V1 {
    #[inline]
    pub fn applyWithBezelCorrect(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyWithBezelCorrect(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn immersiveGaming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_immersiveGaming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn baseMosaic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_baseMosaic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverReloadAllowed(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverReloadAllowed(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acceleratePrimaryDisplay(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_acceleratePrimaryDisplay(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyWithBezelCorrect: NvU32,
        immersiveGaming: NvU32,
        baseMosaic: NvU32,
        driverReloadAllowed: NvU32,
        acceleratePrimaryDisplay: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyWithBezelCorrect: u32 =
                unsafe { ::std::mem::transmute(applyWithBezelCorrect) };
            applyWithBezelCorrect as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let immersiveGaming: u32 = unsafe { ::std::mem::transmute(immersiveGaming) };
            immersiveGaming as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let baseMosaic: u32 = unsafe { ::std::mem::transmute(baseMosaic) };
            baseMosaic as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverReloadAllowed: u32 = unsafe { ::std::mem::transmute(driverReloadAllowed) };
            driverReloadAllowed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let acceleratePrimaryDisplay: u32 =
                unsafe { ::std::mem::transmute(acceleratePrimaryDisplay) };
            acceleratePrimaryDisplay as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MOSAIC_GRID_TOPO_V1 = _NV_MOSAIC_GRID_TOPO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MOSAIC_GRID_TOPO_V2 {
    pub version: NvU32,
    pub rows: NvU32,
    pub columns: NvU32,
    pub displayCount: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub displays: [NV_MOSAIC_GRID_TOPO_DISPLAY_V2; 64usize],
    pub displaySettings: NV_MOSAIC_DISPLAY_SETTING_V1,
}
impl _NV_MOSAIC_GRID_TOPO_V2 {
    #[inline]
    pub fn applyWithBezelCorrect(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyWithBezelCorrect(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn immersiveGaming(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_immersiveGaming(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn baseMosaic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_baseMosaic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn driverReloadAllowed(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_driverReloadAllowed(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acceleratePrimaryDisplay(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_acceleratePrimaryDisplay(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelShift(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pixelShift(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyWithBezelCorrect: NvU32,
        immersiveGaming: NvU32,
        baseMosaic: NvU32,
        driverReloadAllowed: NvU32,
        acceleratePrimaryDisplay: NvU32,
        pixelShift: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyWithBezelCorrect: u32 =
                unsafe { ::std::mem::transmute(applyWithBezelCorrect) };
            applyWithBezelCorrect as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let immersiveGaming: u32 = unsafe { ::std::mem::transmute(immersiveGaming) };
            immersiveGaming as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let baseMosaic: u32 = unsafe { ::std::mem::transmute(baseMosaic) };
            baseMosaic as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let driverReloadAllowed: u32 = unsafe { ::std::mem::transmute(driverReloadAllowed) };
            driverReloadAllowed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let acceleratePrimaryDisplay: u32 =
                unsafe { ::std::mem::transmute(acceleratePrimaryDisplay) };
            acceleratePrimaryDisplay as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let pixelShift: u32 = unsafe { ::std::mem::transmute(pixelShift) };
            pixelShift as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_MOSAIC_GRID_TOPO_V2 = _NV_MOSAIC_GRID_TOPO_V2;
pub type NV_MOSAIC_GRID_TOPO = NV_MOSAIC_GRID_TOPO_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_DISPLAY_TOPO_STATUS {
    pub version: NvU32,
    pub errorFlags: NvU32,
    pub warningFlags: NvU32,
    pub displayCount: NvU32,
    pub displays: [NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1 {
    pub displayId: NvU32,
    pub errorFlags: NvU32,
    pub warningFlags: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl NV_MOSAIC_DISPLAY_TOPO_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn supportsRotation(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsRotation(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supportsRotation: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supportsRotation: u32 = unsafe { ::std::mem::transmute(supportsRotation) };
            supportsRotation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_TOPOLOGY {
    pub version: NvU32,
    pub rowCount: NvU32,
    pub colCount: NvU32,
    pub gpuLayout: [[NV_MOSAIC_TOPOLOGY__bindgen_ty_1; 8usize]; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_TOPOLOGY__bindgen_ty_1 {
    pub hPhysicalGPU: NvPhysicalGpuHandle,
    pub displayOutputId: NvU32,
    pub overlapX: NvS32,
    pub overlapY: NvS32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_MOSAIC_SUPPORTED_TOPOLOGIES {
    pub version: NvU32,
    pub totalCount: NvU32,
    pub topos: [NV_MOSAIC_TOPOLOGY; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_CAPABILITIES_V1 {
    pub version: NvU32,
    pub boardId: NvU32,
    pub revision: NvU32,
    pub capFlags: NvU32,
}
pub type NV_GSYNC_CAPABILITIES_V1 = _NV_GSYNC_CAPABILITIES_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_CAPABILITIES_V2 {
    pub version: NvU32,
    pub boardId: NvU32,
    pub revision: NvU32,
    pub capFlags: NvU32,
    pub extendedRevision: NvU32,
}
pub type NV_GSYNC_CAPABILITIES_V2 = _NV_GSYNC_CAPABILITIES_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_CAPABILITIES_V3 {
    pub version: NvU32,
    pub boardId: NvU32,
    pub revision: NvU32,
    pub capFlags: NvU32,
    pub extendedRevision: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub maxMulDivValue: NvU32,
}
impl _NV_GSYNC_CAPABILITIES_V3 {
    #[inline]
    pub fn bIsMulDivSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsMulDivSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsMulDivSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsMulDivSupported: u32 = unsafe { ::std::mem::transmute(bIsMulDivSupported) };
            bIsMulDivSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_CAPABILITIES_V3 = _NV_GSYNC_CAPABILITIES_V3;
pub type NV_GSYNC_CAPABILITIES = NV_GSYNC_CAPABILITIES_V3;
impl _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR {
    pub const NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NONE: _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR =
        _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR(0);
}
impl _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR {
    pub const NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_PRIMARY: _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR =
        _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR(1);
}
impl _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR {
    pub const NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_SECONDARY: _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR =
        _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR(2);
}
impl _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR {
    pub const NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_TERTIARY: _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR =
        _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR(3);
}
impl _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR {
    pub const NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_QUARTERNARY: _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR =
        _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR(pub ::std::os::raw::c_int);
pub use self::_NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR as NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR;
impl _NVAPI_GSYNC_DISPLAY_SYNC_STATE {
    pub const NVAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED: _NVAPI_GSYNC_DISPLAY_SYNC_STATE =
        _NVAPI_GSYNC_DISPLAY_SYNC_STATE(0);
}
impl _NVAPI_GSYNC_DISPLAY_SYNC_STATE {
    pub const NVAPI_GSYNC_DISPLAY_SYNC_STATE_SLAVE: _NVAPI_GSYNC_DISPLAY_SYNC_STATE =
        _NVAPI_GSYNC_DISPLAY_SYNC_STATE(1);
}
impl _NVAPI_GSYNC_DISPLAY_SYNC_STATE {
    pub const NVAPI_GSYNC_DISPLAY_SYNC_STATE_MASTER: _NVAPI_GSYNC_DISPLAY_SYNC_STATE =
        _NVAPI_GSYNC_DISPLAY_SYNC_STATE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_GSYNC_DISPLAY_SYNC_STATE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_GSYNC_DISPLAY_SYNC_STATE as NVAPI_GSYNC_DISPLAY_SYNC_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_GPU {
    pub version: NvU32,
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    pub connector: NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR,
    pub hProxyPhysicalGpu: NvPhysicalGpuHandle,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl _NV_GSYNC_GPU {
    #[inline]
    pub fn isSynced(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSynced(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isSynced: NvU32, reserved: NvU32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isSynced: u32 = unsafe { ::std::mem::transmute(isSynced) };
            isSynced as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_GPU = _NV_GSYNC_GPU;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_DISPLAY {
    pub version: NvU32,
    pub displayId: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub syncState: NVAPI_GSYNC_DISPLAY_SYNC_STATE,
}
impl _NV_GSYNC_DISPLAY {
    #[inline]
    pub fn isMasterable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMasterable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isMasterable: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isMasterable: u32 = unsafe { ::std::mem::transmute(isMasterable) };
            isMasterable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_DISPLAY = _NV_GSYNC_DISPLAY;
impl _NVAPI_GSYNC_POLARITY {
    pub const NVAPI_GSYNC_POLARITY_RISING_EDGE: _NVAPI_GSYNC_POLARITY = _NVAPI_GSYNC_POLARITY(0);
}
impl _NVAPI_GSYNC_POLARITY {
    pub const NVAPI_GSYNC_POLARITY_FALLING_EDGE: _NVAPI_GSYNC_POLARITY = _NVAPI_GSYNC_POLARITY(1);
}
impl _NVAPI_GSYNC_POLARITY {
    pub const NVAPI_GSYNC_POLARITY_BOTH_EDGES: _NVAPI_GSYNC_POLARITY = _NVAPI_GSYNC_POLARITY(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_GSYNC_POLARITY(pub ::std::os::raw::c_int);
pub use self::_NVAPI_GSYNC_POLARITY as NVAPI_GSYNC_POLARITY;
impl _NVAPI_GSYNC_VIDEO_MODE {
    pub const NVAPI_GSYNC_VIDEO_MODE_NONE: _NVAPI_GSYNC_VIDEO_MODE = _NVAPI_GSYNC_VIDEO_MODE(0);
}
impl _NVAPI_GSYNC_VIDEO_MODE {
    pub const NVAPI_GSYNC_VIDEO_MODE_TTL: _NVAPI_GSYNC_VIDEO_MODE = _NVAPI_GSYNC_VIDEO_MODE(1);
}
impl _NVAPI_GSYNC_VIDEO_MODE {
    pub const NVAPI_GSYNC_VIDEO_MODE_NTSCPALSECAM: _NVAPI_GSYNC_VIDEO_MODE =
        _NVAPI_GSYNC_VIDEO_MODE(2);
}
impl _NVAPI_GSYNC_VIDEO_MODE {
    pub const NVAPI_GSYNC_VIDEO_MODE_HDTV: _NVAPI_GSYNC_VIDEO_MODE = _NVAPI_GSYNC_VIDEO_MODE(3);
}
impl _NVAPI_GSYNC_VIDEO_MODE {
    pub const NVAPI_GSYNC_VIDEO_MODE_COMPOSITE: _NVAPI_GSYNC_VIDEO_MODE =
        _NVAPI_GSYNC_VIDEO_MODE(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_GSYNC_VIDEO_MODE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_GSYNC_VIDEO_MODE as NVAPI_GSYNC_VIDEO_MODE;
impl _NVAPI_GSYNC_SYNC_SOURCE {
    pub const NVAPI_GSYNC_SYNC_SOURCE_VSYNC: _NVAPI_GSYNC_SYNC_SOURCE = _NVAPI_GSYNC_SYNC_SOURCE(0);
}
impl _NVAPI_GSYNC_SYNC_SOURCE {
    pub const NVAPI_GSYNC_SYNC_SOURCE_HOUSESYNC: _NVAPI_GSYNC_SYNC_SOURCE =
        _NVAPI_GSYNC_SYNC_SOURCE(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_GSYNC_SYNC_SOURCE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_GSYNC_SYNC_SOURCE as NVAPI_GSYNC_SYNC_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_DELAY {
    pub version: NvU32,
    pub numLines: NvU32,
    pub numPixels: NvU32,
    pub maxLines: NvU32,
    pub minPixels: NvU32,
}
pub type NV_GSYNC_DELAY = _NV_GSYNC_DELAY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_CONTROL_PARAMS_V1 {
    pub version: NvU32,
    pub polarity: NVAPI_GSYNC_POLARITY,
    pub vmode: NVAPI_GSYNC_VIDEO_MODE,
    pub interval: NvU32,
    pub source: NVAPI_GSYNC_SYNC_SOURCE,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub syncSkew: NV_GSYNC_DELAY,
    pub startupDelay: NV_GSYNC_DELAY,
}
impl _NV_GSYNC_CONTROL_PARAMS_V1 {
    #[inline]
    pub fn interlaceMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaceMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syncSourceIsOutput(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_syncSourceIsOutput(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interlaceMode: NvU32,
        syncSourceIsOutput: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaceMode: u32 = unsafe { ::std::mem::transmute(interlaceMode) };
            interlaceMode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syncSourceIsOutput: u32 = unsafe { ::std::mem::transmute(syncSourceIsOutput) };
            syncSourceIsOutput as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_CONTROL_PARAMS_V1 = _NV_GSYNC_CONTROL_PARAMS_V1;
impl _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE {
    pub const NVAPI_GSYNC_UNDEFINED_MODE: _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE =
        _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE(0);
}
impl _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE {
    pub const NVAPI_GSYNC_MULTIPLY_MODE: _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE =
        _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE(1);
}
impl _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE {
    pub const NVAPI_GSYNC_DIVIDE_MODE: _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE =
        _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE as NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_CONTROL_PARAMS_V2 {
    pub version: NvU32,
    pub polarity: NVAPI_GSYNC_POLARITY,
    pub vmode: NVAPI_GSYNC_VIDEO_MODE,
    pub interval: NvU32,
    pub source: NVAPI_GSYNC_SYNC_SOURCE,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub syncSkew: NV_GSYNC_DELAY,
    pub startupDelay: NV_GSYNC_DELAY,
    pub multiplyDivideMode: NVAPI_GSYNC_MULTIPLY_DIVIDE_MODE,
    pub multiplyDivideValue: NvU8,
}
impl _NV_GSYNC_CONTROL_PARAMS_V2 {
    #[inline]
    pub fn interlaceMode(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interlaceMode(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syncSourceIsOutput(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_syncSourceIsOutput(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interlaceMode: NvU32,
        syncSourceIsOutput: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interlaceMode: u32 = unsafe { ::std::mem::transmute(interlaceMode) };
            interlaceMode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syncSourceIsOutput: u32 = unsafe { ::std::mem::transmute(syncSourceIsOutput) };
            syncSourceIsOutput as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_CONTROL_PARAMS_V2 = _NV_GSYNC_CONTROL_PARAMS_V2;
pub type NV_GSYNC_CONTROL_PARAMS = NV_GSYNC_CONTROL_PARAMS_V2;
impl _NVAPI_GSYNC_DELAY_TYPE {
    pub const NVAPI_GSYNC_DELAY_TYPE_UNKNOWN: _NVAPI_GSYNC_DELAY_TYPE = _NVAPI_GSYNC_DELAY_TYPE(0);
}
impl _NVAPI_GSYNC_DELAY_TYPE {
    pub const NVAPI_GSYNC_DELAY_TYPE_SYNC_SKEW: _NVAPI_GSYNC_DELAY_TYPE =
        _NVAPI_GSYNC_DELAY_TYPE(1);
}
impl _NVAPI_GSYNC_DELAY_TYPE {
    pub const NVAPI_GSYNC_DELAY_TYPE_STARTUP: _NVAPI_GSYNC_DELAY_TYPE = _NVAPI_GSYNC_DELAY_TYPE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_GSYNC_DELAY_TYPE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_GSYNC_DELAY_TYPE as NVAPI_GSYNC_DELAY_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_STATUS {
    pub version: NvU32,
    pub bIsSynced: NvU32,
    pub bIsStereoSynced: NvU32,
    pub bIsSyncSignalAvailable: NvU32,
}
pub type NV_GSYNC_STATUS = _NV_GSYNC_STATUS;
impl _NVAPI_GSYNC_RJ45_IO {
    pub const NVAPI_GSYNC_RJ45_OUTPUT: _NVAPI_GSYNC_RJ45_IO = _NVAPI_GSYNC_RJ45_IO(0);
}
impl _NVAPI_GSYNC_RJ45_IO {
    pub const NVAPI_GSYNC_RJ45_INPUT: _NVAPI_GSYNC_RJ45_IO = _NVAPI_GSYNC_RJ45_IO(1);
}
impl _NVAPI_GSYNC_RJ45_IO {
    pub const NVAPI_GSYNC_RJ45_UNUSED: _NVAPI_GSYNC_RJ45_IO = _NVAPI_GSYNC_RJ45_IO(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_GSYNC_RJ45_IO(pub ::std::os::raw::c_int);
pub use self::_NVAPI_GSYNC_RJ45_IO as NVAPI_GSYNC_RJ45_IO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_STATUS_PARAMS_V1 {
    pub version: NvU32,
    pub refreshRate: NvU32,
    pub RJ45_IO: [NVAPI_GSYNC_RJ45_IO; 2usize],
    pub RJ45_Ethernet: [NvU32; 2usize],
    pub houseSyncIncoming: NvU32,
    pub bHouseSync: NvU32,
}
pub type NV_GSYNC_STATUS_PARAMS_V1 = _NV_GSYNC_STATUS_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GSYNC_STATUS_PARAMS_V2 {
    pub version: NvU32,
    pub refreshRate: NvU32,
    pub RJ45_IO: [NVAPI_GSYNC_RJ45_IO; 2usize],
    pub RJ45_Ethernet: [NvU32; 2usize],
    pub houseSyncIncoming: NvU32,
    pub bHouseSync: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NV_GSYNC_STATUS_PARAMS_V2 {
    #[inline]
    pub fn bInternalSlave(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bInternalSlave(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bInternalSlave: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bInternalSlave: u32 = unsafe { ::std::mem::transmute(bInternalSlave) };
            bInternalSlave as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_GSYNC_STATUS_PARAMS_V2 = _NV_GSYNC_STATUS_PARAMS_V2;
pub type NV_GSYNC_STATUS_PARAMS = NV_GSYNC_STATUS_PARAMS_V2;
impl _NVAPI_D3D11_INSERTWFI_FLAG {
    pub const NVAPI_D3D_BEGIN_UAV_OVERLAP_NO_WFI: _NVAPI_D3D11_INSERTWFI_FLAG =
        _NVAPI_D3D11_INSERTWFI_FLAG(0);
}
impl _NVAPI_D3D11_INSERTWFI_FLAG {
    pub const NVAPI_D3D_BEGIN_UAV_OVERLAP_GFX_WFI: _NVAPI_D3D11_INSERTWFI_FLAG =
        _NVAPI_D3D11_INSERTWFI_FLAG(1);
}
impl _NVAPI_D3D11_INSERTWFI_FLAG {
    pub const NVAPI_D3D_BEGIN_UAV_OVERLAP_COMP_WFI: _NVAPI_D3D11_INSERTWFI_FLAG =
        _NVAPI_D3D11_INSERTWFI_FLAG(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D11_INSERTWFI_FLAG(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D11_INSERTWFI_FLAG as NVAPI_D3D11_INSERTWFI_FLAG;
impl NVAPI_VSYNC_MODE {
    pub const NVAPI_VSYNC_DEFAULT: NVAPI_VSYNC_MODE = NVAPI_VSYNC_MODE(0);
}
impl NVAPI_VSYNC_MODE {
    pub const NVAPI_VSYNC_OFF: NVAPI_VSYNC_MODE = NVAPI_VSYNC_MODE(1);
}
impl NVAPI_VSYNC_MODE {
    pub const NVAPI_VSYNC_ON: NVAPI_VSYNC_MODE = NVAPI_VSYNC_MODE(2);
}
impl NVAPI_VSYNC_MODE {
    pub const NVAPI_VSYNC_ADAPTIVE: NVAPI_VSYNC_MODE = NVAPI_VSYNC_MODE(3);
}
impl NVAPI_VSYNC_MODE {
    pub const NVAPI_VSYNC_ADAPTIVE_HALF_REFRESH_RATE: NVAPI_VSYNC_MODE = NVAPI_VSYNC_MODE(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NVAPI_VSYNC_MODE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_JOIN_PRESENT_BARRIER_PARAMS {
    pub dwVersion: NvU32,
}
pub type NV_JOIN_PRESENT_BARRIER_PARAMS = _NV_JOIN_PRESENT_BARRIER_PARAMS;
impl _NV_PRESENT_BARRIER_SYNC_MODE {
    pub const PRESENT_BARRIER_NOT_JOINED: _NV_PRESENT_BARRIER_SYNC_MODE =
        _NV_PRESENT_BARRIER_SYNC_MODE(0);
}
impl _NV_PRESENT_BARRIER_SYNC_MODE {
    pub const PRESENT_BARRIER_SYNC_CLIENT: _NV_PRESENT_BARRIER_SYNC_MODE =
        _NV_PRESENT_BARRIER_SYNC_MODE(1);
}
impl _NV_PRESENT_BARRIER_SYNC_MODE {
    pub const PRESENT_BARRIER_SYNC_SYSTEM: _NV_PRESENT_BARRIER_SYNC_MODE =
        _NV_PRESENT_BARRIER_SYNC_MODE(2);
}
impl _NV_PRESENT_BARRIER_SYNC_MODE {
    pub const PRESENT_BARRIER_SYNC_CLUSTER: _NV_PRESENT_BARRIER_SYNC_MODE =
        _NV_PRESENT_BARRIER_SYNC_MODE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_PRESENT_BARRIER_SYNC_MODE(pub ::std::os::raw::c_int);
pub use self::_NV_PRESENT_BARRIER_SYNC_MODE as NV_PRESENT_BARRIER_SYNC_MODE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PRESENT_BARRIER_FRAME_STATISTICS {
    pub dwVersion: NvU32,
    pub SyncMode: NV_PRESENT_BARRIER_SYNC_MODE,
    pub PresentCount: NvU32,
    pub PresentInSyncCount: NvU32,
    pub FlipInSyncCount: NvU32,
    pub RefreshCount: NvU32,
}
pub type NV_PRESENT_BARRIER_FRAME_STATISTICS = _NV_PRESENT_BARRIER_FRAME_STATISTICS;
impl NVAPI_QUAD_FILLMODE {
    pub const NVAPI_QUAD_FILLMODE_DISABLED: NVAPI_QUAD_FILLMODE = NVAPI_QUAD_FILLMODE(0);
}
impl NVAPI_QUAD_FILLMODE {
    pub const NVAPI_QUAD_FILLMODE_BBOX: NVAPI_QUAD_FILLMODE = NVAPI_QUAD_FILLMODE(1);
}
impl NVAPI_QUAD_FILLMODE {
    pub const NVAPI_QUAD_FILLMODE_FULL_VIEWPORT: NVAPI_QUAD_FILLMODE = NVAPI_QUAD_FILLMODE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NVAPI_QUAD_FILLMODE(pub ::std::os::raw::c_int);
#[repr(C)]
pub struct NvAPI_D3D11_RASTERIZER_DESC_EX {
    pub FillMode: D3D11_FILL_MODE,
    pub CullMode: D3D11_CULL_MODE,
    pub FrontCounterClockwise: BOOL,
    pub DepthBias: INT,
    pub DepthBiasClamp: FLOAT,
    pub SlopeScaledDepthBias: FLOAT,
    pub DepthClipEnable: BOOL,
    pub ScissorEnable: BOOL,
    pub MultisampleEnable: BOOL,
    pub AntialiasedLineEnable: BOOL,
    pub ForcedSampleCount: NvU32,
    pub ProgrammableSamplePositionsEnable: bool,
    pub InterleavedSamplingEnable: bool,
    pub SampleCount: NvU8,
    pub SamplePositionsX: [NvU8; 16usize],
    pub SamplePositionsY: [NvU8; 16usize],
    pub ConservativeRasterEnable: bool,
    pub QuadFillMode: NVAPI_QUAD_FILLMODE,
    pub PostZCoverageEnable: bool,
    pub CoverageToColorEnable: bool,
    pub CoverageToColorRTIndex: NvU8,
    pub TargetIndependentRasterWithDepth: bool,
    pub reserved: [NvU8; 63usize],
}
impl _NVAPI_ANSEL_FEATURE {
    pub const NVAPI_ANSEL_FEATURE_UNKNOWN: _NVAPI_ANSEL_FEATURE = _NVAPI_ANSEL_FEATURE(0);
}
impl _NVAPI_ANSEL_FEATURE {
    pub const NVAPI_ANSEL_FEATURE_BLACK_AND_WHITE: _NVAPI_ANSEL_FEATURE = _NVAPI_ANSEL_FEATURE(1);
}
impl _NVAPI_ANSEL_FEATURE {
    pub const NVAPI_ANSEL_FEATURE_HUDLESS: _NVAPI_ANSEL_FEATURE = _NVAPI_ANSEL_FEATURE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_ANSEL_FEATURE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_ANSEL_FEATURE as NVAPI_ANSEL_FEATURE;
impl _NVAPI_ANSEL_FEATURE_STATE {
    pub const NVAPI_ANSEL_FEATURE_STATE_UNKNOWN: _NVAPI_ANSEL_FEATURE_STATE =
        _NVAPI_ANSEL_FEATURE_STATE(0);
}
impl _NVAPI_ANSEL_FEATURE_STATE {
    pub const NVAPI_ANSEL_FEATURE_STATE_ENABLE: _NVAPI_ANSEL_FEATURE_STATE =
        _NVAPI_ANSEL_FEATURE_STATE(1);
}
impl _NVAPI_ANSEL_FEATURE_STATE {
    pub const NVAPI_ANSEL_FEATURE_STATE_DISABLE: _NVAPI_ANSEL_FEATURE_STATE =
        _NVAPI_ANSEL_FEATURE_STATE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_ANSEL_FEATURE_STATE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_ANSEL_FEATURE_STATE as NVAPI_ANSEL_FEATURE_STATE;
impl _NVAPI_ANSEL_HOTKEY_MODIFIER {
    pub const NVAPI_ANSEL_HOTKEY_MODIFIER_UNKNOWN: _NVAPI_ANSEL_HOTKEY_MODIFIER =
        _NVAPI_ANSEL_HOTKEY_MODIFIER(0);
}
impl _NVAPI_ANSEL_HOTKEY_MODIFIER {
    pub const NVAPI_ANSEL_HOTKEY_MODIFIER_CTRL: _NVAPI_ANSEL_HOTKEY_MODIFIER =
        _NVAPI_ANSEL_HOTKEY_MODIFIER(1);
}
impl _NVAPI_ANSEL_HOTKEY_MODIFIER {
    pub const NVAPI_ANSEL_HOTKEY_MODIFIER_SHIFT: _NVAPI_ANSEL_HOTKEY_MODIFIER =
        _NVAPI_ANSEL_HOTKEY_MODIFIER(2);
}
impl _NVAPI_ANSEL_HOTKEY_MODIFIER {
    pub const NVAPI_ANSEL_HOTKEY_MODIFIER_ALT: _NVAPI_ANSEL_HOTKEY_MODIFIER =
        _NVAPI_ANSEL_HOTKEY_MODIFIER(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_ANSEL_HOTKEY_MODIFIER(pub ::std::os::raw::c_int);
pub use self::_NVAPI_ANSEL_HOTKEY_MODIFIER as NVAPI_ANSEL_HOTKEY_MODIFIER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_ANSEL_FEATURE_CONFIGURATION_STRUCT {
    pub featureId: NVAPI_ANSEL_FEATURE,
    pub featureState: NVAPI_ANSEL_FEATURE_STATE,
    pub hotkey: UINT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_ANSEL_CONFIGURATION_STRUCT_V1 {
    pub version: NvU32,
    pub hotkeyModifier: NVAPI_ANSEL_HOTKEY_MODIFIER,
    pub keyEnable: UINT,
    pub numAnselFeatures: UINT,
    pub pAnselFeatures: *mut NVAPI_ANSEL_FEATURE_CONFIGURATION_STRUCT,
}
pub type NVAPI_ANSEL_CONFIGURATION_STRUCT = NVAPI_ANSEL_CONFIGURATION_STRUCT_V1;
impl _NV_D3D11_FEATURE {
    pub const NV_D3D11_FEATURE_RASTERIZER: _NV_D3D11_FEATURE = _NV_D3D11_FEATURE(0);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_D3D11_FEATURE(pub ::std::os::raw::c_int);
pub use self::_NV_D3D11_FEATURE as NV_D3D11_FEATURE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D11_FEATURE_DATA_RASTERIZER_SUPPORT {
    pub TargetIndependentRasterWithDepth: BOOL,
    pub ProgrammableSamplePositions: BOOL,
    pub InterleavedSampling: BOOL,
    pub ConservativeRaster: BOOL,
    pub PostZCoverage: BOOL,
    pub CoverageToColor: BOOL,
}
pub type NV_D3D11_FEATURE_DATA_RASTERIZER_SUPPORT = _NV_D3D11_FEATURE_DATA_RASTERIZER_SUPPORT;
impl _NV_RESOLVE_MODE {
    pub const NV_RESOLVE_MODE_SAMPLE_0: _NV_RESOLVE_MODE = _NV_RESOLVE_MODE(0);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_RESOLVE_MODE(pub ::std::os::raw::c_int);
pub use self::_NV_RESOLVE_MODE as NV_RESOLVE_MODE;
pub type NvAPI_D3D11_SWIZZLE_MODE = UINT;
impl _NV_SWIZZLE_MODE {
    pub const NV_SWIZZLE_POS_X: _NV_SWIZZLE_MODE = _NV_SWIZZLE_MODE(0);
}
impl _NV_SWIZZLE_MODE {
    pub const NV_SWIZZLE_NEG_X: _NV_SWIZZLE_MODE = _NV_SWIZZLE_MODE(1);
}
impl _NV_SWIZZLE_MODE {
    pub const NV_SWIZZLE_POS_Y: _NV_SWIZZLE_MODE = _NV_SWIZZLE_MODE(2);
}
impl _NV_SWIZZLE_MODE {
    pub const NV_SWIZZLE_NEG_Y: _NV_SWIZZLE_MODE = _NV_SWIZZLE_MODE(3);
}
impl _NV_SWIZZLE_MODE {
    pub const NV_SWIZZLE_POS_Z: _NV_SWIZZLE_MODE = _NV_SWIZZLE_MODE(4);
}
impl _NV_SWIZZLE_MODE {
    pub const NV_SWIZZLE_NEG_Z: _NV_SWIZZLE_MODE = _NV_SWIZZLE_MODE(5);
}
impl _NV_SWIZZLE_MODE {
    pub const NV_SWIZZLE_POS_W: _NV_SWIZZLE_MODE = _NV_SWIZZLE_MODE(6);
}
impl _NV_SWIZZLE_MODE {
    pub const NV_SWIZZLE_NEG_W: _NV_SWIZZLE_MODE = _NV_SWIZZLE_MODE(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_SWIZZLE_MODE(pub ::std::os::raw::c_int);
pub use self::_NV_SWIZZLE_MODE as NV_SWIZZLE_MODE;
impl _NV_SWIZZLE_OFFSET {
    pub const NV_SWIZZLE_OFFSET_X: _NV_SWIZZLE_OFFSET = _NV_SWIZZLE_OFFSET(0);
}
impl _NV_SWIZZLE_OFFSET {
    pub const NV_SWIZZLE_OFFSET_Y: _NV_SWIZZLE_OFFSET = _NV_SWIZZLE_OFFSET(4);
}
impl _NV_SWIZZLE_OFFSET {
    pub const NV_SWIZZLE_OFFSET_Z: _NV_SWIZZLE_OFFSET = _NV_SWIZZLE_OFFSET(8);
}
impl _NV_SWIZZLE_OFFSET {
    pub const NV_SWIZZLE_OFFSET_W: _NV_SWIZZLE_OFFSET = _NV_SWIZZLE_OFFSET(12);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_SWIZZLE_OFFSET(pub ::std::os::raw::c_int);
pub use self::_NV_SWIZZLE_OFFSET as NV_SWIZZLE_OFFSET;
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_NONE_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(0);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_X_RIGHT_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(1);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_VIEWPORT_MASK_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(2);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_XYZW_RIGHT_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(3);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_VIEWPORT_MASK_2_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(4);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_POSITION_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(5);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_CLIP_DISTANCE_0_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(6);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_CLIP_DISTANCE_1_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(7);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_CULL_DISTANCE_0_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(8);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_CULL_DISTANCE_1_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(9);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_GENERIC_ATTRIBUTE_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(10);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_PACKED_EYE_INDEX_SEMANTIC: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(17);
}
impl NV_CUSTOM_SEMANTIC_TYPE {
    pub const NV_CUSTOM_SEMANTIC_MAX: NV_CUSTOM_SEMANTIC_TYPE = NV_CUSTOM_SEMANTIC_TYPE(32);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_CUSTOM_SEMANTIC_TYPE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_CUSTOM_SEMANTIC {
    pub version: UINT,
    pub NVCustomSemanticType: NV_CUSTOM_SEMANTIC_TYPE,
    pub NVCustomSemanticNameString: NvAPI_LongString,
    pub RegisterSpecified: BOOL,
    pub RegisterNum: NvU32,
    pub RegisterMask: NvU32,
    pub Reserved: NvU32,
}
pub type NV_CUSTOM_SEMANTIC = _NV_CUSTOM_SEMANTIC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX_V5 {
    pub version: UINT,
    pub UseViewportMask: BOOL,
    pub OffsetRtIndexByVpIndex: BOOL,
    pub ForceFastGS: BOOL,
    pub DontUseViewportOrder: BOOL,
    pub UseAttributeSkipMask: BOOL,
    pub UseCoordinateSwizzle: BOOL,
    pub pCoordinateSwizzling: *mut NvAPI_D3D11_SWIZZLE_MODE,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub ConvertToFastGS: BOOL,
    pub UseSpecificShaderExt: BOOL,
}
pub type NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX = NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX_V5;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V1 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V2 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub UseWithFastGS: BOOL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V3 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub UseWithFastGS: BOOL,
    pub UseSpecificShaderExt: BOOL,
}
pub type NvAPI_D3D11_CREATE_VERTEX_SHADER_EX = NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_HULL_SHADER_EX_V1 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub UseWithFastGS: BOOL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_HULL_SHADER_EX_V2 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub UseWithFastGS: BOOL,
    pub UseSpecificShaderExt: BOOL,
}
pub type NvAPI_D3D11_CREATE_HULL_SHADER_EX = NvAPI_D3D11_CREATE_HULL_SHADER_EX_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V1 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V2 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub UseWithFastGS: BOOL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V3 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub UseWithFastGS: BOOL,
    pub UseSpecificShaderExt: BOOL,
}
pub type NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX = NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V1 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V2 {
    pub version: UINT,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V2 {
    #[inline]
    pub fn bEnableSuperSamplingPredicationForVRS(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bEnableSuperSamplingPredicationForVRS(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bEnableSuperSamplingPredicationForVRSAllAttributes(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bEnableSuperSamplingPredicationForVRSAllAttributes(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bEnableSuperSamplingPredicationForVRS: NvU32,
        bEnableSuperSamplingPredicationForVRSAllAttributes: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bEnableSuperSamplingPredicationForVRS: u32 =
                unsafe { ::std::mem::transmute(bEnableSuperSamplingPredicationForVRS) };
            bEnableSuperSamplingPredicationForVRS as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bEnableSuperSamplingPredicationForVRSAllAttributes: u32 = unsafe {
                ::std::mem::transmute(bEnableSuperSamplingPredicationForVRSAllAttributes)
            };
            bEnableSuperSamplingPredicationForVRSAllAttributes as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NvAPI_D3D11_CREATE_PIXEL_SHADER_EX = NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V2;
impl _NV_FASTGS_FLAGS {
    pub const NV_FASTGS_USE_VIEWPORT_MASK: _NV_FASTGS_FLAGS = _NV_FASTGS_FLAGS(1);
}
impl _NV_FASTGS_FLAGS {
    pub const NV_FASTGS_OFFSET_RT_INDEX_BY_VP_INDEX: _NV_FASTGS_FLAGS = _NV_FASTGS_FLAGS(2);
}
impl _NV_FASTGS_FLAGS {
    pub const NV_FASTGS_STRICT_API_ORDER: _NV_FASTGS_FLAGS = _NV_FASTGS_FLAGS(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_FASTGS_FLAGS(pub ::std::os::raw::c_int);
pub use self::_NV_FASTGS_FLAGS as NV_FASTGS_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvAPI_D3D11_CREATE_FASTGS_EXPLICIT_DESC_V1 {
    pub version: NvU32,
    pub flags: NvU32,
    pub pCoordinateSwizzling: *mut NvAPI_D3D11_SWIZZLE_MODE,
}
pub type NvAPI_D3D11_CREATE_FASTGS_EXPLICIT_DESC = NvAPI_D3D11_CREATE_FASTGS_EXPLICIT_DESC_V1;
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_RASTER_EXTENSION: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(0);
}
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_REQUEST_FASTGS_EXTENSION: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(1);
}
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_GEOMETRY_SHADER_EXTENSION: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(2);
}
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_ENABLE_DEPTH_BOUND_TEST_EXTENSION: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(3);
}
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_EXPLICIT_FASTGS_EXTENSION: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(4);
}
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_SET_SHADER_EXTNENSION_SLOT_AND_SPACE: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(5);
}
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_SET_SHADER_EXTENSION_SLOT_AND_SPACE: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(5);
}
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_VERTEX_SHADER_EXTENSION: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(6);
}
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_DOMAIN_SHADER_EXTENSION: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(7);
}
impl _NV_PSO_EXTENSION {
    pub const NV_PSO_HULL_SHADER_EXTENSION: _NV_PSO_EXTENSION = _NV_PSO_EXTENSION(9);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_PSO_EXTENSION(pub ::std::os::raw::c_int);
pub use self::_NV_PSO_EXTENSION as NV_PSO_EXTENSION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_EXTENSION_DESC_V1 {
    pub baseVersion: NvU32,
    pub psoExtension: NV_PSO_EXTENSION,
}
pub type NVAPI_D3D12_PSO_EXTENSION_DESC = NVAPI_D3D12_PSO_EXTENSION_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_RASTERIZER_STATE_DESC_V1 {
    pub _base: NVAPI_D3D12_PSO_EXTENSION_DESC,
    pub version: NvU32,
    pub ProgrammableSamplePositionsEnable: bool,
    pub InterleavedSamplingEnable: bool,
    pub SampleCount: NvU8,
    pub SamplePositionsX: [NvU8; 16usize],
    pub SamplePositionsY: [NvU8; 16usize],
    pub QuadFillMode: NVAPI_QUAD_FILLMODE,
    pub PostZCoverageEnable: bool,
    pub CoverageToColorEnable: bool,
    pub CoverageToColorRTIndex: NvU8,
    pub TargetIndependentRasterWithDepth: bool,
    pub ForcedSampleCount: NvU8,
    pub reserved: [NvU8; 62usize],
}
pub type NVAPI_D3D12_PSO_RASTERIZER_STATE_DESC = NVAPI_D3D12_PSO_RASTERIZER_STATE_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_CREATE_FASTGS_EXPLICIT_DESC_V1 {
    pub _base: NVAPI_D3D12_PSO_EXTENSION_DESC,
    pub version: NvU32,
    pub flags: NvU32,
    pub pCoordinateSwizzling: *mut NvAPI_D3D11_SWIZZLE_MODE,
}
pub type NVAPI_D3D12_PSO_CREATE_FASTGS_EXPLICIT_DESC =
    NVAPI_D3D12_PSO_CREATE_FASTGS_EXPLICIT_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_REQUEST_FAST_GEOMETRY_SHADER_DESC_V1 {
    pub _base: NVAPI_D3D12_PSO_EXTENSION_DESC,
    pub version: NvU32,
}
pub type NVAPI_D3D12_PSO_REQUEST_FAST_GEOMETRY_SHADER_DESC =
    NVAPI_D3D12_PSO_REQUEST_FAST_GEOMETRY_SHADER_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_GEOMETRY_SHADER_DESC_V5 {
    pub _base: NVAPI_D3D12_PSO_EXTENSION_DESC,
    pub version: NvU32,
    pub UseViewportMask: BOOL,
    pub OffsetRtIndexByVpIndex: BOOL,
    pub ForceFastGS: BOOL,
    pub DontUseViewportOrder: BOOL,
    pub UseAttributeSkipMask: BOOL,
    pub UseCoordinateSwizzle: BOOL,
    pub pCoordinateSwizzling: *mut NvAPI_D3D11_SWIZZLE_MODE,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub ConvertToFastGS: BOOL,
    pub UseSpecificShaderExt: BOOL,
}
pub type NVAPI_D3D12_PSO_GEOMETRY_SHADER_DESC = NVAPI_D3D12_PSO_GEOMETRY_SHADER_DESC_V5;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V1 {
    pub _base: NVAPI_D3D12_PSO_EXTENSION_DESC,
    pub version: NvU32,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V2 {
    pub _base: NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V1,
    pub UseWithFastGS: BOOL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V3 {
    pub _base: NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V2,
    pub UseSpecificShaderExt: BOOL,
}
pub type NVAPI_D3D12_PSO_VERTEX_SHADER_DESC = NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_HULL_SHADER_DESC_V1 {
    pub _base: NVAPI_D3D12_PSO_EXTENSION_DESC,
    pub version: NvU32,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
    pub UseWithFastGS: BOOL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_HULL_SHADER_DESC_V2 {
    pub _base: NVAPI_D3D12_PSO_HULL_SHADER_DESC_V1,
    pub UseSpecificShaderExt: BOOL,
}
pub type NVAPI_D3D12_PSO_HULL_SHADER_DESC = NVAPI_D3D12_PSO_HULL_SHADER_DESC_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V1 {
    pub _base: NVAPI_D3D12_PSO_EXTENSION_DESC,
    pub version: NvU32,
    pub NumCustomSemantics: NvU32,
    pub pCustomSemantics: *mut NV_CUSTOM_SEMANTIC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V2 {
    pub _base: NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V1,
    pub UseWithFastGS: BOOL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V3 {
    pub _base: NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V2,
    pub UseSpecificShaderExt: BOOL,
}
pub type NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC = NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_ENABLE_DEPTH_BOUND_TEST_DESC_V1 {
    pub _base: NVAPI_D3D12_PSO_EXTENSION_DESC,
    pub version: NvU32,
    pub EnableDBT: bool,
}
pub type NVAPI_D3D12_PSO_ENABLE_DEPTH_BOUND_TEST_DESC =
    NVAPI_D3D12_PSO_ENABLE_DEPTH_BOUND_TEST_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_D3D12_PSO_SET_SHADER_EXTENSION_SLOT_DESC_V1 {
    pub _base: NVAPI_D3D12_PSO_EXTENSION_DESC,
    pub version: NvU32,
    pub uavSlot: NvU32,
    pub registerSpace: NvU32,
}
pub type NVAPI_D3D12_PSO_SET_SHADER_EXTENSION_SLOT_DESC =
    NVAPI_D3D12_PSO_SET_SHADER_EXTENSION_SLOT_DESC_V1;
impl _NV_COMPUTE_SHADER_DERIVATIVES {
    pub const NV_COMPUTE_SHADER_DERIVATIVE_NONE: _NV_COMPUTE_SHADER_DERIVATIVES =
        _NV_COMPUTE_SHADER_DERIVATIVES(0);
}
impl _NV_COMPUTE_SHADER_DERIVATIVES {
    pub const NV_COMPUTE_SHADER_DERIVATIVE_GROUP_LINEAR: _NV_COMPUTE_SHADER_DERIVATIVES =
        _NV_COMPUTE_SHADER_DERIVATIVES(1);
}
impl _NV_COMPUTE_SHADER_DERIVATIVES {
    pub const NV_COMPUTE_SHADER_DERIVATIVE_GROUP_QUADS: _NV_COMPUTE_SHADER_DERIVATIVES =
        _NV_COMPUTE_SHADER_DERIVATIVES(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_COMPUTE_SHADER_DERIVATIVES(pub ::std::os::raw::c_int);
pub use self::_NV_COMPUTE_SHADER_DERIVATIVES as NV_COMPUTE_SHADER_DERIVATIVES;
impl NV_D3D12_HEAP_FLAGS {
    pub const NV_D3D12_HEAP_FLAG_NONE: NV_D3D12_HEAP_FLAGS = NV_D3D12_HEAP_FLAGS(0);
}
impl NV_D3D12_HEAP_FLAGS {
    pub const NV_D3D12_HEAP_FLAG_CPUVISIBLE_VIDMEM: NV_D3D12_HEAP_FLAGS = NV_D3D12_HEAP_FLAGS(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_D3D12_HEAP_FLAGS(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_HEAP_PARAMS_V1 {
    pub version: NvU32,
    pub NVHeapFlags: NV_D3D12_HEAP_FLAGS,
}
pub type NV_HEAP_PARAMS_V1 = _NV_HEAP_PARAMS_V1;
pub type NV_HEAP_PARAMS = NV_HEAP_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_UAV_INFO_V1 {
    pub version: NvU32,
    pub surfaceHandle: NvU32,
    pub gpuVAStart: NvU64,
    pub gpuVASize: NvU64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVAPI_UAV_INFO_V2 {
    pub version: NvU32,
    pub surfaceHandle: NvU32,
    pub gpuVAStart: NvU64,
    pub gpuVASize: NvU64,
    pub outFlags: NvU64,
}
pub type NVAPI_UAV_INFO = NVAPI_UAV_INFO_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_GET_GPU_VIRTUAL_ADDRESS_V1 {
    pub version: NvU32,
    pub hResource: NVDX_ObjectHandle,
    pub gpuVAStart: NvU64,
    pub gpuVASize: NvU64,
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_NONE: NV_D3D_GRAPHICS_STATES = NV_D3D_GRAPHICS_STATES(0);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_IA_VERTEX_BUFFERS: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(1);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_IA_INDEX_BUFFER: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(2);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_IA_PRIMITIVE_TOPOLOGY: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(4);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_DESCRIPTOR_HEAP: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(8);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_GRAPHICS_ROOT_SIGNATURE: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(16);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_COMPUTE_ROOT_SIGNATURE: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(32);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_RS_VIEWPORTS: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(64);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_RS_SCISSOR_RECTS: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(128);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_PREDICATION: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(256);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_OM_RENDER_TARGETS: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(512);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_OM_STENCIL_REF: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(1024);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_OM_BLEND_FACTOR: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(2048);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_PIPELINE_STATE: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(4096);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_SO_TARGETS: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(8192);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_OM_DEPTH_BOUNDS: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(16384);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_SAMPLE_POSITIONS: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(32768);
}
impl NV_D3D_GRAPHICS_STATES {
    pub const NV_D3D_GRAPHICS_STATE_VIEW_INSTANCE_MASK: NV_D3D_GRAPHICS_STATES =
        NV_D3D_GRAPHICS_STATES(65536);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_D3D_GRAPHICS_STATES(pub ::std::os::raw::c_int);
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NVAPI_META_COMMAND_DESC {
    pub Id: GUID,
    pub Name: LPCWSTR,
    pub InitializationDirtyState: NV_D3D_GRAPHICS_STATES,
    pub ExecutionDirtyState: NV_D3D_GRAPHICS_STATES,
}
pub type NV_META_COMMAND_BOOL = NvU64;
impl NV_META_COMMAND_TENSOR_DATA_TYPE {
    pub const NV_META_COMMAND_TENSOR_DATA_TYPE_FLOAT32: NV_META_COMMAND_TENSOR_DATA_TYPE =
        NV_META_COMMAND_TENSOR_DATA_TYPE(0);
}
impl NV_META_COMMAND_TENSOR_DATA_TYPE {
    pub const NV_META_COMMAND_TENSOR_DATA_TYPE_FLOAT16: NV_META_COMMAND_TENSOR_DATA_TYPE =
        NV_META_COMMAND_TENSOR_DATA_TYPE(1);
}
impl NV_META_COMMAND_TENSOR_DATA_TYPE {
    pub const NV_META_COMMAND_TENSOR_DATA_TYPE_UINT32: NV_META_COMMAND_TENSOR_DATA_TYPE =
        NV_META_COMMAND_TENSOR_DATA_TYPE(2);
}
impl NV_META_COMMAND_TENSOR_DATA_TYPE {
    pub const NV_META_COMMAND_TENSOR_DATA_TYPE_COUNT: NV_META_COMMAND_TENSOR_DATA_TYPE =
        NV_META_COMMAND_TENSOR_DATA_TYPE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_TENSOR_DATA_TYPE(pub NvU64);
impl NV_META_COMMAND_TENSOR_LAYOUT {
    pub const NV_META_COMMAND_TENSOR_LAYOUT_UNKNOWN: NV_META_COMMAND_TENSOR_LAYOUT =
        NV_META_COMMAND_TENSOR_LAYOUT(0);
}
impl NV_META_COMMAND_TENSOR_LAYOUT {
    pub const NV_META_COMMAND_TENSOR_LAYOUT_STANDARD: NV_META_COMMAND_TENSOR_LAYOUT =
        NV_META_COMMAND_TENSOR_LAYOUT(1);
}
impl NV_META_COMMAND_TENSOR_LAYOUT {
    pub const NV_META_COMMAND_TENSOR_LAYOUT_COUNT: NV_META_COMMAND_TENSOR_LAYOUT =
        NV_META_COMMAND_TENSOR_LAYOUT(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_TENSOR_LAYOUT(pub NvU64);
impl NV_META_COMMAND_TENSOR_FLAGS {
    pub const NV_META_COMMAND_TENSOR_FLAG_NONE: NV_META_COMMAND_TENSOR_FLAGS =
        NV_META_COMMAND_TENSOR_FLAGS(0);
}
impl NV_META_COMMAND_TENSOR_FLAGS {
    pub const NV_META_COMMAND_TENSOR_FLAG_DATA_STATIC: NV_META_COMMAND_TENSOR_FLAGS =
        NV_META_COMMAND_TENSOR_FLAGS(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_TENSOR_FLAGS(pub NvU64);
impl NV_META_COMMAND_PRECISION {
    pub const NV_META_COMMAND_PRECISION_FLOAT32: NV_META_COMMAND_PRECISION =
        NV_META_COMMAND_PRECISION(0);
}
impl NV_META_COMMAND_PRECISION {
    pub const NV_META_COMMAND_PRECISION_FLOAT16: NV_META_COMMAND_PRECISION =
        NV_META_COMMAND_PRECISION(1);
}
impl NV_META_COMMAND_PRECISION {
    pub const NV_META_COMMAND_PRECISION_MUL_FLOAT16_ADD_FLOAT32: NV_META_COMMAND_PRECISION =
        NV_META_COMMAND_PRECISION(2);
}
impl NV_META_COMMAND_PRECISION {
    pub const NV_META_COMMAND_PRECISION_COUNT: NV_META_COMMAND_PRECISION =
        NV_META_COMMAND_PRECISION(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_PRECISION(pub NvU64);
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_META_COMMAND_TENSOR_DESC {
    pub DataType: NV_META_COMMAND_TENSOR_DATA_TYPE,
    pub Layout: NV_META_COMMAND_TENSOR_LAYOUT,
    pub Flags: NV_META_COMMAND_TENSOR_FLAGS,
    pub DimensionCount: NvU64,
    pub Size: [NvU64; 5usize],
    pub Stride: [NvU64; 5usize],
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_ELU: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(0);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_HARDMAX: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(1);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_HARD_SIGMOID:
        NV_META_COMMAND_ACTIVATION_FUNCTION = NV_META_COMMAND_ACTIVATION_FUNCTION(2);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_IDENTITY: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(3);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_LEAKY_RELU: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(4);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_LINEAR: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(5);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_LOG_SOFTMAX: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(6);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_PARAMETERIZED_RELU:
        NV_META_COMMAND_ACTIVATION_FUNCTION = NV_META_COMMAND_ACTIVATION_FUNCTION(7);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_PARAMETRIC_SOFTPLUS:
        NV_META_COMMAND_ACTIVATION_FUNCTION = NV_META_COMMAND_ACTIVATION_FUNCTION(8);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_RELU: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(9);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_SCALED_ELU: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(10);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_SCALED_TANH: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(11);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_SIGMOID: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(12);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_SOFTMAX: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(13);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_SOFTPLUS: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(14);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_SOFTSIGN: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(15);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_TANH: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(16);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_THRESHOLDED_RELU:
        NV_META_COMMAND_ACTIVATION_FUNCTION = NV_META_COMMAND_ACTIVATION_FUNCTION(17);
}
impl NV_META_COMMAND_ACTIVATION_FUNCTION {
    pub const NV_META_COMMAND_ACTIVATION_FUNCTION_COUNT: NV_META_COMMAND_ACTIVATION_FUNCTION =
        NV_META_COMMAND_ACTIVATION_FUNCTION(18);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_ACTIVATION_FUNCTION(pub NvU64);
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_META_COMMAND_ACTIVATION_DESC {
    pub Function: NV_META_COMMAND_ACTIVATION_FUNCTION,
    pub Params: [f32; 2usize],
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_META_COMMAND_OPTIONAL_TENSOR_DESC {
    pub _base: NV_META_COMMAND_TENSOR_DESC,
    pub IsNull: NV_META_COMMAND_BOOL,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_META_COMMAND_OPTIONAL_ACTIVATION_DESC {
    pub _base: NV_META_COMMAND_ACTIVATION_DESC,
    pub IsNull: NV_META_COMMAND_BOOL,
}
impl NV_META_COMMAND_PADDING_MODE {
    pub const NV_META_COMMAND_PADDING_ZEROS: NV_META_COMMAND_PADDING_MODE =
        NV_META_COMMAND_PADDING_MODE(0);
}
impl NV_META_COMMAND_PADDING_MODE {
    pub const NV_META_COMMAND_PADDING_MIRROR: NV_META_COMMAND_PADDING_MODE =
        NV_META_COMMAND_PADDING_MODE(1);
}
impl NV_META_COMMAND_PADDING_MODE {
    pub const NV_META_COMMAND_PADDING_CLAMP: NV_META_COMMAND_PADDING_MODE =
        NV_META_COMMAND_PADDING_MODE(2);
}
impl NV_META_COMMAND_PADDING_MODE {
    pub const NV_META_COMMAND_PADDING_CONSTANT: NV_META_COMMAND_PADDING_MODE =
        NV_META_COMMAND_PADDING_MODE(3);
}
impl NV_META_COMMAND_PADDING_MODE {
    pub const NV_META_COMMAND_PADDING_COUNT: NV_META_COMMAND_PADDING_MODE =
        NV_META_COMMAND_PADDING_MODE(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_PADDING_MODE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_META_COMMAND_PADDING_DESC {
    pub Mode: NV_META_COMMAND_PADDING_MODE,
    pub ConstantPadVal: f32,
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_INPUT: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(0);
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_OUTPUT: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(1);
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_FILTER: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(2);
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_WEIGHT: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(2);
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_BIAS: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(3);
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_MATRIX_A: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(0);
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_MATRIX_B: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(2);
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_MATRIX_C: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(3);
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_PERSISTENT: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(4);
}
impl NV_META_COMMAND_RESOURCE_TYPE {
    pub const NV_META_COMMAND_RESOURCE_TYPE_TEMPORARY: NV_META_COMMAND_RESOURCE_TYPE =
        NV_META_COMMAND_RESOURCE_TYPE(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_RESOURCE_TYPE(pub ::std::os::raw::c_int);
impl NV_META_COMMAND_CONVOLUTION_DIRECTION {
    pub const NV_META_COMMAND_CONVOLUTION_DIRECTION_FORWARD: NV_META_COMMAND_CONVOLUTION_DIRECTION =
        NV_META_COMMAND_CONVOLUTION_DIRECTION(0);
}
impl NV_META_COMMAND_CONVOLUTION_DIRECTION {
    pub const NV_META_COMMAND_CONVOLUTION_DIRECTION_BACKWARD:
        NV_META_COMMAND_CONVOLUTION_DIRECTION = NV_META_COMMAND_CONVOLUTION_DIRECTION(1);
}
impl NV_META_COMMAND_CONVOLUTION_DIRECTION {
    pub const NV_META_COMMAND_CONVOLUTION_DIRECTION_COUNT: NV_META_COMMAND_CONVOLUTION_DIRECTION =
        NV_META_COMMAND_CONVOLUTION_DIRECTION(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_CONVOLUTION_DIRECTION(pub NvU64);
impl NV_META_COMMAND_CONVOLUTION_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_MODE_CONVOLUTION: NV_META_COMMAND_CONVOLUTION_MODE =
        NV_META_COMMAND_CONVOLUTION_MODE(0);
}
impl NV_META_COMMAND_CONVOLUTION_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_MODE_CROSS_CORRELATION: NV_META_COMMAND_CONVOLUTION_MODE =
        NV_META_COMMAND_CONVOLUTION_MODE(1);
}
impl NV_META_COMMAND_CONVOLUTION_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_MODE_COUNT: NV_META_COMMAND_CONVOLUTION_MODE =
        NV_META_COMMAND_CONVOLUTION_MODE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_CONVOLUTION_MODE(pub NvU64);
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_META_COMMAND_CREATE_CONVOLUTION_EX_DESC {
    pub DescIn: NV_META_COMMAND_TENSOR_DESC,
    pub DescFilter: NV_META_COMMAND_TENSOR_DESC,
    pub DescBias: NV_META_COMMAND_OPTIONAL_TENSOR_DESC,
    pub DescOut: NV_META_COMMAND_TENSOR_DESC,
    pub Mode: NV_META_COMMAND_CONVOLUTION_MODE,
    pub Direction: NV_META_COMMAND_CONVOLUTION_DIRECTION,
    pub Precision: NV_META_COMMAND_PRECISION,
    pub Activation: NV_META_COMMAND_OPTIONAL_ACTIVATION_DESC,
    pub Padding: NV_META_COMMAND_PADDING_DESC,
    pub PerChannelScaling: NV_META_COMMAND_BOOL,
    pub Alpha1: f32,
    pub Alpha2: f32,
    pub Stride: [NvU64; 3usize],
    pub Dilation: [NvU64; 3usize],
    pub StartPadding: [NvU64; 3usize],
    pub EndPadding: [NvU64; 3usize],
    pub DimensionCount: NvU64,
    pub GroupCount: NvU64,
}
impl NV_META_COMMAND_CONVOLUTION_POOL_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_POOL_MODE_NONE: NV_META_COMMAND_CONVOLUTION_POOL_MODE =
        NV_META_COMMAND_CONVOLUTION_POOL_MODE(0);
}
impl NV_META_COMMAND_CONVOLUTION_POOL_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_POOL_MODE_REDUCTION_MAX:
        NV_META_COMMAND_CONVOLUTION_POOL_MODE = NV_META_COMMAND_CONVOLUTION_POOL_MODE(1);
}
impl NV_META_COMMAND_CONVOLUTION_POOL_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_POOL_MODE_REDUCTION_AVG:
        NV_META_COMMAND_CONVOLUTION_POOL_MODE = NV_META_COMMAND_CONVOLUTION_POOL_MODE(2);
}
impl NV_META_COMMAND_CONVOLUTION_POOL_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_POOL_MODE_REDUCTION_MIN:
        NV_META_COMMAND_CONVOLUTION_POOL_MODE = NV_META_COMMAND_CONVOLUTION_POOL_MODE(3);
}
impl NV_META_COMMAND_CONVOLUTION_POOL_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_POOL_MODE_COUNT: NV_META_COMMAND_CONVOLUTION_POOL_MODE =
        NV_META_COMMAND_CONVOLUTION_POOL_MODE(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_CONVOLUTION_POOL_MODE(pub ::std::os::raw::c_int);
impl NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE_NONE:
        NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE = NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE(0);
}
impl NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE_REPLICATE:
        NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE = NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE(1);
}
impl NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE_BILINEAR:
        NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE = NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE(2);
}
impl NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE_COUNT:
        NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE = NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE(pub ::std::os::raw::c_int);
impl NV_META_COMMAND_CONVOLUTION_SKIP_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_SKIP_MODE_NONE: NV_META_COMMAND_CONVOLUTION_SKIP_MODE =
        NV_META_COMMAND_CONVOLUTION_SKIP_MODE(0);
}
impl NV_META_COMMAND_CONVOLUTION_SKIP_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_SKIP_MODE_ADD: NV_META_COMMAND_CONVOLUTION_SKIP_MODE =
        NV_META_COMMAND_CONVOLUTION_SKIP_MODE(1);
}
impl NV_META_COMMAND_CONVOLUTION_SKIP_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_SKIP_MODE_CONCAT: NV_META_COMMAND_CONVOLUTION_SKIP_MODE =
        NV_META_COMMAND_CONVOLUTION_SKIP_MODE(2);
}
impl NV_META_COMMAND_CONVOLUTION_SKIP_MODE {
    pub const NV_META_COMMAND_CONVOLUTION_SKIP_MODE_COUNT: NV_META_COMMAND_CONVOLUTION_SKIP_MODE =
        NV_META_COMMAND_CONVOLUTION_SKIP_MODE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_CONVOLUTION_SKIP_MODE(pub ::std::os::raw::c_int);
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_META_COMMAND_CONVOLUTION_FUSE_DESC {
    pub PoolMode: NV_META_COMMAND_CONVOLUTION_POOL_MODE,
    pub UpsampleMode: NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE,
    pub SkipMode: NV_META_COMMAND_CONVOLUTION_SKIP_MODE,
    pub OutputPrepool: NV_META_COMMAND_BOOL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_META_COMMAND_CREATE_CONVOLUTION_EX_FUSED_DESC {
    pub _base: NV_META_COMMAND_CREATE_CONVOLUTION_EX_DESC,
    pub FuseDesc: NV_META_COMMAND_CONVOLUTION_FUSE_DESC,
}
impl NV_META_COMMAND_MATRIX_TRANSFORM {
    pub const NV_META_COMMAND_MATRIX_TRANSFORM_NONE: NV_META_COMMAND_MATRIX_TRANSFORM =
        NV_META_COMMAND_MATRIX_TRANSFORM(0);
}
impl NV_META_COMMAND_MATRIX_TRANSFORM {
    pub const NV_META_COMMAND_MATRIX_TRANSFORM_TRANSPOSE: NV_META_COMMAND_MATRIX_TRANSFORM =
        NV_META_COMMAND_MATRIX_TRANSFORM(1);
}
impl NV_META_COMMAND_MATRIX_TRANSFORM {
    pub const NV_META_COMMAND_MATRIX_TRANSFORM_COUNT: NV_META_COMMAND_MATRIX_TRANSFORM =
        NV_META_COMMAND_MATRIX_TRANSFORM(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_META_COMMAND_MATRIX_TRANSFORM(pub NvU64);
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_META_COMMAND_CREATE_GEMM_DESC {
    pub DescA: NV_META_COMMAND_TENSOR_DESC,
    pub DescB: NV_META_COMMAND_TENSOR_DESC,
    pub DescC: NV_META_COMMAND_OPTIONAL_TENSOR_DESC,
    pub DescOut: NV_META_COMMAND_TENSOR_DESC,
    pub Precision: NV_META_COMMAND_PRECISION,
    pub TransA: NV_META_COMMAND_MATRIX_TRANSFORM,
    pub TransB: NV_META_COMMAND_MATRIX_TRANSFORM,
    pub Alpha: f32,
    pub Beta: f32,
    pub Activation: NV_META_COMMAND_OPTIONAL_ACTIVATION_DESC,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_D3D11_META_COMMAND_RESOURCE {
    pub __bindgen_anon_1: NV_D3D11_META_COMMAND_RESOURCE__bindgen_ty_1,
    pub Offset: NvU64,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union NV_D3D11_META_COMMAND_RESOURCE__bindgen_ty_1 {
    pub ResourceHandle: NVDX_ObjectHandle,
    pub unused: NvU64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_D3D11_META_COMMAND_INITIALIZE_CONVOLUTION_EX_DESC {
    pub PersistentResource: NV_D3D11_META_COMMAND_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_D3D11_META_COMMAND_EXECUTE_CONVOLUTION_EX_DESC {
    pub InputResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub FilterResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub BiasResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub OutputResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub Alpha1Resource: NV_D3D11_META_COMMAND_RESOURCE,
    pub Alpha2Resource: NV_D3D11_META_COMMAND_RESOURCE,
    pub SkipConnectionResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub PersistentResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub TemporaryResource: NV_D3D11_META_COMMAND_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_D3D11_META_COMMAND_INITIALIZE_GEMM_DESC {
    pub PersistentResource: NV_D3D11_META_COMMAND_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_D3D11_META_COMMAND_EXECUTE_GEMM_DESC {
    pub AResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub BResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub CResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub OutputResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub PersistentResource: NV_D3D11_META_COMMAND_RESOURCE,
    pub TemporaryResource: NV_D3D11_META_COMMAND_RESOURCE,
}
#[repr(C, packed(4))]
pub struct NV_D3D12_META_COMMAND_INITIALIZE_CONVOLUTION_EX_DESC {
    pub PersistentResource: D3D12_GPU_VIRTUAL_ADDRESS,
}
#[repr(C, packed(4))]
pub struct NV_D3D12_META_COMMAND_EXECUTE_CONVOLUTION_EX_DESC {
    pub InputResource: D3D12_GPU_VIRTUAL_ADDRESS,
    pub FilterResource: D3D12_GPU_VIRTUAL_ADDRESS,
    pub BiasResource: D3D12_GPU_VIRTUAL_ADDRESS,
    pub OutputResource: D3D12_GPU_VIRTUAL_ADDRESS,
    pub Alpha1Resource: D3D12_GPU_VIRTUAL_ADDRESS,
    pub Alpha2Resource: D3D12_GPU_VIRTUAL_ADDRESS,
    pub SkipConnectionResource: D3D12_GPU_VIRTUAL_ADDRESS,
    pub PersistentResource: D3D12_GPU_VIRTUAL_ADDRESS,
    pub TemporaryResource: D3D12_GPU_VIRTUAL_ADDRESS,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_D3D12_META_COMMAND_INITIALIZE_GEMM_DESC {
    pub PersistentResource: NvU64,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct NV_D3D12_META_COMMAND_EXECUTE_GEMM_DESC {
    pub AResource: NvU64,
    pub BResource: NvU64,
    pub CResource: NvU64,
    pub OutputResource: NvU64,
    pub PersistentResource: NvU64,
    pub TemporaryResource: NvU64,
}
impl NV_D3D12_RESOURCE_FLAGS {
    pub const NV_D3D12_RESOURCE_FLAG_NONE: NV_D3D12_RESOURCE_FLAGS = NV_D3D12_RESOURCE_FLAGS(0);
}
impl NV_D3D12_RESOURCE_FLAGS {
    pub const NV_D3D12_RESOURCE_FLAG_HTEX: NV_D3D12_RESOURCE_FLAGS = NV_D3D12_RESOURCE_FLAGS(1);
}
impl NV_D3D12_RESOURCE_FLAGS {
    pub const NV_D3D12_RESOURCE_FLAG_CPUVISIBLE_VIDMEM: NV_D3D12_RESOURCE_FLAGS =
        NV_D3D12_RESOURCE_FLAGS(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_D3D12_RESOURCE_FLAGS(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_RESOURCE_PARAMS_V1 {
    pub version: NvU32,
    pub NVResourceFlags: NV_D3D12_RESOURCE_FLAGS,
}
pub type NV_RESOURCE_PARAMS_V1 = _NV_RESOURCE_PARAMS_V1;
pub type NV_RESOURCE_PARAMS = NV_RESOURCE_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MULTIGPU_CAPS_V1 {
    pub multiGPUVersion: NvU32,
    pub reserved: NvU32,
    pub nTotalGPUs: NvU32,
    pub nSLIGPUs: NvU32,
    pub videoBridgePresent: NvU32,
}
pub type NV_MULTIGPU_CAPS_V1 = _NV_MULTIGPU_CAPS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MULTIGPU_CAPS_V2 {
    pub multiGPUVersion: NvU32,
    pub __bindgen_anon_1: _NV_MULTIGPU_CAPS_V2__bindgen_ty_1,
    pub nTotalGPUs: NvU32,
    pub nSLIGPUs: NvU32,
    pub videoBridgePresent: NvU32,
    pub NvLinkPresent: NvU32,
    pub fastNvLinkReads: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_MULTIGPU_CAPS_V2__bindgen_ty_1 {
    pub reserved: NvU32,
    pub version: NvU32,
}
pub type NV_MULTIGPU_CAPS_V2 = _NV_MULTIGPU_CAPS_V2;
pub type NV_MULTIGPU_CAPS = NV_MULTIGPU_CAPS_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1 {
    pub version: NvU32,
    pub bSinglePassStereoSupported: NvU32,
}
pub type NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1 =
    _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 {
    #[inline]
    pub fn bSinglePassStereoSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSinglePassStereoXYZWSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoXYZWSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bSinglePassStereoSupported: NvU32,
        bSinglePassStereoXYZWSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bSinglePassStereoSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoSupported) };
            bSinglePassStereoSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSinglePassStereoXYZWSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoXYZWSupported) };
            bSinglePassStereoXYZWSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 =
    _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2;
pub type NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS = NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 {
    #[inline]
    pub fn bMultiViewSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bMultiViewSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSinglePassStereoSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSinglePassStereoXYZWSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSinglePassStereoXYZWSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bMultiViewSupported: NvU32,
        bSinglePassStereoSupported: NvU32,
        bSinglePassStereoXYZWSupported: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bMultiViewSupported: u32 = unsafe { ::std::mem::transmute(bMultiViewSupported) };
            bMultiViewSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSinglePassStereoSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoSupported) };
            bSinglePassStereoSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bSinglePassStereoXYZWSupported: u32 =
                unsafe { ::std::mem::transmute(bSinglePassStereoXYZWSupported) };
            bSinglePassStereoXYZWSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 = _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1;
pub type NV_QUERY_MULTIVIEW_SUPPORT_PARAMS = NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MULTIVIEW_PARAMS_V1 {
    pub version: NvU32,
    pub numViews: NvU32,
    pub renderTargetIndexOffset: [NvU32; 4usize],
    pub independentViewportMaskEnable: NvU8,
}
pub type NV_MULTIVIEW_PARAMS_V1 = _NV_MULTIVIEW_PARAMS_V1;
pub type NV_MULTIVIEW_PARAMS = NV_MULTIVIEW_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_QUERY_MODIFIED_W_SUPPORT_PARAMS {
    pub version: NvU32,
    pub bModifiedWSupported: NvU32,
}
pub type NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_V1 = _NV_QUERY_MODIFIED_W_SUPPORT_PARAMS;
pub type NV_QUERY_MODIFIED_W_SUPPORT_PARAMS = NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MODIFIED_W_COEFFICIENTS {
    pub fA: f32,
    pub fB: f32,
    pub fAReserved: f32,
    pub fBReserved: f32,
    pub fReserved: [f32; 2usize],
}
pub type NV_MODIFIED_W_COEFFICIENTS = _NV_MODIFIED_W_COEFFICIENTS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MODIFIED_W_PARAMS {
    pub version: NvU32,
    pub numEntries: NvU32,
    pub modifiedWCoefficients: [NV_MODIFIED_W_COEFFICIENTS; 16usize],
    pub id: NvU32,
    pub reserved: [NvU32; 16usize],
}
pub type NV_MODIFIED_W_PARAMS_V1 = _NV_MODIFIED_W_PARAMS;
pub type NV_MODIFIED_W_PARAMS = NV_MODIFIED_W_PARAMS_V1;
#[repr(C)]
pub struct ID3DLateLatchObject_V1__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3DLateLatchObject_V1 {
    pub vtable_: *const ID3DLateLatchObject_V1__bindgen_vtable,
}
pub type ID3DLateLatchObject = ID3DLateLatchObject_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D_LATELATCH_OBJECT_DESC_V1 {
    pub version: NvU32,
    pub numBuffers: NvU32,
    pub ppBufferDesc: *mut *mut D3D11_BUFFER_DESC,
    pub ppD3DLateLatchObject: *mut *mut ID3DLateLatchObject,
}
pub type NV_D3D_LATELATCH_OBJECT_DESC_V1 = _NV_D3D_LATELATCH_OBJECT_DESC_V1;
pub type NV_D3D_LATELATCH_OBJECT_DESC = NV_D3D_LATELATCH_OBJECT_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_QUERY_LATELATCH_SUPPORT_PARAMS {
    pub version: NvU32,
    pub bLateLatchSupported: NvU32,
}
pub type NV_QUERY_LATELATCH_SUPPORT_PARAMS_V1 = _NV_QUERY_LATELATCH_SUPPORT_PARAMS;
pub type NV_QUERY_LATELATCH_SUPPORT_PARAMS = NV_QUERY_LATELATCH_SUPPORT_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS {
    pub version: NvU32,
    pub pDevice: *mut ID3D12Device,
    pub pSwapChainBuffer: *mut ID3D12Resource,
    pub companionBufferCount: NvU32,
    pub ppCompanionResources: *mut *mut ID3D12Resource,
}
pub type NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS_V1 = _NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS;
pub type NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS = NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS {
    pub version: NvU32,
    pub pDevice: *mut ID3D12Device,
    pub pSwapChainBuffer: *mut ID3D12Resource,
    pub pPartitionCount: *mut NvU32,
    pub pViewport: *mut RECT,
    pub pNodeMask: *mut NvU32,
}
pub type NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS_V1 =
    _NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS;
pub type NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS =
    NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D1x_GRAPHICS_CAPS_V1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved: [NvU32; 7usize],
}
impl _NV_D3D1x_GRAPHICS_CAPS_V1 {
    #[inline]
    pub fn bExclusiveScissorRectsSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bExclusiveScissorRectsSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bVariablePixelRateShadingSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bVariablePixelRateShadingSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBits(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBits(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bExclusiveScissorRectsSupported: NvU32,
        bVariablePixelRateShadingSupported: NvU32,
        reservedBits: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bExclusiveScissorRectsSupported: u32 =
                unsafe { ::std::mem::transmute(bExclusiveScissorRectsSupported) };
            bExclusiveScissorRectsSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bVariablePixelRateShadingSupported: u32 =
                unsafe { ::std::mem::transmute(bVariablePixelRateShadingSupported) };
            bVariablePixelRateShadingSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reservedBits: u32 = unsafe { ::std::mem::transmute(reservedBits) };
            reservedBits as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_D3D1x_GRAPHICS_CAPS_V1 = _NV_D3D1x_GRAPHICS_CAPS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D1x_GRAPHICS_CAPS_V2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub majorSMVersion: NvU16,
    pub minorSMVersion: NvU16,
    pub reserved: [NvU32; 14usize],
}
impl _NV_D3D1x_GRAPHICS_CAPS_V2 {
    #[inline]
    pub fn bExclusiveScissorRectsSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bExclusiveScissorRectsSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bVariablePixelRateShadingSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bVariablePixelRateShadingSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFastUAVClearSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bFastUAVClearSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBits(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBits(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bExclusiveScissorRectsSupported: NvU32,
        bVariablePixelRateShadingSupported: NvU32,
        bFastUAVClearSupported: NvU32,
        reservedBits: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bExclusiveScissorRectsSupported: u32 =
                unsafe { ::std::mem::transmute(bExclusiveScissorRectsSupported) };
            bExclusiveScissorRectsSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bVariablePixelRateShadingSupported: u32 =
                unsafe { ::std::mem::transmute(bVariablePixelRateShadingSupported) };
            bVariablePixelRateShadingSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bFastUAVClearSupported: u32 =
                unsafe { ::std::mem::transmute(bFastUAVClearSupported) };
            bFastUAVClearSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reservedBits: u32 = unsafe { ::std::mem::transmute(reservedBits) };
            reservedBits as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_D3D1x_GRAPHICS_CAPS_V2 = _NV_D3D1x_GRAPHICS_CAPS_V2;
pub type NV_D3D1x_GRAPHICS_CAPS = NV_D3D1x_GRAPHICS_CAPS_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D12_GRAPHICS_CAPS_V1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub majorSMVersion: NvU16,
    pub minorSMVersion: NvU16,
    pub reserved: [NvU32; 6usize],
}
impl _NV_D3D12_GRAPHICS_CAPS_V1 {
    #[inline]
    pub fn bExclusiveScissorRectsSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bExclusiveScissorRectsSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bVariablePixelRateShadingSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bVariablePixelRateShadingSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFastUAVClearSupported(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bFastUAVClearSupported(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBits(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBits(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bExclusiveScissorRectsSupported: NvU32,
        bVariablePixelRateShadingSupported: NvU32,
        bFastUAVClearSupported: NvU32,
        reservedBits: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bExclusiveScissorRectsSupported: u32 =
                unsafe { ::std::mem::transmute(bExclusiveScissorRectsSupported) };
            bExclusiveScissorRectsSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bVariablePixelRateShadingSupported: u32 =
                unsafe { ::std::mem::transmute(bVariablePixelRateShadingSupported) };
            bVariablePixelRateShadingSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bFastUAVClearSupported: u32 =
                unsafe { ::std::mem::transmute(bFastUAVClearSupported) };
            bFastUAVClearSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reservedBits: u32 = unsafe { ::std::mem::transmute(reservedBits) };
            reservedBits as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_D3D12_GRAPHICS_CAPS_V1 = _NV_D3D12_GRAPHICS_CAPS_V1;
pub type NV_D3D12_GRAPHICS_CAPS = NV_D3D12_GRAPHICS_CAPS_V1;
#[repr(C)]
pub struct _NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC_V1 {
    pub enableExclusiveScissorRect: bool,
    pub scissorRect: D3D11_RECT,
}
pub type NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC_V1 = _NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_V1 {
    pub version: NvU32,
    pub numRects: NvU32,
    pub pRects: *mut NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC_V1,
}
pub type NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_V1 = _NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_V1;
pub type NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC = NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_V1;
pub type NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC = NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC_V1;
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X0_CULL_RASTER_PIXELS: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(0);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X16_PER_RASTER_PIXEL: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(1);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X8_PER_RASTER_PIXEL: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(2);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X4_PER_RASTER_PIXEL: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(3);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X2_PER_RASTER_PIXEL: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(4);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X1_PER_RASTER_PIXEL: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(5);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X1_PER_2X1_RASTER_PIXELS: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(6);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X1_PER_1X2_RASTER_PIXELS: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(7);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X1_PER_2X2_RASTER_PIXELS: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(8);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X1_PER_4X2_RASTER_PIXELS: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(9);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X1_PER_2X4_RASTER_PIXELS: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(10);
}
impl NV_PIXEL_SHADING_RATE {
    pub const NV_PIXEL_X1_PER_4X4_RASTER_PIXELS: NV_PIXEL_SHADING_RATE = NV_PIXEL_SHADING_RATE(11);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_PIXEL_SHADING_RATE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D11_VIEWPORT_SHADING_RATE_DESC_V1 {
    pub enableVariablePixelShadingRate: bool,
    pub shadingRateTable: [NV_PIXEL_SHADING_RATE; 16usize],
}
pub type NV_D3D11_VIEWPORT_SHADING_RATE_DESC_V1 = _NV_D3D11_VIEWPORT_SHADING_RATE_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_V1 {
    pub version: NvU32,
    pub numViewports: NvU32,
    pub pViewports: *mut NV_D3D11_VIEWPORT_SHADING_RATE_DESC_V1,
}
pub type NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_V1 = _NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_V1;
pub type NV_D3D11_VIEWPORTS_SHADING_RATE_DESC = NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_V1;
pub type NV_D3D11_VIEWPORT_SHADING_RATE_DESC = NV_D3D11_VIEWPORT_SHADING_RATE_DESC_V1;
impl _NV_SRRV_DIMENSION {
    pub const NV_SRRV_DIMENSION_TEXTURE2D: _NV_SRRV_DIMENSION = _NV_SRRV_DIMENSION(4);
}
impl _NV_SRRV_DIMENSION {
    pub const NV_SRRV_DIMENSION_TEXTURE2DARRAY: _NV_SRRV_DIMENSION = _NV_SRRV_DIMENSION(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_SRRV_DIMENSION(pub ::std::os::raw::c_int);
pub use self::_NV_SRRV_DIMENSION as NV_SRRV_DIMENSION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_TEX2D_SRRV {
    pub MipSlice: UINT,
}
pub type NV_TEX2D_SRRV = _NV_TEX2D_SRRV;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_TEX2D_ARRAY_SRRV {
    pub MipSlice: UINT,
    pub FirstArraySlice: UINT,
    pub ArraySize: UINT,
}
pub type NV_TEX2D_ARRAY_SRRV = _NV_TEX2D_ARRAY_SRRV;
#[repr(C)]
pub struct _NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1 {
    pub version: NvU32,
    pub Format: DXGI_FORMAT,
    pub ViewDimension: NV_SRRV_DIMENSION,
    pub __bindgen_anon_1: _NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1__bindgen_ty_1 {
    pub Texture2D: NV_TEX2D_SRRV,
    pub Texture2DArray: NV_TEX2D_ARRAY_SRRV,
}
pub type NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1 = _NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1;
pub type NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC = NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_1x2 {
    pub X1: _NV_PIXEL_SRSO_1x2_NV_PIXEL_SRSO_1x2_X1,
    pub X2: _NV_PIXEL_SRSO_1x2_NV_PIXEL_SRSO_1x2_X2,
    pub X4: _NV_PIXEL_SRSO_1x2_NV_PIXEL_SRSO_1x2_X4,
    pub X8: _NV_PIXEL_SRSO_1x2_NV_PIXEL_SRSO_1x2_X8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_1x2_NV_PIXEL_SRSO_1x2_X1 {
    pub Y: [NvU8; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_1x2_NV_PIXEL_SRSO_1x2_X2 {
    pub YS: [[NvU8; 2usize]; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_1x2_NV_PIXEL_SRSO_1x2_X4 {
    pub YS: [[NvU8; 4usize]; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_1x2_NV_PIXEL_SRSO_1x2_X8 {
    pub YS: [[NvU8; 8usize]; 2usize],
}
pub type NV_PIXEL_SRSO_1x2 = _NV_PIXEL_SRSO_1x2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x1 {
    pub X1: _NV_PIXEL_SRSO_2x1_NV_PIXEL_SRSO_2x1_X1,
    pub X2: _NV_PIXEL_SRSO_2x1_NV_PIXEL_SRSO_2x1_X2,
    pub X4: _NV_PIXEL_SRSO_2x1_NV_PIXEL_SRSO_2x1_X4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x1_NV_PIXEL_SRSO_2x1_X1 {
    pub X: [NvU8; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x1_NV_PIXEL_SRSO_2x1_X2 {
    pub XS: [[NvU8; 2usize]; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x1_NV_PIXEL_SRSO_2x1_X4 {
    pub XS: [[NvU8; 4usize]; 2usize],
}
pub type NV_PIXEL_SRSO_2x1 = _NV_PIXEL_SRSO_2x1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x2 {
    pub X1: _NV_PIXEL_SRSO_2x2_NV_PIXEL_SRSO_2x2_X1,
    pub X2: _NV_PIXEL_SRSO_2x2_NV_PIXEL_SRSO_2x2_X2,
    pub X4: _NV_PIXEL_SRSO_2x2_NV_PIXEL_SRSO_2x2_X4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x2_NV_PIXEL_SRSO_2x2_X1 {
    pub YX: [[NvU8; 2usize]; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x2_NV_PIXEL_SRSO_2x2_X2 {
    pub YXS: [[[NvU8; 2usize]; 2usize]; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x2_NV_PIXEL_SRSO_2x2_X4 {
    pub YXS: [[[NvU8; 4usize]; 2usize]; 2usize],
}
pub type NV_PIXEL_SRSO_2x2 = _NV_PIXEL_SRSO_2x2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x4 {
    pub X1: _NV_PIXEL_SRSO_2x4_NV_PIXEL_SRSO_2x4_X1,
    pub X2: _NV_PIXEL_SRSO_2x4_NV_PIXEL_SRSO_2x4_X2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x4_NV_PIXEL_SRSO_2x4_X1 {
    pub YX: [[NvU8; 2usize]; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_2x4_NV_PIXEL_SRSO_2x4_X2 {
    pub YXS: [[[NvU8; 2usize]; 2usize]; 4usize],
}
pub type NV_PIXEL_SRSO_2x4 = _NV_PIXEL_SRSO_2x4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_4x2 {
    pub X1: _NV_PIXEL_SRSO_4x2_NV_PIXEL_SRSO_4x2_X1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_4x2_NV_PIXEL_SRSO_4x2_X1 {
    pub YX: [[NvU8; 4usize]; 2usize],
}
pub type NV_PIXEL_SRSO_4x2 = _NV_PIXEL_SRSO_4x2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_4x4 {
    pub X1: _NV_PIXEL_SRSO_4x4_NV_PIXEL_SRSO_4x4_X1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SRSO_4x4_NV_PIXEL_SRSO_4x4_X1 {
    pub YX: [[NvU8; 4usize]; 4usize],
}
pub type NV_PIXEL_SRSO_4x4 = _NV_PIXEL_SRSO_4x4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_V1 {
    pub version: NvU32,
    pub Pixel_1x2: NV_PIXEL_SRSO_1x2,
    pub Pixel_2x1: NV_PIXEL_SRSO_2x1,
    pub Pixel_2x2: NV_PIXEL_SRSO_2x2,
    pub Pixel_2x4: NV_PIXEL_SRSO_2x4,
    pub Pixel_4x2: NV_PIXEL_SRSO_4x2,
    pub Pixel_4x4: NV_PIXEL_SRSO_4x4,
}
pub type NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_V1 = _NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_V1;
pub type NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE = NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_VRS_HELPER_LATCH_GAZE_PARAMS_V1 {
    pub version: NvU32,
    pub flags: NvU32,
}
pub type NV_VRS_HELPER_LATCH_GAZE_PARAMS_V1 = _NV_VRS_HELPER_LATCH_GAZE_PARAMS_V1;
pub type NV_VRS_HELPER_LATCH_GAZE_PARAMS = NV_VRS_HELPER_LATCH_GAZE_PARAMS_V1;
impl _NV_VRS_CONTENT_TYPE {
    pub const NV_VRS_CONTENT_TYPE_INVALID: _NV_VRS_CONTENT_TYPE = _NV_VRS_CONTENT_TYPE(0);
}
impl _NV_VRS_CONTENT_TYPE {
    pub const NV_VRS_CONTENT_TYPE_FOVEATED_RENDERING: _NV_VRS_CONTENT_TYPE =
        _NV_VRS_CONTENT_TYPE(1);
}
impl _NV_VRS_CONTENT_TYPE {
    pub const NV_VRS_CONTENT_TYPE_MAX: _NV_VRS_CONTENT_TYPE = _NV_VRS_CONTENT_TYPE(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_VRS_CONTENT_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_VRS_CONTENT_TYPE as NV_VRS_CONTENT_TYPE;
impl _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET {
    pub const NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_INVALID:
        _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET = _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET(0);
}
impl _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET {
    pub const NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_HIGHEST_PERFORMANCE:
        _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET = _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET(1);
}
impl _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET {
    pub const NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_HIGH_PERFORMANCE:
        _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET = _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET(2);
}
impl _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET {
    pub const NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_BALANCED:
        _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET = _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET(3);
}
impl _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET {
    pub const NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_HIGH_QUALITY:
        _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET = _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET(4);
}
impl _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET {
    pub const NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_HIGHEST_QUALITY:
        _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET = _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET(5);
}
impl _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET {
    pub const NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_CUSTOM:
        _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET = _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET(6);
}
impl _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET {
    pub const NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_MAX:
        _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET = _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET(pub ::std::os::raw::c_int);
pub use self::_NV_FOVEATED_RENDERING_SHADING_RATE_PRESET as NV_FOVEATED_RENDERING_SHADING_RATE_PRESET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1 {
    pub version: NvU32,
    pub InnerMostRegionShadingRate: NV_PIXEL_SHADING_RATE,
    pub MiddleRegionShadingRate: NV_PIXEL_SHADING_RATE,
    pub PeripheralRegionShadingRate: NV_PIXEL_SHADING_RATE,
}
pub type NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1 =
    _NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1;
pub type NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC =
    NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1;
impl _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET {
    pub const NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_INVALID:
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET =
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET(0);
}
impl _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET {
    pub const NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_WIDE:
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET =
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET(1);
}
impl _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET {
    pub const NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_BALANCED:
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET =
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET(2);
}
impl _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET {
    pub const NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_NARROW:
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET =
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET(3);
}
impl _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET {
    pub const NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_CUSTOM:
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET =
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET(4);
}
impl _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET {
    pub const NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_MAX:
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET =
        _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET(pub ::std::os::raw::c_int);
pub use self::_NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET as NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1 {
    pub version: NvU32,
    pub fInnermostRadii: [f32; 2usize],
    pub fMiddleRadii: [f32; 2usize],
    pub fPeripheralRadii: [f32; 2usize],
}
pub type NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1 =
    _NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1;
pub type NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC =
    NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_FOVEATED_RENDERING_DESC_V1 {
    pub version: NvU32,
    pub flags: NvU32,
    pub ShadingRatePreset: NV_FOVEATED_RENDERING_SHADING_RATE_PRESET,
    pub ShadingRateCustomPresetDesc: NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1,
    pub FoveationPatternPreset: NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET,
    pub FoveationPatternCustomPresetDesc:
        NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1,
    pub GazeDataDeviceId: NvU32,
}
pub type NV_FOVEATED_RENDERING_DESC_V1 = _NV_FOVEATED_RENDERING_DESC_V1;
pub type NV_FOVEATED_RENDERING_DESC = NV_FOVEATED_RENDERING_DESC_V1;
impl _NV_VRS_RENDER_MODE {
    pub const NV_VRS_RENDER_MODE_INVALID: _NV_VRS_RENDER_MODE = _NV_VRS_RENDER_MODE(0);
}
impl _NV_VRS_RENDER_MODE {
    pub const NV_VRS_RENDER_MODE_MONO: _NV_VRS_RENDER_MODE = _NV_VRS_RENDER_MODE(1);
}
impl _NV_VRS_RENDER_MODE {
    pub const NV_VRS_RENDER_MODE_LEFT_EYE: _NV_VRS_RENDER_MODE = _NV_VRS_RENDER_MODE(2);
}
impl _NV_VRS_RENDER_MODE {
    pub const NV_VRS_RENDER_MODE_RIGHT_EYE: _NV_VRS_RENDER_MODE = _NV_VRS_RENDER_MODE(3);
}
impl _NV_VRS_RENDER_MODE {
    pub const NV_VRS_RENDER_MODE_STEREO: _NV_VRS_RENDER_MODE = _NV_VRS_RENDER_MODE(4);
}
impl _NV_VRS_RENDER_MODE {
    pub const NV_VRS_RENDER_MODE_MAX: _NV_VRS_RENDER_MODE = _NV_VRS_RENDER_MODE(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_VRS_RENDER_MODE(pub ::std::os::raw::c_int);
pub use self::_NV_VRS_RENDER_MODE as NV_VRS_RENDER_MODE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_VRS_HELPER_ENABLE_PARAMS_V1 {
    pub version: NvU32,
    pub flags: NvU32,
    pub RenderMode: NV_VRS_RENDER_MODE,
    pub ContentType: NV_VRS_CONTENT_TYPE,
    pub sFoveatedRenderingDesc: NV_FOVEATED_RENDERING_DESC_V1,
}
pub type NV_VRS_HELPER_ENABLE_PARAMS_V1 = _NV_VRS_HELPER_ENABLE_PARAMS_V1;
pub type NV_VRS_HELPER_ENABLE_PARAMS = NV_VRS_HELPER_ENABLE_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_VRS_HELPER_DISABLE_PARAMS_V1 {
    pub version: NvU32,
    pub reserved: NvU32,
}
pub type NV_VRS_HELPER_DISABLE_PARAMS_V1 = _NV_VRS_HELPER_DISABLE_PARAMS_V1;
pub type NV_VRS_HELPER_DISABLE_PARAMS = NV_VRS_HELPER_DISABLE_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_V1 {
    pub version: NvU32,
    pub ppShadingRateResource: *mut *mut IUnknown,
    pub shadingRateTable: [NV_PIXEL_SHADING_RATE; 16usize],
}
pub type NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_V1 =
    _NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_V1;
pub type NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS =
    NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_V1 {
    pub version: NvU32,
    pub reserved: NvU32,
}
pub type NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_V1 =
    _NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_V1;
pub type NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS =
    NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_V1;
#[repr(C)]
pub struct ID3DNvVRSHelper_V1__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3DNvVRSHelper_V1 {
    pub vtable_: *const ID3DNvVRSHelper_V1__bindgen_vtable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_VRS_HELPER_INIT_PARAMS_V1 {
    pub version: NvU32,
    pub flags: NvU32,
    pub ppVRSHelper: *mut *mut ID3DNvVRSHelper_V1,
}
pub type NV_VRS_HELPER_INIT_PARAMS_V1 = _NV_VRS_HELPER_INIT_PARAMS_V1;
pub type NV_VRS_HELPER_INIT_PARAMS = NV_VRS_HELPER_INIT_PARAMS_V1;
impl _NV_GAZE_DATA_VALIDITY_FLAGS {
    pub const NV_GAZE_ORIGIN_VALID: _NV_GAZE_DATA_VALIDITY_FLAGS = _NV_GAZE_DATA_VALIDITY_FLAGS(1);
}
impl _NV_GAZE_DATA_VALIDITY_FLAGS {
    pub const NV_GAZE_DIRECTION_VALID: _NV_GAZE_DATA_VALIDITY_FLAGS =
        _NV_GAZE_DATA_VALIDITY_FLAGS(2);
}
impl _NV_GAZE_DATA_VALIDITY_FLAGS {
    pub const NV_GAZE_LOCATION_VALID: _NV_GAZE_DATA_VALIDITY_FLAGS =
        _NV_GAZE_DATA_VALIDITY_FLAGS(4);
}
impl _NV_GAZE_DATA_VALIDITY_FLAGS {
    pub const NV_GAZE_VELOCITY_VALID: _NV_GAZE_DATA_VALIDITY_FLAGS =
        _NV_GAZE_DATA_VALIDITY_FLAGS(8);
}
impl _NV_GAZE_DATA_VALIDITY_FLAGS {
    pub const NV_GAZE_PUPIL_DIAMETER_VALID: _NV_GAZE_DATA_VALIDITY_FLAGS =
        _NV_GAZE_DATA_VALIDITY_FLAGS(16);
}
impl _NV_GAZE_DATA_VALIDITY_FLAGS {
    pub const NV_GAZE_EYE_OPENNESS_VALID: _NV_GAZE_DATA_VALIDITY_FLAGS =
        _NV_GAZE_DATA_VALIDITY_FLAGS(32);
}
impl _NV_GAZE_DATA_VALIDITY_FLAGS {
    pub const NV_GAZE_EYE_SACCADE_DATA_VALID: _NV_GAZE_DATA_VALIDITY_FLAGS =
        _NV_GAZE_DATA_VALIDITY_FLAGS(64);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GAZE_DATA_VALIDITY_FLAGS(pub ::std::os::raw::c_int);
pub use self::_NV_GAZE_DATA_VALIDITY_FLAGS as NV_GAZE_DATA_VALIDITY_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE {
    pub version: NvU32,
    pub GazeDataValidityFlags: NvU32,
    pub fGazeOrigin_mm: [f32; 3usize],
    pub fGazeDirection: [f32; 3usize],
    pub fGazeNormalizedLocation: [f32; 2usize],
    pub fGazeVelocity: [f32; 2usize],
    pub fPupilDiameter_mm: f32,
    pub fEyeOpenness: f32,
    pub bInSaccade: BOOL,
}
pub type NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1 = _NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE;
pub type NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE = NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS {
    pub version: NvU32,
    pub flags: NvU32,
    pub Timestamp: NvU64,
    pub __bindgen_anon_1: _NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS__bindgen_ty_1 {
    pub sMonoData: NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1,
    pub sStereoData: _NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS__bindgen_ty_1__bindgen_ty_1 {
    pub sLeftEye: NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1,
    pub sRightEye: NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1,
}
pub type NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS_V1 =
    _NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS;
pub type NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS =
    NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS_V1;
#[repr(C)]
pub struct ID3DNvGazeHandler_V2__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3DNvGazeHandler_V2 {
    pub vtable_: *const ID3DNvGazeHandler_V2__bindgen_vtable,
}
#[repr(C)]
pub struct ID3DNvGazeHandler_V1__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3DNvGazeHandler_V1 {
    pub vtable_: *const ID3DNvGazeHandler_V1__bindgen_vtable,
}
impl _NV_GAZE_DATA_TYPE {
    pub const NV_GAZE_DATA_INVALID: _NV_GAZE_DATA_TYPE = _NV_GAZE_DATA_TYPE(0);
}
impl _NV_GAZE_DATA_TYPE {
    pub const NV_GAZE_DATA_MONO: _NV_GAZE_DATA_TYPE = _NV_GAZE_DATA_TYPE(1);
}
impl _NV_GAZE_DATA_TYPE {
    pub const NV_GAZE_DATA_STEREO: _NV_GAZE_DATA_TYPE = _NV_GAZE_DATA_TYPE(2);
}
impl _NV_GAZE_DATA_TYPE {
    pub const NV_GAZE_DATA_MAX: _NV_GAZE_DATA_TYPE = _NV_GAZE_DATA_TYPE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GAZE_DATA_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_GAZE_DATA_TYPE as NV_GAZE_DATA_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GAZE_HANDLER_INIT_PARAMS_V2 {
    pub version: NvU32,
    pub GazeDataDeviceId: NvU32,
    pub GazeDataType: NV_GAZE_DATA_TYPE,
    pub flags: NvU32,
    pub fHorizontalFOV: f32,
    pub fVericalFOV: f32,
    pub ppNvGazeHandler: *mut *mut ID3DNvGazeHandler_V2,
}
pub type NV_GAZE_HANDLER_INIT_PARAMS_V2 = _NV_GAZE_HANDLER_INIT_PARAMS_V2;
pub type NV_GAZE_HANDLER_INIT_PARAMS = NV_GAZE_HANDLER_INIT_PARAMS_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GAZE_HANDLER_INIT_PARAMS_V1 {
    pub version: NvU32,
    pub GazeDataDeviceId: NvU32,
    pub GazeDataType: NV_GAZE_DATA_TYPE,
    pub flags: NvU32,
    pub fHorizontalFOV: f32,
    pub fVericalFOV: f32,
    pub ppNvGazeHandler: *mut *mut ID3DNvGazeHandler_V1,
}
pub type NV_GAZE_HANDLER_INIT_PARAMS_V1 = _NV_GAZE_HANDLER_INIT_PARAMS_V1;
impl NV_SMP_ASSIST_TYPE {
    pub const NV_SMP_ASSIST_NONE: NV_SMP_ASSIST_TYPE = NV_SMP_ASSIST_TYPE(0);
}
impl NV_SMP_ASSIST_TYPE {
    pub const NV_SMP_ASSIST_MRS: NV_SMP_ASSIST_TYPE = NV_SMP_ASSIST_TYPE(1);
}
impl NV_SMP_ASSIST_TYPE {
    pub const NV_SMP_ASSIST_LMS: NV_SMP_ASSIST_TYPE = NV_SMP_ASSIST_TYPE(2);
}
impl NV_SMP_ASSIST_TYPE {
    pub const NV_SMP_ASSIST_NUM_TYPES: NV_SMP_ASSIST_TYPE = NV_SMP_ASSIST_TYPE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_SMP_ASSIST_TYPE(pub ::std::os::raw::c_int);
impl NV_SMP_ASSIST_LEVEL {
    pub const NV_SMP_ASSIST_LEVEL_FULL: NV_SMP_ASSIST_LEVEL = NV_SMP_ASSIST_LEVEL(0);
}
impl NV_SMP_ASSIST_LEVEL {
    pub const NV_SMP_ASSIST_LEVEL_PARTIAL: NV_SMP_ASSIST_LEVEL = NV_SMP_ASSIST_LEVEL(1);
}
impl NV_SMP_ASSIST_LEVEL {
    pub const NV_SMP_ASSIST_LEVEL_MINIMAL: NV_SMP_ASSIST_LEVEL = NV_SMP_ASSIST_LEVEL(2);
}
impl NV_SMP_ASSIST_LEVEL {
    pub const NV_SMP_ASSIST_NUM_LEVELS: NV_SMP_ASSIST_LEVEL = NV_SMP_ASSIST_LEVEL(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_SMP_ASSIST_LEVEL(pub ::std::os::raw::c_int);
impl NV_MRS_CONFIG {
    pub const NV_MRS_CONFIG_BALANCED: NV_MRS_CONFIG = NV_MRS_CONFIG(0);
}
impl NV_MRS_CONFIG {
    pub const NV_MRS_CONFIG_AGGRESSIVE: NV_MRS_CONFIG = NV_MRS_CONFIG(1);
}
impl NV_MRS_CONFIG {
    pub const NV_MRS_CONFIG_OCULUSRIFT_CV1_CONSERVATIVE: NV_MRS_CONFIG = NV_MRS_CONFIG(2);
}
impl NV_MRS_CONFIG {
    pub const NV_MRS_CONFIG_OCULUSRIFT_CV1_BALANCED: NV_MRS_CONFIG = NV_MRS_CONFIG(3);
}
impl NV_MRS_CONFIG {
    pub const NV_MRS_CONFIG_OCULUSRIFT_CV1_AGGRESSIVE: NV_MRS_CONFIG = NV_MRS_CONFIG(4);
}
impl NV_MRS_CONFIG {
    pub const NV_MRS_CONFIG_HTC_VIVE_CONSERVATIVE: NV_MRS_CONFIG = NV_MRS_CONFIG(5);
}
impl NV_MRS_CONFIG {
    pub const NV_MRS_CONFIG_HTC_VIVE_BALANCED: NV_MRS_CONFIG = NV_MRS_CONFIG(6);
}
impl NV_MRS_CONFIG {
    pub const NV_MRS_CONFIG_HTC_VIVE_AGGRESSIVE: NV_MRS_CONFIG = NV_MRS_CONFIG(7);
}
impl NV_MRS_CONFIG {
    pub const NV_MRS_NUM_CONFIGS: NV_MRS_CONFIG = NV_MRS_CONFIG(8);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_MRS_CONFIG(pub ::std::os::raw::c_int);
impl NV_LMS_CONFIG {
    pub const NV_LMS_CONFIG_OCULUSRIFT_CV1_CONSERVATIVE: NV_LMS_CONFIG = NV_LMS_CONFIG(0);
}
impl NV_LMS_CONFIG {
    pub const NV_LMS_CONFIG_OCULUSRIFT_CV1_BALANCED: NV_LMS_CONFIG = NV_LMS_CONFIG(1);
}
impl NV_LMS_CONFIG {
    pub const NV_LMS_CONFIG_OCULUSRIFT_CV1_AGGRESSIVE: NV_LMS_CONFIG = NV_LMS_CONFIG(2);
}
impl NV_LMS_CONFIG {
    pub const NV_LMS_CONFIG_HTC_VIVE_CONSERVATIVE: NV_LMS_CONFIG = NV_LMS_CONFIG(3);
}
impl NV_LMS_CONFIG {
    pub const NV_LMS_CONFIG_HTC_VIVE_BALANCED: NV_LMS_CONFIG = NV_LMS_CONFIG(4);
}
impl NV_LMS_CONFIG {
    pub const NV_LMS_CONFIG_HTC_VIVE_AGGRESSIVE: NV_LMS_CONFIG = NV_LMS_CONFIG(5);
}
impl NV_LMS_CONFIG {
    pub const NV_LMS_NUM_CONFIGS: NV_LMS_CONFIG = NV_LMS_CONFIG(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_LMS_CONFIG(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MRS_CUSTOM_CONFIG_V1 {
    pub centerWidth: f32,
    pub centerHeight: f32,
    pub centerX: f32,
    pub centerY: f32,
    pub densityScaleX: [f32; 3usize],
    pub densityScaleY: [f32; 3usize],
}
pub type NV_MRS_CUSTOM_CONFIG_V1 = _NV_MRS_CUSTOM_CONFIG_V1;
pub type NV_MRS_CUSTOM_CONFIG = NV_MRS_CUSTOM_CONFIG_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_MRS_INSTANCED_STEREO_CONFIG_V1 {
    pub centerWidth: [f32; 2usize],
    pub centerHeight: f32,
    pub centerX: [f32; 2usize],
    pub centerY: f32,
    pub densityScaleX: [f32; 5usize],
    pub densityScaleY: [f32; 3usize],
}
pub type NV_MRS_INSTANCED_STEREO_CONFIG_V1 = _NV_MRS_INSTANCED_STEREO_CONFIG_V1;
pub type NV_MRS_INSTANCED_STEREO_CONFIG = NV_MRS_INSTANCED_STEREO_CONFIG_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LMS_CUSTOM_CONFIG_V1 {
    pub warpLeft: f32,
    pub warpRight: f32,
    pub warpUp: f32,
    pub warpDown: f32,
    pub relativeSizeLeft: f32,
    pub relativeSizeRight: f32,
    pub relativeSizeUp: f32,
    pub relativeSizeDown: f32,
}
pub type NV_LMS_CUSTOM_CONFIG_V1 = _NV_LMS_CUSTOM_CONFIG_V1;
pub type NV_LMS_CUSTOM_CONFIG = NV_LMS_CUSTOM_CONFIG_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LMS_INSTANCED_STEREO_CONFIG_V1 {
    pub sLeftConfig: NV_LMS_CUSTOM_CONFIG_V1,
    pub sRightConfig: NV_LMS_CUSTOM_CONFIG_V1,
}
pub type NV_LMS_INSTANCED_STEREO_CONFIG_V1 = _NV_LMS_INSTANCED_STEREO_CONFIG_V1;
pub type NV_LMS_INSTANCED_STEREO_CONFIG = NV_LMS_INSTANCED_STEREO_CONFIG_V1;
impl _NV_SMP_ASSIST_EYE_INDEX {
    pub const NV_SMP_ASSIST_EYE_INDEX_MONO: _NV_SMP_ASSIST_EYE_INDEX = _NV_SMP_ASSIST_EYE_INDEX(0);
}
impl _NV_SMP_ASSIST_EYE_INDEX {
    pub const NV_SMP_ASSIST_EYE_INDEX_LEFT_EYE: _NV_SMP_ASSIST_EYE_INDEX =
        _NV_SMP_ASSIST_EYE_INDEX(1);
}
impl _NV_SMP_ASSIST_EYE_INDEX {
    pub const NV_SMP_ASSIST_EYE_INDEX_RIGHT_EYE: _NV_SMP_ASSIST_EYE_INDEX =
        _NV_SMP_ASSIST_EYE_INDEX(2);
}
impl _NV_SMP_ASSIST_EYE_INDEX {
    pub const NV_SMP_ASSIST_EYE_INDEX_INSTANCED_STEREO: _NV_SMP_ASSIST_EYE_INDEX =
        _NV_SMP_ASSIST_EYE_INDEX(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_SMP_ASSIST_EYE_INDEX(pub ::std::os::raw::c_int);
pub use self::_NV_SMP_ASSIST_EYE_INDEX as NV_SMP_ASSIST_EYE_INDEX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_CUSTOM_RECTS_V1 {
    pub numViewports: [NvU32; 4usize],
    pub pViewports: [*mut D3D11_VIEWPORT; 4usize],
    pub pScissors: [*mut D3D11_RECT; 4usize],
}
pub type NV_CUSTOM_RECTS_V1 = _NV_CUSTOM_RECTS_V1;
pub type NV_CUSTOM_RECTS = NV_CUSTOM_RECTS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SMP_ASSIST_ENABLE_PARAMS_V1 {
    pub version: NvU32,
    pub eEyeIndex: NV_SMP_ASSIST_EYE_INDEX,
}
pub type NV_SMP_ASSIST_ENABLE_PARAMS_V1 = _NV_SMP_ASSIST_ENABLE_PARAMS_V1;
pub type NV_SMP_ASSIST_ENABLE_PARAMS = NV_SMP_ASSIST_ENABLE_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SMP_ASSIST_DISABLE_PARAMS_V1 {
    pub version: NvU32,
    pub Reserved: NvU32,
}
pub type NV_SMP_ASSIST_DISABLE_PARAMS_V1 = _NV_SMP_ASSIST_DISABLE_PARAMS_V1;
pub type NV_SMP_ASSIST_DISABLE_PARAMS = NV_SMP_ASSIST_DISABLE_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SMP_ASSIST_FASTGSCBDATA_V1 {
    pub NDCSplitsX: [f32; 2usize],
    pub NDCSplitsY: [f32; 2usize],
}
pub type NV_SMP_ASSIST_FASTGSCBDATA_V1 = _NV_SMP_ASSIST_FASTGSCBDATA_V1;
pub type NV_SMP_ASSIST_FASTGSCBDATA = NV_SMP_ASSIST_FASTGSCBDATA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO_V1 {
    pub NDCSplitsX: [f32; 4usize],
    pub NDCSplitsY: [f32; 2usize],
}
pub type NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO_V1 =
    _NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO_V1;
pub type NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO =
    NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SMP_ASSIST_REMAPCBDATA_V1 {
    pub ClipToWindowSplitsX: [f32; 2usize],
    pub ClipToWindowSplitsY: [f32; 2usize],
    pub ClipToWindowX: [[f32; 2usize]; 3usize],
    pub ClipToWindowY: [[f32; 2usize]; 3usize],
    pub ClipToWindowZ: [f32; 2usize],
    pub WindowToClipSplitsX: [f32; 2usize],
    pub WindowToClipSplitsY: [f32; 2usize],
    pub WindowToClipX: [[f32; 2usize]; 3usize],
    pub WindowToClipY: [[f32; 2usize]; 3usize],
    pub WindowToClipZ: [f32; 2usize],
    pub BoundingRectOriginX: f32,
    pub BoundingRectOriginY: f32,
    pub BoundingRectSizeWidth: f32,
    pub BoundingRectSizeHeight: f32,
    pub BoundingRectSizeInvWidth: f32,
    pub BoundingRectSizeInvHeight: f32,
    pub Padding: [f32; 2usize],
}
pub type NV_SMP_ASSIST_REMAPCBDATA_V1 = _NV_SMP_ASSIST_REMAPCBDATA_V1;
pub type NV_SMP_ASSIST_REMAPCBDATA = NV_SMP_ASSIST_REMAPCBDATA_V1;
#[repr(C)]
pub struct _NV_SMP_ASSIST_GET_CONSTANTS_V3 {
    pub version: NvU32,
    pub eEyeIndex: NV_SMP_ASSIST_EYE_INDEX,
    pub numViewports: NvU32,
    pub pViewports: *mut D3D11_VIEWPORT,
    pub pScissors: *mut D3D11_RECT,
    pub eSMPAssistType: NV_SMP_ASSIST_TYPE,
    pub eSMPAssistLevel: NV_SMP_ASSIST_LEVEL,
    pub __bindgen_anon_1: _NV_SMP_ASSIST_GET_CONSTANTS_V3__bindgen_ty_1,
    pub projectionSizeWidth: f32,
    pub projectionSizeHeight: f32,
    pub pFastGSCBData: *mut NV_SMP_ASSIST_FASTGSCBDATA_V1,
    pub pRemapCBData: *mut NV_SMP_ASSIST_REMAPCBDATA_V1,
    pub boundingViewport: D3D11_VIEWPORT,
    pub boundingScissor: D3D11_RECT,
    pub __bindgen_anon_2: _NV_SMP_ASSIST_GET_CONSTANTS_V3__bindgen_ty_2,
    pub pFastGSCBDataMRS_IS: *mut NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO_V1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_SMP_ASSIST_GET_CONSTANTS_V3__bindgen_ty_1 {
    pub sMRSConfig: NV_MRS_CUSTOM_CONFIG_V1,
    pub sLMSConfig: NV_LMS_CUSTOM_CONFIG_V1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_SMP_ASSIST_GET_CONSTANTS_V3__bindgen_ty_2 {
    pub sMRS_ISConfig: NV_MRS_INSTANCED_STEREO_CONFIG_V1,
    pub sLMS_ISConfig: NV_LMS_INSTANCED_STEREO_CONFIG_V1,
}
pub type NV_SMP_ASSIST_GET_CONSTANTS_V3 = _NV_SMP_ASSIST_GET_CONSTANTS_V3;
pub type NV_SMP_ASSIST_GET_CONSTANTS = NV_SMP_ASSIST_GET_CONSTANTS_V3;
#[repr(C)]
pub struct _NV_SMP_ASSIST_SETUP_PARAMS_V1 {
    pub version: NvU32,
    pub __bindgen_anon_1: _NV_SMP_ASSIST_SETUP_PARAMS_V1__bindgen_ty_1,
    pub resolutionScale: f32,
    pub boundingBox: D3D11_VIEWPORT,
    pub vpOffsets: [f32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_SMP_ASSIST_SETUP_PARAMS_V1__bindgen_ty_1 {
    pub eMRSConfig: NV_MRS_CONFIG,
    pub eLMSConfig: NV_LMS_CONFIG,
    pub sMRSCustomConfig: NV_MRS_CUSTOM_CONFIG_V1,
    pub sLMSCustomConfig: NV_LMS_CUSTOM_CONFIG_V1,
    pub sCustomRects: NV_CUSTOM_RECTS_V1,
}
pub type NV_SMP_ASSIST_SETUP_PARAMS_V1 = _NV_SMP_ASSIST_SETUP_PARAMS_V1;
pub type NV_SMP_ASSIST_SETUP_PARAMS = NV_SMP_ASSIST_SETUP_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_V1 {
    pub version: NvU32,
    pub eSMPAssistType: NV_SMP_ASSIST_TYPE,
    pub leftCoeffs: [f32; 4usize],
    pub leftConst: f32,
    pub rightCoeffs: [f32; 4usize],
    pub rightConst: f32,
}
pub type NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_V1 =
    _NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_V1;
pub type NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS =
    NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_V1;
#[repr(C)]
pub struct ID3DNvSMPAssist_V1__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ID3DNvSMPAssist_V1 {
    pub vtable_: *const ID3DNvSMPAssist_V1__bindgen_vtable,
}
pub type ID3DNvSMPAssist = ID3DNvSMPAssist_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SMP_ASSIST_INITIALIZE_PARAMS_V1 {
    pub version: NvU32,
    pub eSMPAssistType: NV_SMP_ASSIST_TYPE,
    pub eSMPAssistLevel: NV_SMP_ASSIST_LEVEL,
    pub flags: NvU32,
    pub ppD3DNvSMPAssist: *mut *mut ID3DNvSMPAssist,
}
pub type NV_SMP_ASSIST_INITIALIZE_PARAMS_V1 = _NV_SMP_ASSIST_INITIALIZE_PARAMS_V1;
pub type NV_SMP_ASSIST_INITIALIZE_PARAMS = NV_SMP_ASSIST_INITIALIZE_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_V1 {
    pub version: NvU32,
    pub eSMPAssistType: NV_SMP_ASSIST_TYPE,
    pub eSMPAssistLevel: NV_SMP_ASSIST_LEVEL,
    pub bSMPAssistSupported: NvBool,
}
pub type NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_V1 = _NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_V1;
pub type NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS = NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GET_SLEEP_STATUS_PARAMS {
    pub version: NvU32,
    pub bLowLatencyMode: NvBool,
    pub bFsVrr: NvBool,
    pub bCplVsyncOn: NvBool,
    pub rsvd: [NvU8; 126usize],
}
pub type NV_GET_SLEEP_STATUS_PARAMS_V1 = _NV_GET_SLEEP_STATUS_PARAMS;
pub type NV_GET_SLEEP_STATUS_PARAMS = NV_GET_SLEEP_STATUS_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SET_SLEEP_MODE_PARAMS {
    pub version: NvU32,
    pub bLowLatencyMode: NvBool,
    pub bLowLatencyBoost: NvBool,
    pub minimumIntervalUs: NvU32,
    pub bUseMarkersToOptimize: NvBool,
    pub rsvd: [NvU8; 31usize],
}
pub type NV_SET_SLEEP_MODE_PARAMS_V1 = _NV_SET_SLEEP_MODE_PARAMS;
pub type NV_SET_SLEEP_MODE_PARAMS = NV_SET_SLEEP_MODE_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_SET_REFLEX_SYNC_PARAMS {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub vblankIntervalUs: NvU32,
    pub timeInQueueUs: NvS32,
    pub timeInQueueUsTarget: NvU32,
    pub rsvd: [NvU8; 28usize],
}
impl _NV_SET_REFLEX_SYNC_PARAMS {
    #[inline]
    pub fn bEnable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bEnable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bDisable(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bDisable(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flagsRsvd(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_flagsRsvd(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bEnable: NvU32,
        bDisable: NvU32,
        flagsRsvd: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bEnable: u32 = unsafe { ::std::mem::transmute(bEnable) };
            bEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bDisable: u32 = unsafe { ::std::mem::transmute(bDisable) };
            bDisable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let flagsRsvd: u32 = unsafe { ::std::mem::transmute(flagsRsvd) };
            flagsRsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_SET_REFLEX_SYNC_PARAMS_V1 = _NV_SET_REFLEX_SYNC_PARAMS;
pub type NV_SET_REFLEX_SYNC_PARAMS = NV_SET_REFLEX_SYNC_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LATENCY_RESULT_PARAMS {
    pub version: NvU32,
    pub frameReport: [_NV_LATENCY_RESULT_PARAMS_FrameReport; 64usize],
    pub rsvd: [NvU8; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LATENCY_RESULT_PARAMS_FrameReport {
    pub frameID: NvU64,
    pub inputSampleTime: NvU64,
    pub simStartTime: NvU64,
    pub simEndTime: NvU64,
    pub renderSubmitStartTime: NvU64,
    pub renderSubmitEndTime: NvU64,
    pub presentStartTime: NvU64,
    pub presentEndTime: NvU64,
    pub driverStartTime: NvU64,
    pub driverEndTime: NvU64,
    pub osRenderQueueStartTime: NvU64,
    pub osRenderQueueEndTime: NvU64,
    pub gpuRenderStartTime: NvU64,
    pub gpuRenderEndTime: NvU64,
    pub gpuActiveRenderTimeUs: NvU32,
    pub gpuFrameTimeUs: NvU32,
    pub rsvd: [NvU8; 120usize],
}
pub type NV_LATENCY_RESULT_PARAMS_V1 = _NV_LATENCY_RESULT_PARAMS;
pub type NV_LATENCY_RESULT_PARAMS = NV_LATENCY_RESULT_PARAMS_V1;
impl NV_LATENCY_MARKER_TYPE {
    pub const SIMULATION_START: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(0);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const SIMULATION_END: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(1);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const RENDERSUBMIT_START: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(2);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const RENDERSUBMIT_END: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(3);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const PRESENT_START: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(4);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const PRESENT_END: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(5);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const INPUT_SAMPLE: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(6);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const TRIGGER_FLASH: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(7);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const PC_LATENCY_PING: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(8);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const OUT_OF_BAND_RENDERSUBMIT_START: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(9);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const OUT_OF_BAND_RENDERSUBMIT_END: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(10);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const OUT_OF_BAND_PRESENT_START: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(11);
}
impl NV_LATENCY_MARKER_TYPE {
    pub const OUT_OF_BAND_PRESENT_END: NV_LATENCY_MARKER_TYPE = NV_LATENCY_MARKER_TYPE(12);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_LATENCY_MARKER_TYPE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_LATENCY_MARKER_PARAMS {
    pub version: NvU32,
    pub frameID: NvU64,
    pub markerType: NV_LATENCY_MARKER_TYPE,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_LATENCY_MARKER_PARAMS_V1 = _NV_LATENCY_MARKER_PARAMS;
pub type NV_LATENCY_MARKER_PARAMS = NV_LATENCY_MARKER_PARAMS_V1;
pub type NV_ASYNC_FRAME_MARKER_PARAMS_V1 = NV_LATENCY_MARKER_PARAMS_V1;
pub type NV_ASYNC_FRAME_MARKER_PARAMS = NV_ASYNC_FRAME_MARKER_PARAMS_V1;
impl NV_OUT_OF_BAND_CQ_TYPE {
    pub const OUT_OF_BAND_RENDER: NV_OUT_OF_BAND_CQ_TYPE = NV_OUT_OF_BAND_CQ_TYPE(0);
}
impl NV_OUT_OF_BAND_CQ_TYPE {
    pub const OUT_OF_BAND_PRESENT: NV_OUT_OF_BAND_CQ_TYPE = NV_OUT_OF_BAND_CQ_TYPE(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_OUT_OF_BAND_CQ_TYPE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_DIM3 {
    pub x: NvU32,
    pub y: NvU32,
    pub z: NvU32,
}
pub type NVAPI_DIM3 = _NVAPI_DIM3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_CU_KERNEL_LAUNCH_PARAMS {
    pub hFunction: NVDX_ObjectHandle,
    pub gridDim: NVAPI_DIM3,
    pub blockDim: NVAPI_DIM3,
    pub dynSharedMemBytes: NvU32,
    pub pParams: *const ::std::os::raw::c_void,
    pub paramSize: NvU32,
}
pub type NVAPI_CU_KERNEL_LAUNCH_PARAMS = _NVAPI_CU_KERNEL_LAUNCH_PARAMS;
impl _NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS {
    pub const NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAP_NONE:
        _NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS =
        _NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS(0);
}
impl _NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS {
    pub const NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAP_STANDARD:
        _NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS =
        _NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS as NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS;
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_NONE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS(0);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_STANDARD:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS as NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS;
impl _NVAPI_D3D12_RAYTRACING_CAPS_TYPE {
    pub const NVAPI_D3D12_RAYTRACING_CAPS_TYPE_THREAD_REORDERING:
        _NVAPI_D3D12_RAYTRACING_CAPS_TYPE = _NVAPI_D3D12_RAYTRACING_CAPS_TYPE(0);
}
impl _NVAPI_D3D12_RAYTRACING_CAPS_TYPE {
    pub const NVAPI_D3D12_RAYTRACING_CAPS_TYPE_OPACITY_MICROMAP: _NVAPI_D3D12_RAYTRACING_CAPS_TYPE =
        _NVAPI_D3D12_RAYTRACING_CAPS_TYPE(1);
}
impl _NVAPI_D3D12_RAYTRACING_CAPS_TYPE {
    pub const NVAPI_D3D12_RAYTRACING_CAPS_TYPE_INVALID: _NVAPI_D3D12_RAYTRACING_CAPS_TYPE =
        _NVAPI_D3D12_RAYTRACING_CAPS_TYPE(-1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_CAPS_TYPE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_CAPS_TYPE as NVAPI_D3D12_RAYTRACING_CAPS_TYPE;
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAG_NONE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS(0);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAG_PREFER_FAST_TRACE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS(1);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAG_PREFER_FAST_BUILD:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS as NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS;
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT_OC1_2_STATE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT(1);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT_OC1_4_STATE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT as NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_USAGE_COUNT {
    pub count: NvU32,
    pub subdivisionLevel: NvU32,
    pub format: NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_FORMAT,
}
pub type NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_USAGE_COUNT =
    _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_USAGE_COUNT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_DESC {
    pub byteOffset: NvU32,
    pub subdivisionLevel: NvU16,
    pub format: NvU16,
}
pub type NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_DESC =
    _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_DESC;
#[repr(C)]
pub struct _NVAPI_D3D12_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_INPUTS {
    pub flags: NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_BUILD_FLAGS,
    pub numOMMUsageCounts: NvU32,
    pub pOMMUsageCounts: *const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_USAGE_COUNT,
    pub inputBuffer: D3D12_GPU_VIRTUAL_ADDRESS,
    pub perOMMDescs: D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE,
}
pub type NVAPI_D3D12_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_INPUTS =
    _NVAPI_D3D12_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_INPUTS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO {
    pub resultDataMaxSizeInBytes: NvU64,
    pub scratchDataSizeInBytes: NvU64,
}
pub type NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO =
    _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS_V1 {
    pub version: NvU32,
    pub pDesc: *const NVAPI_D3D12_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_INPUTS,
    pub pInfo: *mut NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO,
}
pub type NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS_V1 =
    _NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS_V1;
pub type NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS =
    NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS_V1;
impl _NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS {
    pub const NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS_NONE:
        _NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS = _NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS(0);
}
impl _NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS {
    pub const NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS_ENABLE_OMM_SUPPORT:
        _NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS = _NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS as NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS_V1 {
    pub version: NvU32,
    pub flags: NvU32,
}
pub type NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS_V1 =
    _NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS_V1;
pub type NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS =
    NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS_V1;
impl _NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX {
    pub const NVAPI_D3D12_SERIALIZED_DATA_RAYTRACING_ACCELERATION_STRUCTURE_EX:
        _NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX = _NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX(0);
}
impl _NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX {
    pub const NVAPI_D3D12_SERIALIZED_DATA_RAYTRACING_OPACITY_MICROMAP_ARRAY_EX:
        _NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX = _NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX as NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX;
#[repr(C)]
pub struct _NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS_V1 {
    pub version: NvU32,
    pub serializedDataType: NVAPI_D3D12_SERIALIZED_DATA_TYPE_EX,
    pub pIdentifierToCheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    pub checkStatus: D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS,
}
pub type NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS_V1 =
    _NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS_V1;
pub type NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS =
    NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS_V1;
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_NONE_EX:
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX =
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(0);
}
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE_EX:
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX =
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(1);
}
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_COMPACTION_EX:
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX =
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(2);
}
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE_EX:
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX =
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(4);
}
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_BUILD_EX:
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX =
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(8);
}
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_MINIMIZE_MEMORY_EX:
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX =
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(16);
}
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE_EX:
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX =
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(32);
}
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_UPDATE_EX:
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX =
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(64);
}
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_DISABLE_OMMS_EX:
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX =
        _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(128);
}
impl _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_OPACITY_STATES_UPDATE_EX : _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX = _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX (256) ;
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX as NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX;
impl _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX {
    pub const NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES_EX:
        _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX = _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX(0);
}
impl _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX {
    pub const NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS_EX:
        _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX = _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX(1);
}
impl _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX {
    pub const NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_OMM_TRIANGLES_EX:
        _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX = _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX as NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX;
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX(-1);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX(-2);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX(-3);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX(-4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX as NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_SPECIAL_INDEX;
#[repr(C)]
pub struct _NVAPI_D3D12_RAYTRACING_GEOMETRY_OMM_ATTACHMENT_DESC {
    pub opacityMicromapIndexBuffer: D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE,
    pub opacityMicromapIndexFormat: DXGI_FORMAT,
    pub opacityMicromapBaseLocation: NvU32,
    pub opacityMicromapArray: D3D12_GPU_VIRTUAL_ADDRESS,
    pub numOMMUsageCounts: NvU32,
    pub pOMMUsageCounts: *const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_USAGE_COUNT,
}
pub type NVAPI_D3D12_RAYTRACING_GEOMETRY_OMM_ATTACHMENT_DESC =
    _NVAPI_D3D12_RAYTRACING_GEOMETRY_OMM_ATTACHMENT_DESC;
#[repr(C)]
pub struct _NVAPI_D3D12_RAYTRACING_GEOMETRY_OMM_TRIANGLES_DESC {
    pub triangles: D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC,
    pub ommAttachment: NVAPI_D3D12_RAYTRACING_GEOMETRY_OMM_ATTACHMENT_DESC,
}
pub type NVAPI_D3D12_RAYTRACING_GEOMETRY_OMM_TRIANGLES_DESC =
    _NVAPI_D3D12_RAYTRACING_GEOMETRY_OMM_TRIANGLES_DESC;
#[repr(C)]
pub struct _NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX {
    pub type_: NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_EX,
    pub flags: D3D12_RAYTRACING_GEOMETRY_FLAGS,
    pub __bindgen_anon_1: _NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX__bindgen_ty_1,
}
#[repr(C)]
pub struct _NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX__bindgen_ty_1 {
    pub triangles: __BindgenUnionField<D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC>,
    pub aabbs: __BindgenUnionField<D3D12_RAYTRACING_GEOMETRY_AABBS_DESC>,
    pub ommTriangles: __BindgenUnionField<NVAPI_D3D12_RAYTRACING_GEOMETRY_OMM_TRIANGLES_DESC>,
    pub bindgen_union_field: [u64; 12usize],
}
pub type NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX = _NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX;
impl _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_INSTANCE_FLAG_NONE_EX:
        _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX = _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX(0);
}
impl _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_CULL_DISABLE_EX:
        _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX = _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX(1);
}
impl _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_FRONT_COUNTERCLOCKWISE_EX:
        _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX = _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX(2);
}
impl _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_INSTANCE_FLAG_FORCE_OPAQUE_EX:
        _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX = _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX(4);
}
impl _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_INSTANCE_FLAG_FORCE_NON_OPAQUE_EX:
        _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX = _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX(8);
}
impl _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_INSTANCE_FLAG_FORCE_OMM_2_STATE_EX:
        _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX = _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX(16);
}
impl _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX {
    pub const NVAPI_D3D12_RAYTRACING_INSTANCE_FLAG_DISABLE_OMMS_EX:
        _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX = _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX(32);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX as NVAPI_D3D12_RAYTRACING_INSTANCE_FLAGS_EX;
#[repr(C)]
pub struct _NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX {
    pub type_: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE,
    pub flags: NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS_EX,
    pub numDescs: NvU32,
    pub descsLayout: D3D12_ELEMENTS_LAYOUT,
    pub geometryDescStrideInBytes: NvU32,
    pub __bindgen_anon_1:
        _NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX__bindgen_ty_1,
}
#[repr(C)]
pub struct _NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX__bindgen_ty_1 {
    pub instanceDescs: __BindgenUnionField<D3D12_GPU_VIRTUAL_ADDRESS>,
    pub pGeometryDescs: __BindgenUnionField<*const NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX>,
    pub ppGeometryDescs: __BindgenUnionField<*const *const NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX>,
    pub bindgen_union_field: u64,
}
pub type NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX =
    _NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS_V1 {
    pub version: NvU32,
    pub pDesc: *const NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX,
    pub pInfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
}
pub type NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS_V1 =
    _NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS_V1;
pub type NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS =
    NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS_V1;
#[repr(C)]
pub struct _NVAPI_D3D12_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_DESC {
    pub destOpacityMicromapArrayData: D3D12_GPU_VIRTUAL_ADDRESS,
    pub inputs: NVAPI_D3D12_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_INPUTS,
    pub scratchOpacityMicromapArrayData: D3D12_GPU_VIRTUAL_ADDRESS,
}
pub type NVAPI_D3D12_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_DESC =
    _NVAPI_D3D12_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_DESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_CURRENT_SIZE_DESC {
    pub currentSizeInBytes: NvU64,
}
pub type NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_CURRENT_SIZE_DESC =
    _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_CURRENT_SIZE_DESC;
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_TYPE {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_CURRENT_SIZE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_TYPE =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_TYPE(0);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_TYPE(
    pub ::std::os::raw::c_int,
);
pub use self::_NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_TYPE as NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_TYPE;
#[repr(C)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_DESC {
    pub destBuffer: D3D12_GPU_VIRTUAL_ADDRESS,
    pub infoType: NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_TYPE,
}
pub type NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_DESC =
    _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_DESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS_V1 {
    pub version: NvU32,
    pub pDesc: *const NVAPI_D3D12_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_DESC,
    pub numPostbuildInfoDescs: NvU32,
    pub pPostbuildInfoDescs:
        *const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_DESC,
}
pub type NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS_V1 =
    _NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS_V1;
pub type NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS =
    NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS_V1;
#[repr(C)]
pub struct _NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS_V1 {
    pub version: NvU32,
    pub opacityMicromapArray: D3D12_GPU_VIRTUAL_ADDRESS,
}
pub type NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS_V1 =
    _NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS_V1;
pub type NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS =
    NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS_V1 {
    pub version: NvU32,
    pub pDesc: *const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_DESC,
    pub numSources: NvU32,
    pub pSources: *const D3D12_GPU_VIRTUAL_ADDRESS,
}
pub type NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS_V1 =
    _NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS_V1;
pub type NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS =
    NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS_V1;
#[repr(C)]
pub struct _NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC_EX {
    pub destAccelerationStructureData: D3D12_GPU_VIRTUAL_ADDRESS,
    pub inputs: NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX,
    pub sourceAccelerationStructureData: D3D12_GPU_VIRTUAL_ADDRESS,
    pub scratchAccelerationStructureData: D3D12_GPU_VIRTUAL_ADDRESS,
}
pub type NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC_EX =
    _NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS_V1 {
    pub version: NvU32,
    pub pDesc: *const NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC_EX,
    pub numPostbuildInfoDescs: NvU32,
    pub pPostbuildInfoDescs: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
}
pub type NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS_V1 =
    _NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS_V1;
pub type NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS =
    NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS_V1;
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE_TRANSPARENT:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE(0);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE_OPAQUE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE(1);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE_UNKNOWN_TRANSPARENT:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE(2);
}
impl _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE {
    pub const NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE_UNKNOWN_OPAQUE:
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE =
        _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE(pub ::std::os::raw::c_int);
pub use self::_NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE as NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_STATE;
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_NONE_EX: _NVAPI_RAY_FLAGS_EX = _NVAPI_RAY_FLAGS_EX(0);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_FORCE_OPAQUE_EX: _NVAPI_RAY_FLAGS_EX = _NVAPI_RAY_FLAGS_EX(1);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_FORCE_NON_OPAQUE_EX: _NVAPI_RAY_FLAGS_EX = _NVAPI_RAY_FLAGS_EX(2);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH_EX: _NVAPI_RAY_FLAGS_EX =
        _NVAPI_RAY_FLAGS_EX(4);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_SKIP_CLOSEST_HIT_SHADER_EX: _NVAPI_RAY_FLAGS_EX =
        _NVAPI_RAY_FLAGS_EX(8);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_CULL_BACK_FACING_TRIANGLES_EX: _NVAPI_RAY_FLAGS_EX =
        _NVAPI_RAY_FLAGS_EX(16);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES_EX: _NVAPI_RAY_FLAGS_EX =
        _NVAPI_RAY_FLAGS_EX(32);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_CULL_OPAQUE_EX: _NVAPI_RAY_FLAGS_EX = _NVAPI_RAY_FLAGS_EX(64);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_CULL_NON_OPAQUE_EX: _NVAPI_RAY_FLAGS_EX = _NVAPI_RAY_FLAGS_EX(128);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_SKIP_TRIANGLES_EX: _NVAPI_RAY_FLAGS_EX = _NVAPI_RAY_FLAGS_EX(256);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES_EX: _NVAPI_RAY_FLAGS_EX =
        _NVAPI_RAY_FLAGS_EX(512);
}
impl _NVAPI_RAY_FLAGS_EX {
    pub const NVAPI_RAY_FLAG_FORCE_OMM_2_STATE_EX: _NVAPI_RAY_FLAGS_EX = _NVAPI_RAY_FLAGS_EX(1024);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_RAY_FLAGS_EX(pub ::std::os::raw::c_int);
pub use self::_NVAPI_RAY_FLAGS_EX as NVAPI_RAY_FLAG_EX;
impl _NV_D3D12_WORKSTATION_FEATURE_TYPE {
    pub const NV_D3D12_WORKSTATION_FEATURE_TYPE_PRESENT_BARRIER:
        _NV_D3D12_WORKSTATION_FEATURE_TYPE = _NV_D3D12_WORKSTATION_FEATURE_TYPE(1);
}
impl _NV_D3D12_WORKSTATION_FEATURE_TYPE {
    pub const NV_D3D12_WORKSTATION_FEATURE_TYPE_RDMA_BAR1_SUPPORT:
        _NV_D3D12_WORKSTATION_FEATURE_TYPE = _NV_D3D12_WORKSTATION_FEATURE_TYPE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_D3D12_WORKSTATION_FEATURE_TYPE(pub ::std::os::raw::c_int);
pub use self::_NV_D3D12_WORKSTATION_FEATURE_TYPE as NV_D3D12_WORKSTATION_FEATURE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES {
    pub rdmaHeapSize: NvU64,
}
pub type NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES =
    _NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_D3D12_WORKSTATION_FEATURE_PROPERTIES {
    pub version: NvU32,
    pub workstationFeatureType: NV_D3D12_WORKSTATION_FEATURE_TYPE,
    pub supported: NvBool,
    pub __bindgen_anon_1: _NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_D3D12_WORKSTATION_FEATURE_PROPERTIES__bindgen_ty_1 {
    pub rdmaInfo: NV_D3D12_WORKSTATION_FEATURE_RDMA_PROPERTIES,
}
pub type NVAPI_D3D12_WORKSTATION_FEATURE_PROPERTIES_PARAMS_V1 =
    _NV_D3D12_WORKSTATION_FEATURE_PROPERTIES;
pub type NVVIOOWNERID = NvU32;
impl _NVVIOOWNERTYPE {
    pub const NVVIOOWNERTYPE_NONE: _NVVIOOWNERTYPE = _NVVIOOWNERTYPE(0);
}
impl _NVVIOOWNERTYPE {
    pub const NVVIOOWNERTYPE_APPLICATION: _NVVIOOWNERTYPE = _NVVIOOWNERTYPE(1);
}
impl _NVVIOOWNERTYPE {
    pub const NVVIOOWNERTYPE_DESKTOP: _NVVIOOWNERTYPE = _NVVIOOWNERTYPE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOOWNERTYPE(pub ::std::os::raw::c_int);
pub use self::_NVVIOOWNERTYPE as NVVIOOWNERTYPE;
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_NONE: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(0);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_487I_59_94_SMPTE259_NTSC: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(1);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_576I_50_00_SMPTE259_PAL: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(2);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1035I_60_00_SMPTE260: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(3);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1035I_59_94_SMPTE260: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(4);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_50_00_SMPTE295: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(5);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(6);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(7);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(8);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(9);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(10);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(11);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(12);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_23_976_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(13);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_720P_60_00_SMPTE296: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(14);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_720P_59_94_SMPTE296: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(15);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_720P_50_00_SMPTE296: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(16);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(17);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(18);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_720P_30_00_SMPTE296: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(19);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_720P_29_97_SMPTE296: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(20);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_720P_25_00_SMPTE296: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(21);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_720P_24_00_SMPTE296: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(22);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_720P_23_98_SMPTE296: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(23);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(24);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(25);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(26);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(27);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(28);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(29);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(30);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(31);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(32);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(33);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080PSF_25_00_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(34);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080PSF_29_97_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(35);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080PSF_30_00_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(36);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080PSF_24_00_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(37);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080PSF_23_98_SMPTE274: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(38);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_A: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(39);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_A: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(40);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_A: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(41);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(42);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(43);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(44);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(45);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(46);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(47);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(48);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(49);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(50);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(51);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(52);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(53);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(54);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(55);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(56);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(57);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(58);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(59);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(60);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080P_23_98_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(61);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(62);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(63);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372_3G_LEVEL_B: _NVVIOSIGNALFORMAT =
        _NVVIOSIGNALFORMAT(64);
}
impl _NVVIOSIGNALFORMAT {
    pub const NVVIOSIGNALFORMAT_END: _NVVIOSIGNALFORMAT = _NVVIOSIGNALFORMAT(65);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOSIGNALFORMAT(pub ::std::os::raw::c_int);
pub use self::_NVVIOSIGNALFORMAT as NVVIOSIGNALFORMAT;
impl _NVVIOVIDEOSTANDARD {
    pub const NVVIOVIDEOSTANDARD_SMPTE259: _NVVIOVIDEOSTANDARD = _NVVIOVIDEOSTANDARD(0);
}
impl _NVVIOVIDEOSTANDARD {
    pub const NVVIOVIDEOSTANDARD_SMPTE260: _NVVIOVIDEOSTANDARD = _NVVIOVIDEOSTANDARD(1);
}
impl _NVVIOVIDEOSTANDARD {
    pub const NVVIOVIDEOSTANDARD_SMPTE274: _NVVIOVIDEOSTANDARD = _NVVIOVIDEOSTANDARD(2);
}
impl _NVVIOVIDEOSTANDARD {
    pub const NVVIOVIDEOSTANDARD_SMPTE295: _NVVIOVIDEOSTANDARD = _NVVIOVIDEOSTANDARD(3);
}
impl _NVVIOVIDEOSTANDARD {
    pub const NVVIOVIDEOSTANDARD_SMPTE296: _NVVIOVIDEOSTANDARD = _NVVIOVIDEOSTANDARD(4);
}
impl _NVVIOVIDEOSTANDARD {
    pub const NVVIOVIDEOSTANDARD_SMPTE372: _NVVIOVIDEOSTANDARD = _NVVIOVIDEOSTANDARD(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOVIDEOSTANDARD(pub ::std::os::raw::c_int);
pub use self::_NVVIOVIDEOSTANDARD as NVVIOVIDEOSTANDARD;
impl _NVVIOVIDEOTYPE {
    pub const NVVIOVIDEOTYPE_SD: _NVVIOVIDEOTYPE = _NVVIOVIDEOTYPE(0);
}
impl _NVVIOVIDEOTYPE {
    pub const NVVIOVIDEOTYPE_HD: _NVVIOVIDEOTYPE = _NVVIOVIDEOTYPE(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOVIDEOTYPE(pub ::std::os::raw::c_int);
pub use self::_NVVIOVIDEOTYPE as NVVIOVIDEOTYPE;
impl _NVVIOINTERLACEMODE {
    pub const NVVIOINTERLACEMODE_PROGRESSIVE: _NVVIOINTERLACEMODE = _NVVIOINTERLACEMODE(0);
}
impl _NVVIOINTERLACEMODE {
    pub const NVVIOINTERLACEMODE_INTERLACE: _NVVIOINTERLACEMODE = _NVVIOINTERLACEMODE(1);
}
impl _NVVIOINTERLACEMODE {
    pub const NVVIOINTERLACEMODE_PSF: _NVVIOINTERLACEMODE = _NVVIOINTERLACEMODE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOINTERLACEMODE(pub ::std::os::raw::c_int);
pub use self::_NVVIOINTERLACEMODE as NVVIOINTERLACEMODE;
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_UNKNOWN: _NVVIODATAFORMAT = _NVVIODATAFORMAT(-1);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R8G8B8_TO_YCRCB444: _NVVIODATAFORMAT = _NVVIODATAFORMAT(0);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4444: _NVVIODATAFORMAT = _NVVIODATAFORMAT(1);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4444: _NVVIODATAFORMAT = _NVVIODATAFORMAT(2);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R8G8B8_TO_YCRCB422: _NVVIODATAFORMAT = _NVVIODATAFORMAT(3);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4224: _NVVIODATAFORMAT = _NVVIODATAFORMAT(4);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4224: _NVVIODATAFORMAT = _NVVIODATAFORMAT(5);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_X8X8X8_444_PASSTHRU: _NVVIODATAFORMAT = _NVVIODATAFORMAT(6);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_X8X8X8A8_4444_PASSTHRU: _NVVIODATAFORMAT = _NVVIODATAFORMAT(7);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_X8X8X8Z10_4444_PASSTHRU: _NVVIODATAFORMAT = _NVVIODATAFORMAT(8);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_X10X10X10_444_PASSTHRU: _NVVIODATAFORMAT = _NVVIODATAFORMAT(9);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_X10X8X8_444_PASSTHRU: _NVVIODATAFORMAT = _NVVIODATAFORMAT(10);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_X10X8X8A10_4444_PASSTHRU: _NVVIODATAFORMAT = _NVVIODATAFORMAT(11);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_X10X8X8Z10_4444_PASSTHRU: _NVVIODATAFORMAT = _NVVIODATAFORMAT(12);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_DUAL_R8G8B8_TO_DUAL_YCRCB422: _NVVIODATAFORMAT = _NVVIODATAFORMAT(13);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_DUAL_X8X8X8_TO_DUAL_422_PASSTHRU: _NVVIODATAFORMAT =
        _NVVIODATAFORMAT(14);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R10G10B10_TO_YCRCB422: _NVVIODATAFORMAT = _NVVIODATAFORMAT(15);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R10G10B10_TO_YCRCB444: _NVVIODATAFORMAT = _NVVIODATAFORMAT(16);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_X12X12X12_444_PASSTHRU: _NVVIODATAFORMAT = _NVVIODATAFORMAT(17);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_X12X12X12_422_PASSTHRU: _NVVIODATAFORMAT = _NVVIODATAFORMAT(18);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_Y10CR10CB10_TO_YCRCB422: _NVVIODATAFORMAT = _NVVIODATAFORMAT(19);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_Y8CR8CB8_TO_YCRCB422: _NVVIODATAFORMAT = _NVVIODATAFORMAT(20);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_Y10CR8CB8A10_TO_YCRCBA4224: _NVVIODATAFORMAT = _NVVIODATAFORMAT(21);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R10G10B10_TO_RGB444: _NVVIODATAFORMAT = _NVVIODATAFORMAT(22);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R12G12B12_TO_YCRCB444: _NVVIODATAFORMAT = _NVVIODATAFORMAT(23);
}
impl _NVVIODATAFORMAT {
    pub const NVVIODATAFORMAT_R12G12B12_TO_YCRCB422: _NVVIODATAFORMAT = _NVVIODATAFORMAT(24);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIODATAFORMAT(pub ::std::os::raw::c_int);
pub use self::_NVVIODATAFORMAT as NVVIODATAFORMAT;
impl _NVVIOOUTPUTAREA {
    pub const NVVIOOUTPUTAREA_FULLSIZE: _NVVIOOUTPUTAREA = _NVVIOOUTPUTAREA(0);
}
impl _NVVIOOUTPUTAREA {
    pub const NVVIOOUTPUTAREA_SAFEACTION: _NVVIOOUTPUTAREA = _NVVIOOUTPUTAREA(1);
}
impl _NVVIOOUTPUTAREA {
    pub const NVVIOOUTPUTAREA_SAFETITLE: _NVVIOOUTPUTAREA = _NVVIOOUTPUTAREA(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOOUTPUTAREA(pub ::std::os::raw::c_int);
pub use self::_NVVIOOUTPUTAREA as NVVIOOUTPUTAREA;
impl _NVVIOSYNCSOURCE {
    pub const NVVIOSYNCSOURCE_SDISYNC: _NVVIOSYNCSOURCE = _NVVIOSYNCSOURCE(0);
}
impl _NVVIOSYNCSOURCE {
    pub const NVVIOSYNCSOURCE_COMPSYNC: _NVVIOSYNCSOURCE = _NVVIOSYNCSOURCE(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOSYNCSOURCE(pub ::std::os::raw::c_int);
pub use self::_NVVIOSYNCSOURCE as NVVIOSYNCSOURCE;
impl _NVVIOCOMPSYNCTYPE {
    pub const NVVIOCOMPSYNCTYPE_AUTO: _NVVIOCOMPSYNCTYPE = _NVVIOCOMPSYNCTYPE(0);
}
impl _NVVIOCOMPSYNCTYPE {
    pub const NVVIOCOMPSYNCTYPE_BILEVEL: _NVVIOCOMPSYNCTYPE = _NVVIOCOMPSYNCTYPE(1);
}
impl _NVVIOCOMPSYNCTYPE {
    pub const NVVIOCOMPSYNCTYPE_TRILEVEL: _NVVIOCOMPSYNCTYPE = _NVVIOCOMPSYNCTYPE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOCOMPSYNCTYPE(pub ::std::os::raw::c_int);
pub use self::_NVVIOCOMPSYNCTYPE as NVVIOCOMPSYNCTYPE;
impl _NVVIOINPUTOUTPUTSTATUS {
    pub const NVINPUTOUTPUTSTATUS_OFF: _NVVIOINPUTOUTPUTSTATUS = _NVVIOINPUTOUTPUTSTATUS(0);
}
impl _NVVIOINPUTOUTPUTSTATUS {
    pub const NVINPUTOUTPUTSTATUS_ERROR: _NVVIOINPUTOUTPUTSTATUS = _NVVIOINPUTOUTPUTSTATUS(1);
}
impl _NVVIOINPUTOUTPUTSTATUS {
    pub const NVINPUTOUTPUTSTATUS_SDI_SD: _NVVIOINPUTOUTPUTSTATUS = _NVVIOINPUTOUTPUTSTATUS(2);
}
impl _NVVIOINPUTOUTPUTSTATUS {
    pub const NVINPUTOUTPUTSTATUS_SDI_HD: _NVVIOINPUTOUTPUTSTATUS = _NVVIOINPUTOUTPUTSTATUS(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOINPUTOUTPUTSTATUS(pub ::std::os::raw::c_int);
pub use self::_NVVIOINPUTOUTPUTSTATUS as NVVIOINPUTOUTPUTSTATUS;
impl _NVVIOSYNCSTATUS {
    pub const NVVIOSYNCSTATUS_OFF: _NVVIOSYNCSTATUS = _NVVIOSYNCSTATUS(0);
}
impl _NVVIOSYNCSTATUS {
    pub const NVVIOSYNCSTATUS_ERROR: _NVVIOSYNCSTATUS = _NVVIOSYNCSTATUS(1);
}
impl _NVVIOSYNCSTATUS {
    pub const NVVIOSYNCSTATUS_SYNCLOSS: _NVVIOSYNCSTATUS = _NVVIOSYNCSTATUS(2);
}
impl _NVVIOSYNCSTATUS {
    pub const NVVIOSYNCSTATUS_COMPOSITE: _NVVIOSYNCSTATUS = _NVVIOSYNCSTATUS(3);
}
impl _NVVIOSYNCSTATUS {
    pub const NVVIOSYNCSTATUS_SDI_SD: _NVVIOSYNCSTATUS = _NVVIOSYNCSTATUS(4);
}
impl _NVVIOSYNCSTATUS {
    pub const NVVIOSYNCSTATUS_SDI_HD: _NVVIOSYNCSTATUS = _NVVIOSYNCSTATUS(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOSYNCSTATUS(pub ::std::os::raw::c_int);
pub use self::_NVVIOSYNCSTATUS as NVVIOSYNCSTATUS;
impl _NVVIOCAPTURESTATUS {
    pub const NVVIOSTATUS_STOPPED: _NVVIOCAPTURESTATUS = _NVVIOCAPTURESTATUS(0);
}
impl _NVVIOCAPTURESTATUS {
    pub const NVVIOSTATUS_RUNNING: _NVVIOCAPTURESTATUS = _NVVIOCAPTURESTATUS(1);
}
impl _NVVIOCAPTURESTATUS {
    pub const NVVIOSTATUS_ERROR: _NVVIOCAPTURESTATUS = _NVVIOCAPTURESTATUS(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOCAPTURESTATUS(pub ::std::os::raw::c_int);
pub use self::_NVVIOCAPTURESTATUS as NVVIOCAPTURESTATUS;
impl _NVVIOSTATUSTYPE {
    pub const NVVIOSTATUSTYPE_IN: _NVVIOSTATUSTYPE = _NVVIOSTATUSTYPE(0);
}
impl _NVVIOSTATUSTYPE {
    pub const NVVIOSTATUSTYPE_OUT: _NVVIOSTATUSTYPE = _NVVIOSTATUSTYPE(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOSTATUSTYPE(pub ::std::os::raw::c_int);
pub use self::_NVVIOSTATUSTYPE as NVVIOSTATUSTYPE;
impl _NVVIOCONFIGTYPE {
    pub const NVVIOCONFIGTYPE_IN: _NVVIOCONFIGTYPE = _NVVIOCONFIGTYPE(0);
}
impl _NVVIOCONFIGTYPE {
    pub const NVVIOCONFIGTYPE_OUT: _NVVIOCONFIGTYPE = _NVVIOCONFIGTYPE(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOCONFIGTYPE(pub ::std::os::raw::c_int);
pub use self::_NVVIOCONFIGTYPE as NVVIOCONFIGTYPE;
impl _NVVIOCOLORSPACE {
    pub const NVVIOCOLORSPACE_UNKNOWN: _NVVIOCOLORSPACE = _NVVIOCOLORSPACE(0);
}
impl _NVVIOCOLORSPACE {
    pub const NVVIOCOLORSPACE_YCBCR: _NVVIOCOLORSPACE = _NVVIOCOLORSPACE(1);
}
impl _NVVIOCOLORSPACE {
    pub const NVVIOCOLORSPACE_YCBCRA: _NVVIOCOLORSPACE = _NVVIOCOLORSPACE(2);
}
impl _NVVIOCOLORSPACE {
    pub const NVVIOCOLORSPACE_YCBCRD: _NVVIOCOLORSPACE = _NVVIOCOLORSPACE(3);
}
impl _NVVIOCOLORSPACE {
    pub const NVVIOCOLORSPACE_GBR: _NVVIOCOLORSPACE = _NVVIOCOLORSPACE(4);
}
impl _NVVIOCOLORSPACE {
    pub const NVVIOCOLORSPACE_GBRA: _NVVIOCOLORSPACE = _NVVIOCOLORSPACE(5);
}
impl _NVVIOCOLORSPACE {
    pub const NVVIOCOLORSPACE_GBRD: _NVVIOCOLORSPACE = _NVVIOCOLORSPACE(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOCOLORSPACE(pub ::std::os::raw::c_int);
pub use self::_NVVIOCOLORSPACE as NVVIOCOLORSPACE;
impl _NVVIOCOMPONENTSAMPLING {
    pub const NVVIOCOMPONENTSAMPLING_UNKNOWN: _NVVIOCOMPONENTSAMPLING = _NVVIOCOMPONENTSAMPLING(0);
}
impl _NVVIOCOMPONENTSAMPLING {
    pub const NVVIOCOMPONENTSAMPLING_4444: _NVVIOCOMPONENTSAMPLING = _NVVIOCOMPONENTSAMPLING(1);
}
impl _NVVIOCOMPONENTSAMPLING {
    pub const NVVIOCOMPONENTSAMPLING_4224: _NVVIOCOMPONENTSAMPLING = _NVVIOCOMPONENTSAMPLING(2);
}
impl _NVVIOCOMPONENTSAMPLING {
    pub const NVVIOCOMPONENTSAMPLING_444: _NVVIOCOMPONENTSAMPLING = _NVVIOCOMPONENTSAMPLING(3);
}
impl _NVVIOCOMPONENTSAMPLING {
    pub const NVVIOCOMPONENTSAMPLING_422: _NVVIOCOMPONENTSAMPLING = _NVVIOCOMPONENTSAMPLING(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOCOMPONENTSAMPLING(pub ::std::os::raw::c_int);
pub use self::_NVVIOCOMPONENTSAMPLING as NVVIOCOMPONENTSAMPLING;
impl _NVVIOBITSPERCOMPONENT {
    pub const NVVIOBITSPERCOMPONENT_UNKNOWN: _NVVIOBITSPERCOMPONENT = _NVVIOBITSPERCOMPONENT(0);
}
impl _NVVIOBITSPERCOMPONENT {
    pub const NVVIOBITSPERCOMPONENT_8: _NVVIOBITSPERCOMPONENT = _NVVIOBITSPERCOMPONENT(1);
}
impl _NVVIOBITSPERCOMPONENT {
    pub const NVVIOBITSPERCOMPONENT_10: _NVVIOBITSPERCOMPONENT = _NVVIOBITSPERCOMPONENT(2);
}
impl _NVVIOBITSPERCOMPONENT {
    pub const NVVIOBITSPERCOMPONENT_12: _NVVIOBITSPERCOMPONENT = _NVVIOBITSPERCOMPONENT(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOBITSPERCOMPONENT(pub ::std::os::raw::c_int);
pub use self::_NVVIOBITSPERCOMPONENT as NVVIOBITSPERCOMPONENT;
impl _NVVIOLINKID {
    pub const NVVIOLINKID_UNKNOWN: _NVVIOLINKID = _NVVIOLINKID(0);
}
impl _NVVIOLINKID {
    pub const NVVIOLINKID_A: _NVVIOLINKID = _NVVIOLINKID(1);
}
impl _NVVIOLINKID {
    pub const NVVIOLINKID_B: _NVVIOLINKID = _NVVIOLINKID(2);
}
impl _NVVIOLINKID {
    pub const NVVIOLINKID_C: _NVVIOLINKID = _NVVIOLINKID(3);
}
impl _NVVIOLINKID {
    pub const NVVIOLINKID_D: _NVVIOLINKID = _NVVIOLINKID(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOLINKID(pub ::std::os::raw::c_int);
pub use self::_NVVIOLINKID as NVVIOLINKID;
impl _NVVIOANCPARITYCOMPUTATION {
    pub const NVVIOANCPARITYCOMPUTATION_AUTO: _NVVIOANCPARITYCOMPUTATION =
        _NVVIOANCPARITYCOMPUTATION(0);
}
impl _NVVIOANCPARITYCOMPUTATION {
    pub const NVVIOANCPARITYCOMPUTATION_ON: _NVVIOANCPARITYCOMPUTATION =
        _NVVIOANCPARITYCOMPUTATION(1);
}
impl _NVVIOANCPARITYCOMPUTATION {
    pub const NVVIOANCPARITYCOMPUTATION_OFF: _NVVIOANCPARITYCOMPUTATION =
        _NVVIOANCPARITYCOMPUTATION(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOANCPARITYCOMPUTATION(pub ::std::os::raw::c_int);
pub use self::_NVVIOANCPARITYCOMPUTATION as NVVIOANCPARITYCOMPUTATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCAPS {
    pub version: NvU32,
    pub adapterName: NvAPI_String,
    pub adapterClass: NvU32,
    pub adapterCaps: NvU32,
    pub dipSwitch: NvU32,
    pub dipSwitchReserved: NvU32,
    pub boardID: NvU32,
    pub driver: _NVVIOCAPS__bindgen_ty_1,
    pub firmWare: _NVVIOCAPS__bindgen_ty_2,
    pub ownerId: NVVIOOWNERID,
    pub ownerType: NVVIOOWNERTYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCAPS__bindgen_ty_1 {
    pub majorVersion: NvU32,
    pub minorVersion: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCAPS__bindgen_ty_2 {
    pub majorVersion: NvU32,
    pub minorVersion: NvU32,
}
pub type NVVIOCAPS = _NVVIOCAPS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCHANNELSTATUS {
    pub smpte352: NvU32,
    pub signalFormat: NVVIOSIGNALFORMAT,
    pub bitsPerComponent: NVVIOBITSPERCOMPONENT,
    pub samplingFormat: NVVIOCOMPONENTSAMPLING,
    pub colorSpace: NVVIOCOLORSPACE,
    pub linkID: NVVIOLINKID,
}
pub type NVVIOCHANNELSTATUS = _NVVIOCHANNELSTATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOINPUTSTATUS {
    pub vidIn: [[NVVIOCHANNELSTATUS; 2usize]; 4usize],
    pub captureStatus: NVVIOCAPTURESTATUS,
}
pub type NVVIOINPUTSTATUS = _NVVIOINPUTSTATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTSTATUS {
    pub vid1Out: NVVIOINPUTOUTPUTSTATUS,
    pub vid2Out: NVVIOINPUTOUTPUTSTATUS,
    pub sdiSyncIn: NVVIOSYNCSTATUS,
    pub compSyncIn: NVVIOSYNCSTATUS,
    pub syncEnable: NvU32,
    pub syncSource: NVVIOSYNCSOURCE,
    pub syncFormat: NVVIOSIGNALFORMAT,
    pub frameLockEnable: NvU32,
    pub outputVideoLocked: NvU32,
    pub dataIntegrityCheckErrorCount: NvU32,
    pub dataIntegrityCheckEnabled: NvU32,
    pub dataIntegrityCheckFailed: NvU32,
    pub uSyncSourceLocked: NvU32,
    pub uPowerOn: NvU32,
}
pub type NVVIOOUTPUTSTATUS = _NVVIOOUTPUTSTATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOSTATUS {
    pub version: NvU32,
    pub nvvioStatusType: NVVIOSTATUSTYPE,
    pub vioStatus: _NVVIOSTATUS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOSTATUS__bindgen_ty_1 {
    pub inStatus: NVVIOINPUTSTATUS,
    pub outStatus: NVVIOOUTPUTSTATUS,
}
pub type NVVIOSTATUS = _NVVIOSTATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTREGION {
    pub x: NvU32,
    pub y: NvU32,
    pub width: NvU32,
    pub height: NvU32,
}
pub type NVVIOOUTPUTREGION = _NVVIOOUTPUTREGION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOGAMMARAMP8 {
    pub uRed: [NvU16; 256usize],
    pub uGreen: [NvU16; 256usize],
    pub uBlue: [NvU16; 256usize],
}
pub type NVVIOGAMMARAMP8 = _NVVIOGAMMARAMP8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOGAMMARAMP10 {
    pub uRed: [NvU16; 1024usize],
    pub uGreen: [NvU16; 1024usize],
    pub uBlue: [NvU16; 1024usize],
}
pub type NVVIOGAMMARAMP10 = _NVVIOGAMMARAMP10;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOSYNCDELAY {
    pub version: NvU32,
    pub horizontalDelay: NvU32,
    pub verticalDelay: NvU32,
}
pub type NVVIOSYNCDELAY = _NVVIOSYNCDELAY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOVIDEOMODE {
    pub horizontalPixels: NvU32,
    pub verticalLines: NvU32,
    pub fFrameRate: f32,
    pub interlaceMode: NVVIOINTERLACEMODE,
    pub videoStandard: NVVIOVIDEOSTANDARD,
    pub videoType: NVVIOVIDEOTYPE,
}
pub type NVVIOVIDEOMODE = _NVVIOVIDEOMODE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOSIGNALFORMATDETAIL {
    pub signalFormat: NVVIOSIGNALFORMAT,
    pub videoMode: NVVIOVIDEOMODE,
}
pub type NVVIOSIGNALFORMATDETAIL = _NVVIOSIGNALFORMATDETAIL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIODATAFORMATDETAIL {
    pub dataFormat: NVVIODATAFORMAT,
    pub vioCaps: NvU32,
}
pub type NVVIODATAFORMATDETAIL = _NVVIODATAFORMATDETAIL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCOLORCONVERSION {
    pub version: NvU32,
    pub colorMatrix: [[f32; 3usize]; 3usize],
    pub colorOffset: [f32; 3usize],
    pub colorScale: [f32; 3usize],
    pub compositeSafe: NvU32,
}
pub type NVVIOCOLORCONVERSION = _NVVIOCOLORCONVERSION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOGAMMACORRECTION {
    pub version: NvU32,
    pub vioGammaCorrectionType: NvU32,
    pub gammaRamp: _NVVIOGAMMACORRECTION__bindgen_ty_1,
    pub fGammaValueR: f32,
    pub fGammaValueG: f32,
    pub fGammaValueB: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOGAMMACORRECTION__bindgen_ty_1 {
    pub gammaRamp8: NVVIOGAMMARAMP8,
    pub gammaRamp10: NVVIOGAMMARAMP10,
}
pub type NVVIOGAMMACORRECTION = _NVVIOGAMMACORRECTION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCOMPOSITERANGE {
    pub uRange: NvU32,
    pub uEnabled: NvU32,
    pub uMin: NvU32,
    pub uMax: NvU32,
}
pub type NVVIOCOMPOSITERANGE = _NVVIOCOMPOSITERANGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTCONFIG_V1 {
    pub signalFormat: NVVIOSIGNALFORMAT,
    pub dataFormat: NVVIODATAFORMAT,
    pub outputRegion: NVVIOOUTPUTREGION,
    pub outputArea: NVVIOOUTPUTAREA,
    pub colorConversion: NVVIOCOLORCONVERSION,
    pub gammaCorrection: NVVIOGAMMACORRECTION,
    pub syncEnable: NvU32,
    pub syncSource: NVVIOSYNCSOURCE,
    pub syncDelay: NVVIOSYNCDELAY,
    pub compositeSyncType: NVVIOCOMPSYNCTYPE,
    pub frameLockEnable: NvU32,
    pub psfSignalFormat: NvU32,
    pub enable422Filter: NvU32,
    pub compositeTerminate: NvU32,
    pub enableDataIntegrityCheck: NvU32,
    pub cscOverride: NvU32,
    pub flipQueueLength: NvU32,
    pub enableANCTimeCodeGeneration: NvU32,
    pub enableComposite: NvU32,
    pub enableAlphaKeyComposite: NvU32,
    pub compRange: NVVIOCOMPOSITERANGE,
    pub reservedData: [NvU8; 256usize],
    pub enableFullColorRange: NvU32,
    pub enableRGBData: NvU32,
}
pub type NVVIOOUTPUTCONFIG_V1 = _NVVIOOUTPUTCONFIG_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTCONFIG_V2 {
    pub signalFormat: NVVIOSIGNALFORMAT,
    pub dataFormat: NVVIODATAFORMAT,
    pub outputRegion: NVVIOOUTPUTREGION,
    pub outputArea: NVVIOOUTPUTAREA,
    pub colorConversion: NVVIOCOLORCONVERSION,
    pub gammaCorrection: NVVIOGAMMACORRECTION,
    pub syncEnable: NvU32,
    pub syncSource: NVVIOSYNCSOURCE,
    pub syncDelay: NVVIOSYNCDELAY,
    pub compositeSyncType: NVVIOCOMPSYNCTYPE,
    pub frameLockEnable: NvU32,
    pub psfSignalFormat: NvU32,
    pub enable422Filter: NvU32,
    pub compositeTerminate: NvU32,
    pub enableDataIntegrityCheck: NvU32,
    pub cscOverride: NvU32,
    pub flipQueueLength: NvU32,
    pub enableANCTimeCodeGeneration: NvU32,
    pub enableComposite: NvU32,
    pub enableAlphaKeyComposite: NvU32,
    pub compRange: NVVIOCOMPOSITERANGE,
    pub reservedData: [NvU8; 256usize],
    pub enableFullColorRange: NvU32,
    pub enableRGBData: NvU32,
    pub ancParityComputation: NVVIOANCPARITYCOMPUTATION,
}
pub type NVVIOOUTPUTCONFIG_V2 = _NVVIOOUTPUTCONFIG_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOOUTPUTCONFIG_V3 {
    pub signalFormat: NVVIOSIGNALFORMAT,
    pub dataFormat: NVVIODATAFORMAT,
    pub outputRegion: NVVIOOUTPUTREGION,
    pub outputArea: NVVIOOUTPUTAREA,
    pub colorConversion: NVVIOCOLORCONVERSION,
    pub gammaCorrection: NVVIOGAMMACORRECTION,
    pub syncEnable: NvU32,
    pub syncSource: NVVIOSYNCSOURCE,
    pub syncDelay: NVVIOSYNCDELAY,
    pub compositeSyncType: NVVIOCOMPSYNCTYPE,
    pub frameLockEnable: NvU32,
    pub psfSignalFormat: NvU32,
    pub enable422Filter: NvU32,
    pub compositeTerminate: NvU32,
    pub enableDataIntegrityCheck: NvU32,
    pub cscOverride: NvU32,
    pub flipQueueLength: NvU32,
    pub enableANCTimeCodeGeneration: NvU32,
    pub enableComposite: NvU32,
    pub enableAlphaKeyComposite: NvU32,
    pub compRange: NVVIOCOMPOSITERANGE,
    pub reservedData: [NvU8; 256usize],
    pub enableFullColorRange: NvU32,
    pub enableRGBData: NvU32,
    pub ancParityComputation: NVVIOANCPARITYCOMPUTATION,
    pub enableAudioBlanking: NvU32,
}
pub type NVVIOOUTPUTCONFIG_V3 = _NVVIOOUTPUTCONFIG_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOSTREAM {
    pub bitsPerComponent: NvU32,
    pub sampling: NVVIOCOMPONENTSAMPLING,
    pub expansionEnable: NvU32,
    pub numLinks: NvU32,
    pub links: [_NVVIOSTREAM__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOSTREAM__bindgen_ty_1 {
    pub jack: NvU32,
    pub channel: NvU32,
}
pub type NVVIOSTREAM = _NVVIOSTREAM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOINPUTCONFIG {
    pub numRawCaptureImages: NvU32,
    pub signalFormat: NVVIOSIGNALFORMAT,
    pub numStreams: NvU32,
    pub streams: [NVVIOSTREAM; 4usize],
    pub bTestMode: NvU32,
}
pub type NVVIOINPUTCONFIG = _NVVIOINPUTCONFIG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCONFIG_V1 {
    pub version: NvU32,
    pub fields: NvU32,
    pub nvvioConfigType: NVVIOCONFIGTYPE,
    pub vioConfig: _NVVIOCONFIG_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOCONFIG_V1__bindgen_ty_1 {
    pub inConfig: NVVIOINPUTCONFIG,
    pub outConfig: NVVIOOUTPUTCONFIG_V1,
}
pub type NVVIOCONFIG_V1 = _NVVIOCONFIG_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCONFIG_V2 {
    pub version: NvU32,
    pub fields: NvU32,
    pub nvvioConfigType: NVVIOCONFIGTYPE,
    pub vioConfig: _NVVIOCONFIG_V2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOCONFIG_V2__bindgen_ty_1 {
    pub inConfig: NVVIOINPUTCONFIG,
    pub outConfig: NVVIOOUTPUTCONFIG_V2,
}
pub type NVVIOCONFIG_V2 = _NVVIOCONFIG_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOCONFIG_V3 {
    pub version: NvU32,
    pub fields: NvU32,
    pub nvvioConfigType: NVVIOCONFIGTYPE,
    pub vioConfig: _NVVIOCONFIG_V3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVVIOCONFIG_V3__bindgen_ty_1 {
    pub inConfig: NVVIOINPUTCONFIG,
    pub outConfig: NVVIOOUTPUTCONFIG_V3,
}
pub type NVVIOCONFIG_V3 = _NVVIOCONFIG_V3;
pub type NVVIOOUTPUTCONFIG = NVVIOOUTPUTCONFIG_V3;
pub type NVVIOCONFIG = NVVIOCONFIG_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVVIOTOPOLOGYTARGET {
    pub hPhysicalGpu: NvPhysicalGpuHandle,
    pub hVioHandle: NvVioHandle,
    pub vioId: NvU32,
    pub outputId: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_VIO_TOPOLOGY {
    pub version: NvU32,
    pub vioTotalDeviceCount: NvU32,
    pub vioTarget: [NVVIOTOPOLOGYTARGET; 8usize],
}
pub type NV_VIO_TOPOLOGY = _NV_VIO_TOPOLOGY;
pub type NVVIOTOPOLOGY = _NV_VIO_TOPOLOGY;
impl _NVVIOPCILINKRATE {
    pub const NVVIOPCILINKRATE_UNKNOWN: _NVVIOPCILINKRATE = _NVVIOPCILINKRATE(0);
}
impl _NVVIOPCILINKRATE {
    pub const NVVIOPCILINKRATE_GEN1: _NVVIOPCILINKRATE = _NVVIOPCILINKRATE(1);
}
impl _NVVIOPCILINKRATE {
    pub const NVVIOPCILINKRATE_GEN2: _NVVIOPCILINKRATE = _NVVIOPCILINKRATE(2);
}
impl _NVVIOPCILINKRATE {
    pub const NVVIOPCILINKRATE_GEN3: _NVVIOPCILINKRATE = _NVVIOPCILINKRATE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOPCILINKRATE(pub ::std::os::raw::c_int);
pub use self::_NVVIOPCILINKRATE as NVVIOPCILINKRATE;
impl _NVVIOPCILINKWIDTH {
    pub const NVVIOPCILINKWIDTH_UNKNOWN: _NVVIOPCILINKWIDTH = _NVVIOPCILINKWIDTH(0);
}
impl _NVVIOPCILINKWIDTH {
    pub const NVVIOPCILINKWIDTH_x1: _NVVIOPCILINKWIDTH = _NVVIOPCILINKWIDTH(1);
}
impl _NVVIOPCILINKWIDTH {
    pub const NVVIOPCILINKWIDTH_x2: _NVVIOPCILINKWIDTH = _NVVIOPCILINKWIDTH(2);
}
impl _NVVIOPCILINKWIDTH {
    pub const NVVIOPCILINKWIDTH_x4: _NVVIOPCILINKWIDTH = _NVVIOPCILINKWIDTH(4);
}
impl _NVVIOPCILINKWIDTH {
    pub const NVVIOPCILINKWIDTH_x8: _NVVIOPCILINKWIDTH = _NVVIOPCILINKWIDTH(8);
}
impl _NVVIOPCILINKWIDTH {
    pub const NVVIOPCILINKWIDTH_x16: _NVVIOPCILINKWIDTH = _NVVIOPCILINKWIDTH(16);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVVIOPCILINKWIDTH(pub ::std::os::raw::c_int);
pub use self::_NVVIOPCILINKWIDTH as NVVIOPCILINKWIDTH;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVVIOPCIINFO {
    pub version: NvU32,
    pub pciDeviceId: NvU32,
    pub pciSubSystemId: NvU32,
    pub pciRevisionId: NvU32,
    pub pciDomain: NvU32,
    pub pciBus: NvU32,
    pub pciSlot: NvU32,
    pub pciLinkWidth: NVVIOPCILINKWIDTH,
    pub pciLinkRate: NVVIOPCILINKRATE,
}
pub type NVVIOPCIINFO_V1 = _NVVIOPCIINFO;
pub type NVVIOPCIINFO = NVVIOPCIINFO_V1;
impl _NV_StereoRegistryProfileType {
    pub const NVAPI_STEREO_DEFAULT_REGISTRY_PROFILE: _NV_StereoRegistryProfileType =
        _NV_StereoRegistryProfileType(0);
}
impl _NV_StereoRegistryProfileType {
    pub const NVAPI_STEREO_DX9_REGISTRY_PROFILE: _NV_StereoRegistryProfileType =
        _NV_StereoRegistryProfileType(1);
}
impl _NV_StereoRegistryProfileType {
    pub const NVAPI_STEREO_DX10_REGISTRY_PROFILE: _NV_StereoRegistryProfileType =
        _NV_StereoRegistryProfileType(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_StereoRegistryProfileType(pub ::std::os::raw::c_int);
pub use self::_NV_StereoRegistryProfileType as NV_STEREO_REGISTRY_PROFILE_TYPE;
impl _NV_StereoRegistryID {
    pub const NVAPI_CONVERGENCE_ID: _NV_StereoRegistryID = _NV_StereoRegistryID(0);
}
impl _NV_StereoRegistryID {
    pub const NVAPI_FRUSTUM_ADJUST_MODE_ID: _NV_StereoRegistryID = _NV_StereoRegistryID(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_StereoRegistryID(pub ::std::os::raw::c_int);
pub use self::_NV_StereoRegistryID as NV_STEREO_REGISTRY_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVAPI_STEREO_CAPS {
    pub version: NvU32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved2: [NvU32; 3usize],
}
impl _NVAPI_STEREO_CAPS {
    #[inline]
    pub fn supportsWindowedModeOff(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsWindowedModeOff(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportsWindowedModeAutomatic(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsWindowedModeAutomatic(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supportsWindowedModePersistent(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supportsWindowedModePersistent(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supportsWindowedModeOff: NvU32,
        supportsWindowedModeAutomatic: NvU32,
        supportsWindowedModePersistent: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supportsWindowedModeOff: u32 =
                unsafe { ::std::mem::transmute(supportsWindowedModeOff) };
            supportsWindowedModeOff as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let supportsWindowedModeAutomatic: u32 =
                unsafe { ::std::mem::transmute(supportsWindowedModeAutomatic) };
            supportsWindowedModeAutomatic as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let supportsWindowedModePersistent: u32 =
                unsafe { ::std::mem::transmute(supportsWindowedModePersistent) };
            supportsWindowedModePersistent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVAPI_STEREO_CAPS_V1 = _NVAPI_STEREO_CAPS;
pub type NVAPI_STEREO_CAPS = NVAPI_STEREO_CAPS_V1;
impl _NV_FrustumAdjustMode {
    pub const NVAPI_NO_FRUSTUM_ADJUST: _NV_FrustumAdjustMode = _NV_FrustumAdjustMode(0);
}
impl _NV_FrustumAdjustMode {
    pub const NVAPI_FRUSTUM_STRETCH: _NV_FrustumAdjustMode = _NV_FrustumAdjustMode(1);
}
impl _NV_FrustumAdjustMode {
    pub const NVAPI_FRUSTUM_CLEAR_EDGES: _NV_FrustumAdjustMode = _NV_FrustumAdjustMode(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_FrustumAdjustMode(pub ::std::os::raw::c_int);
pub use self::_NV_FrustumAdjustMode as NV_FRUSTUM_ADJUST_MODE;
impl _NVAPI_STEREO_INIT_ACTIVATION_FLAGS {
    pub const NVAPI_STEREO_INIT_ACTIVATION_IMMEDIATE: _NVAPI_STEREO_INIT_ACTIVATION_FLAGS =
        _NVAPI_STEREO_INIT_ACTIVATION_FLAGS(0);
}
impl _NVAPI_STEREO_INIT_ACTIVATION_FLAGS {
    pub const NVAPI_STEREO_INIT_ACTIVATION_DELAYED: _NVAPI_STEREO_INIT_ACTIVATION_FLAGS =
        _NVAPI_STEREO_INIT_ACTIVATION_FLAGS(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVAPI_STEREO_INIT_ACTIVATION_FLAGS(pub ::std::os::raw::c_int);
pub use self::_NVAPI_STEREO_INIT_ACTIVATION_FLAGS as NVAPI_STEREO_INIT_ACTIVATION_FLAGS;
impl _NV_StereoSwapChainMode {
    pub const NVAPI_STEREO_SWAPCHAIN_DEFAULT: _NV_StereoSwapChainMode = _NV_StereoSwapChainMode(0);
}
impl _NV_StereoSwapChainMode {
    pub const NVAPI_STEREO_SWAPCHAIN_STEREO: _NV_StereoSwapChainMode = _NV_StereoSwapChainMode(1);
}
impl _NV_StereoSwapChainMode {
    pub const NVAPI_STEREO_SWAPCHAIN_MONO: _NV_StereoSwapChainMode = _NV_StereoSwapChainMode(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_StereoSwapChainMode(pub ::std::os::raw::c_int);
pub use self::_NV_StereoSwapChainMode as NV_STEREO_SWAPCHAIN_MODE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvDRSSessionHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvDRSSessionHandle = *mut NvDRSSessionHandle__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NvDRSProfileHandle__ {
    pub unused: ::std::os::raw::c_int,
}
pub type NvDRSProfileHandle = *mut NvDRSProfileHandle__;
impl _NVDRS_SETTING_TYPE {
    pub const NVDRS_DWORD_TYPE: _NVDRS_SETTING_TYPE = _NVDRS_SETTING_TYPE(0);
}
impl _NVDRS_SETTING_TYPE {
    pub const NVDRS_BINARY_TYPE: _NVDRS_SETTING_TYPE = _NVDRS_SETTING_TYPE(1);
}
impl _NVDRS_SETTING_TYPE {
    pub const NVDRS_STRING_TYPE: _NVDRS_SETTING_TYPE = _NVDRS_SETTING_TYPE(2);
}
impl _NVDRS_SETTING_TYPE {
    pub const NVDRS_WSTRING_TYPE: _NVDRS_SETTING_TYPE = _NVDRS_SETTING_TYPE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVDRS_SETTING_TYPE(pub ::std::os::raw::c_int);
pub use self::_NVDRS_SETTING_TYPE as NVDRS_SETTING_TYPE;
impl _NVDRS_SETTING_LOCATION {
    pub const NVDRS_CURRENT_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = _NVDRS_SETTING_LOCATION(0);
}
impl _NVDRS_SETTING_LOCATION {
    pub const NVDRS_GLOBAL_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = _NVDRS_SETTING_LOCATION(1);
}
impl _NVDRS_SETTING_LOCATION {
    pub const NVDRS_BASE_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = _NVDRS_SETTING_LOCATION(2);
}
impl _NVDRS_SETTING_LOCATION {
    pub const NVDRS_DEFAULT_PROFILE_LOCATION: _NVDRS_SETTING_LOCATION = _NVDRS_SETTING_LOCATION(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVDRS_SETTING_LOCATION(pub ::std::os::raw::c_int);
pub use self::_NVDRS_SETTING_LOCATION as NVDRS_SETTING_LOCATION;
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct _NVDRS_GPU_SUPPORT {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NVDRS_GPU_SUPPORT {
    #[inline]
    pub fn geforce(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_geforce(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quadro(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quadro(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nvs(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nvs(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved22(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved22(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved23(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved23(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved30(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved30(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved32(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved32(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        geforce: NvU32,
        quadro: NvU32,
        nvs: NvU32,
        reserved4: NvU32,
        reserved5: NvU32,
        reserved6: NvU32,
        reserved7: NvU32,
        reserved8: NvU32,
        reserved9: NvU32,
        reserved10: NvU32,
        reserved11: NvU32,
        reserved12: NvU32,
        reserved13: NvU32,
        reserved14: NvU32,
        reserved15: NvU32,
        reserved16: NvU32,
        reserved17: NvU32,
        reserved18: NvU32,
        reserved19: NvU32,
        reserved20: NvU32,
        reserved21: NvU32,
        reserved22: NvU32,
        reserved23: NvU32,
        reserved24: NvU32,
        reserved25: NvU32,
        reserved26: NvU32,
        reserved27: NvU32,
        reserved28: NvU32,
        reserved29: NvU32,
        reserved30: NvU32,
        reserved31: NvU32,
        reserved32: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let geforce: u32 = unsafe { ::std::mem::transmute(geforce) };
            geforce as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let quadro: u32 = unsafe { ::std::mem::transmute(quadro) };
            quadro as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let nvs: u32 = unsafe { ::std::mem::transmute(nvs) };
            nvs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved4: u32 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved5: u32 = unsafe { ::std::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let reserved6: u32 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let reserved7: u32 = unsafe { ::std::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let reserved9: u32 = unsafe { ::std::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let reserved10: u32 = unsafe { ::std::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let reserved11: u32 = unsafe { ::std::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved12: u32 = unsafe { ::std::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reserved13: u32 = unsafe { ::std::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved14: u32 = unsafe { ::std::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let reserved15: u32 = unsafe { ::std::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved16: u32 = unsafe { ::std::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let reserved17: u32 = unsafe { ::std::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let reserved18: u32 = unsafe { ::std::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let reserved19: u32 = unsafe { ::std::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let reserved20: u32 = unsafe { ::std::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let reserved21: u32 = unsafe { ::std::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let reserved22: u32 = unsafe { ::std::mem::transmute(reserved22) };
            reserved22 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let reserved23: u32 = unsafe { ::std::mem::transmute(reserved23) };
            reserved23 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let reserved24: u32 = unsafe { ::std::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let reserved25: u32 = unsafe { ::std::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let reserved26: u32 = unsafe { ::std::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let reserved27: u32 = unsafe { ::std::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let reserved28: u32 = unsafe { ::std::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let reserved29: u32 = unsafe { ::std::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let reserved30: u32 = unsafe { ::std::mem::transmute(reserved30) };
            reserved30 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let reserved31: u32 = unsafe { ::std::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved32: u32 = unsafe { ::std::mem::transmute(reserved32) };
            reserved32 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVDRS_GPU_SUPPORT = _NVDRS_GPU_SUPPORT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_BINARY_SETTING {
    pub valueLength: NvU32,
    pub valueData: [NvU8; 4096usize],
}
pub type NVDRS_BINARY_SETTING = _NVDRS_BINARY_SETTING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_SETTING_VALUES {
    pub version: NvU32,
    pub numSettingValues: NvU32,
    pub settingType: NVDRS_SETTING_TYPE,
    pub __bindgen_anon_1: _NVDRS_SETTING_VALUES__bindgen_ty_1,
    pub settingValues: [_NVDRS_SETTING_VALUES__bindgen_ty_2; 100usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_VALUES__bindgen_ty_1 {
    pub u32DefaultValue: NvU32,
    pub binaryDefaultValue: NVDRS_BINARY_SETTING,
    pub wszDefaultValue: NvAPI_UnicodeString,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_VALUES__bindgen_ty_2 {
    pub u32Value: NvU32,
    pub binaryValue: NVDRS_BINARY_SETTING,
    pub wszValue: NvAPI_UnicodeString,
}
pub type NVDRS_SETTING_VALUES = _NVDRS_SETTING_VALUES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_SETTING_V1 {
    pub version: NvU32,
    pub settingName: NvAPI_UnicodeString,
    pub settingId: NvU32,
    pub settingType: NVDRS_SETTING_TYPE,
    pub settingLocation: NVDRS_SETTING_LOCATION,
    pub isCurrentPredefined: NvU32,
    pub isPredefinedValid: NvU32,
    pub __bindgen_anon_1: _NVDRS_SETTING_V1__bindgen_ty_1,
    pub __bindgen_anon_2: _NVDRS_SETTING_V1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_V1__bindgen_ty_1 {
    pub u32PredefinedValue: NvU32,
    pub binaryPredefinedValue: NVDRS_BINARY_SETTING,
    pub wszPredefinedValue: NvAPI_UnicodeString,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NVDRS_SETTING_V1__bindgen_ty_2 {
    pub u32CurrentValue: NvU32,
    pub binaryCurrentValue: NVDRS_BINARY_SETTING,
    pub wszCurrentValue: NvAPI_UnicodeString,
}
pub type NVDRS_SETTING_V1 = _NVDRS_SETTING_V1;
pub type NVDRS_SETTING = NVDRS_SETTING_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_APPLICATION_V1 {
    pub version: NvU32,
    pub isPredefined: NvU32,
    pub appName: NvAPI_UnicodeString,
    pub userFriendlyName: NvAPI_UnicodeString,
    pub launcher: NvAPI_UnicodeString,
}
pub type NVDRS_APPLICATION_V1 = _NVDRS_APPLICATION_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_APPLICATION_V2 {
    pub version: NvU32,
    pub isPredefined: NvU32,
    pub appName: NvAPI_UnicodeString,
    pub userFriendlyName: NvAPI_UnicodeString,
    pub launcher: NvAPI_UnicodeString,
    pub fileInFolder: NvAPI_UnicodeString,
}
pub type NVDRS_APPLICATION_V2 = _NVDRS_APPLICATION_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_APPLICATION_V3 {
    pub version: NvU32,
    pub isPredefined: NvU32,
    pub appName: NvAPI_UnicodeString,
    pub userFriendlyName: NvAPI_UnicodeString,
    pub launcher: NvAPI_UnicodeString,
    pub fileInFolder: NvAPI_UnicodeString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NVDRS_APPLICATION_V3 {
    #[inline]
    pub fn isMetro(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMetro(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCommandLine(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCommandLine(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isMetro: NvU32,
        isCommandLine: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isMetro: u32 = unsafe { ::std::mem::transmute(isMetro) };
            isMetro as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isCommandLine: u32 = unsafe { ::std::mem::transmute(isCommandLine) };
            isCommandLine as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVDRS_APPLICATION_V3 = _NVDRS_APPLICATION_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_APPLICATION_V4 {
    pub version: NvU32,
    pub isPredefined: NvU32,
    pub appName: NvAPI_UnicodeString,
    pub userFriendlyName: NvAPI_UnicodeString,
    pub launcher: NvAPI_UnicodeString,
    pub fileInFolder: NvAPI_UnicodeString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub commandLine: NvAPI_UnicodeString,
}
impl _NVDRS_APPLICATION_V4 {
    #[inline]
    pub fn isMetro(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isMetro(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isCommandLine(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isCommandLine(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isMetro: NvU32,
        isCommandLine: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isMetro: u32 = unsafe { ::std::mem::transmute(isMetro) };
            isMetro as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isCommandLine: u32 = unsafe { ::std::mem::transmute(isCommandLine) };
            isCommandLine as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVDRS_APPLICATION_V4 = _NVDRS_APPLICATION_V4;
pub type NVDRS_APPLICATION = NVDRS_APPLICATION_V4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NVDRS_PROFILE_V1 {
    pub version: NvU32,
    pub profileName: NvAPI_UnicodeString,
    pub gpuSupport: NVDRS_GPU_SUPPORT,
    pub isPredefined: NvU32,
    pub numOfApps: NvU32,
    pub numOfSettings: NvU32,
}
pub type NVDRS_PROFILE_V1 = _NVDRS_PROFILE_V1;
pub type NVDRS_PROFILE = NVDRS_PROFILE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_CHIPSET_INFO_v4 {
    pub version: NvU32,
    pub vendorId: NvU32,
    pub deviceId: NvU32,
    pub szVendorName: NvAPI_ShortString,
    pub szChipsetName: NvAPI_ShortString,
    pub flags: NvU32,
    pub subSysVendorId: NvU32,
    pub subSysDeviceId: NvU32,
    pub szSubSysVendorName: NvAPI_ShortString,
    pub HBvendorId: NvU32,
    pub HBdeviceId: NvU32,
    pub HBsubSysVendorId: NvU32,
    pub HBsubSysDeviceId: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_CHIPSET_INFO_v3 {
    pub version: NvU32,
    pub vendorId: NvU32,
    pub deviceId: NvU32,
    pub szVendorName: NvAPI_ShortString,
    pub szChipsetName: NvAPI_ShortString,
    pub flags: NvU32,
    pub subSysVendorId: NvU32,
    pub subSysDeviceId: NvU32,
    pub szSubSysVendorName: NvAPI_ShortString,
}
impl NV_CHIPSET_INFO_FLAGS {
    pub const NV_CHIPSET_INFO_HYBRID: NV_CHIPSET_INFO_FLAGS = NV_CHIPSET_INFO_FLAGS(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct NV_CHIPSET_INFO_FLAGS(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_CHIPSET_INFO_v2 {
    pub version: NvU32,
    pub vendorId: NvU32,
    pub deviceId: NvU32,
    pub szVendorName: NvAPI_ShortString,
    pub szChipsetName: NvAPI_ShortString,
    pub flags: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_CHIPSET_INFO_v1 {
    pub version: NvU32,
    pub vendorId: NvU32,
    pub deviceId: NvU32,
    pub szVendorName: NvAPI_ShortString,
    pub szChipsetName: NvAPI_ShortString,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NV_LID_DOCK_PARAMS {
    pub version: NvU32,
    pub currentLidState: NvU32,
    pub currentDockState: NvU32,
    pub currentLidPolicy: NvU32,
    pub currentDockPolicy: NvU32,
    pub forcedLidMechanismPresent: NvU32,
    pub forcedDockMechanismPresent: NvU32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAY_DRIVER_INFO {
    pub version: NvU32,
    pub driverVersion: NvU32,
    pub szBuildBranch: NvAPI_ShortString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NV_DISPLAY_DRIVER_INFO {
    #[inline]
    pub fn bIsDCHDriver(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsDCHDriver(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAStudioPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAStudioPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAGameReadyPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAGameReadyPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXProductionBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXProductionBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXNewFeatureBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXNewFeatureBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsDCHDriver: NvU32,
        bIsNVIDIAStudioPackage: NvU32,
        bIsNVIDIAGameReadyPackage: NvU32,
        bIsNVIDIARTXProductionBranchPackage: NvU32,
        bIsNVIDIARTXNewFeatureBranchPackage: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsDCHDriver: u32 = unsafe { ::std::mem::transmute(bIsDCHDriver) };
            bIsDCHDriver as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bIsNVIDIAStudioPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAStudioPackage) };
            bIsNVIDIAStudioPackage as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bIsNVIDIAGameReadyPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAGameReadyPackage) };
            bIsNVIDIAGameReadyPackage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bIsNVIDIARTXProductionBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXProductionBranchPackage) };
            bIsNVIDIARTXProductionBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bIsNVIDIARTXNewFeatureBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXNewFeatureBranchPackage) };
            bIsNVIDIARTXNewFeatureBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_DISPLAY_DRIVER_INFO_V1 = _NV_DISPLAY_DRIVER_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_DISPLAY_DRIVER_INFO_V2 {
    pub version: NvU32,
    pub driverVersion: NvU32,
    pub szBuildBranch: NvAPI_ShortString,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub szBuildBaseBranch: NvAPI_ShortString,
    pub reservedEx: NvU32,
}
impl _NV_DISPLAY_DRIVER_INFO_V2 {
    #[inline]
    pub fn bIsDCHDriver(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsDCHDriver(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAStudioPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAStudioPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIAGameReadyPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIAGameReadyPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXProductionBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXProductionBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsNVIDIARTXNewFeatureBranchPackage(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bIsNVIDIARTXNewFeatureBranchPackage(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> NvU32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: NvU32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bIsDCHDriver: NvU32,
        bIsNVIDIAStudioPackage: NvU32,
        bIsNVIDIAGameReadyPackage: NvU32,
        bIsNVIDIARTXProductionBranchPackage: NvU32,
        bIsNVIDIARTXNewFeatureBranchPackage: NvU32,
        reserved: NvU32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bIsDCHDriver: u32 = unsafe { ::std::mem::transmute(bIsDCHDriver) };
            bIsDCHDriver as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bIsNVIDIAStudioPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAStudioPackage) };
            bIsNVIDIAStudioPackage as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bIsNVIDIAGameReadyPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIAGameReadyPackage) };
            bIsNVIDIAGameReadyPackage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bIsNVIDIARTXProductionBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXProductionBranchPackage) };
            bIsNVIDIARTXProductionBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bIsNVIDIARTXNewFeatureBranchPackage: u32 =
                unsafe { ::std::mem::transmute(bIsNVIDIARTXNewFeatureBranchPackage) };
            bIsNVIDIARTXNewFeatureBranchPackage as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_DISPLAY_DRIVER_INFO_V2 = _NV_DISPLAY_DRIVER_INFO_V2;
pub type NV_DISPLAY_DRIVER_INFO = NV_DISPLAY_DRIVER_INFO_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 {
    pub pCallbackParam: *mut ::std::os::raw::c_void,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 = _NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1;
pub type NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 = NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 {
    pub super_: NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1,
    pub callbackPeriodms: NvU32,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 =
    _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 {
    pub pCallbackParam: *mut ::std::os::raw::c_void,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 = _NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1;
impl _NV_GPU_CLIENT_UTIL_DOMAIN_ID {
    pub const NV_GPU_CLIENT_UTIL_DOMAIN_GRAPHICS: _NV_GPU_CLIENT_UTIL_DOMAIN_ID =
        _NV_GPU_CLIENT_UTIL_DOMAIN_ID(0);
}
impl _NV_GPU_CLIENT_UTIL_DOMAIN_ID {
    pub const NV_GPU_CLIENT_UTIL_DOMAIN_FRAME_BUFFER: _NV_GPU_CLIENT_UTIL_DOMAIN_ID =
        _NV_GPU_CLIENT_UTIL_DOMAIN_ID(1);
}
impl _NV_GPU_CLIENT_UTIL_DOMAIN_ID {
    pub const NV_GPU_CLIENT_UTIL_DOMAIN_VIDEO: _NV_GPU_CLIENT_UTIL_DOMAIN_ID =
        _NV_GPU_CLIENT_UTIL_DOMAIN_ID(2);
}
impl _NV_GPU_CLIENT_UTIL_DOMAIN_ID {
    pub const NV_GPU_CLIENT_UTIL_DOMAIN_RSVD: _NV_GPU_CLIENT_UTIL_DOMAIN_ID =
        _NV_GPU_CLIENT_UTIL_DOMAIN_ID(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_GPU_CLIENT_UTIL_DOMAIN_ID(pub ::std::os::raw::c_int);
pub use self::_NV_GPU_CLIENT_UTIL_DOMAIN_ID as NV_GPU_CLIENT_UTIL_DOMAIN_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_UTILIZATION_DATA_V1 {
    pub utilId: NV_GPU_CLIENT_UTIL_DOMAIN_ID,
    pub utilizationPercent: NvU32,
    pub rsvd: [NvU8; 61usize],
}
pub type NV_GPU_CLIENT_UTILIZATION_DATA_V1 = _NV_GPU_CLIENT_UTILIZATION_DATA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1 {
    pub super_: NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1,
    pub numUtils: NvU32,
    pub timestamp: NvU64,
    pub rsvd: [NvU8; 64usize],
    pub utils: [NV_GPU_CLIENT_UTILIZATION_DATA_V1; 4usize],
}
pub type NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1 = _NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1;
pub type NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_V1 = ::std::option::Option<
    unsafe extern "C" fn(
        hPhysicalGpu: NvPhysicalGpuHandle,
        pData: *mut NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1 {
    pub version: NvU32,
    pub super_: NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1,
    pub callback: NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_V1,
    pub rsvd: [NvU8; 64usize],
}
pub type NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1 =
    _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1;
pub type NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS =
    NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1;
