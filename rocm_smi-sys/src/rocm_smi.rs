/* automatically generated by rust-bindgen 0.63.0 */

pub const RSMI_MAX_NUM_FREQUENCIES: u32 = 32;
pub const RSMI_MAX_FAN_SPEED: u32 = 255;
pub const RSMI_NUM_VOLTAGE_CURVE_POINTS: u32 = 3;
pub const RSMI_GPU_METRICS_API_FORMAT_VER: u32 = 1;
pub const RSMI_GPU_METRICS_API_CONTENT_VER_1: u32 = 1;
pub const RSMI_GPU_METRICS_API_CONTENT_VER_2: u32 = 2;
pub const RSMI_GPU_METRICS_API_CONTENT_VER_3: u32 = 3;
pub const RSMI_NUM_HBM_INSTANCES: u32 = 4;
pub const RSMI_DEFAULT_VARIANT: i32 = -1;
impl rsmi_status_t {
    #[doc = "!< Operation was successful"]
    pub const RSMI_STATUS_SUCCESS: rsmi_status_t = rsmi_status_t(0);
}
impl rsmi_status_t {
    #[doc = "!< Passed in arguments are not valid"]
    pub const RSMI_STATUS_INVALID_ARGS: rsmi_status_t = rsmi_status_t(1);
}
impl rsmi_status_t {
    #[doc = "!< The requested information or\n!< action is not available for the\n!< given input, on the given system"]
    pub const RSMI_STATUS_NOT_SUPPORTED: rsmi_status_t = rsmi_status_t(2);
}
impl rsmi_status_t {
    #[doc = "!< Problem accessing a file. This\n!< may because the operation is not\n!< supported by the Linux kernel\n!< version running on the executing\n!< machine"]
    pub const RSMI_STATUS_FILE_ERROR: rsmi_status_t = rsmi_status_t(3);
}
impl rsmi_status_t {
    #[doc = "!< Permission denied/EACCESS file\n!< error. Many functions require\n!< root access to run."]
    pub const RSMI_STATUS_PERMISSION: rsmi_status_t = rsmi_status_t(4);
}
impl rsmi_status_t {
    #[doc = "!< Unable to acquire memory or other\n!< resource"]
    pub const RSMI_STATUS_OUT_OF_RESOURCES: rsmi_status_t = rsmi_status_t(5);
}
impl rsmi_status_t {
    #[doc = "!< An internal exception was caught"]
    pub const RSMI_STATUS_INTERNAL_EXCEPTION: rsmi_status_t = rsmi_status_t(6);
}
impl rsmi_status_t {
    #[doc = "!< The provided input is out of\n!< allowable or safe range"]
    pub const RSMI_STATUS_INPUT_OUT_OF_BOUNDS: rsmi_status_t = rsmi_status_t(7);
}
impl rsmi_status_t {
    #[doc = "!< An error occurred when rsmi\n!< initializing internal data\n!< structures"]
    pub const RSMI_STATUS_INIT_ERROR: rsmi_status_t = rsmi_status_t(8);
}
impl rsmi_status_t {
    pub const RSMI_INITIALIZATION_ERROR: rsmi_status_t = rsmi_status_t(8);
}
impl rsmi_status_t {
    #[doc = "!< The requested function has not\n!< yet been implemented in the\n!< current system for the current\n!< devices"]
    pub const RSMI_STATUS_NOT_YET_IMPLEMENTED: rsmi_status_t = rsmi_status_t(9);
}
impl rsmi_status_t {
    #[doc = "!< An item was searched for but not\n!< found"]
    pub const RSMI_STATUS_NOT_FOUND: rsmi_status_t = rsmi_status_t(10);
}
impl rsmi_status_t {
    #[doc = "!< Not enough resources were\n!< available for the operation"]
    pub const RSMI_STATUS_INSUFFICIENT_SIZE: rsmi_status_t = rsmi_status_t(11);
}
impl rsmi_status_t {
    #[doc = "!< An interrupt occurred during\n!< execution of function"]
    pub const RSMI_STATUS_INTERRUPT: rsmi_status_t = rsmi_status_t(12);
}
impl rsmi_status_t {
    #[doc = "!< An unexpected amount of data\n!< was read"]
    pub const RSMI_STATUS_UNEXPECTED_SIZE: rsmi_status_t = rsmi_status_t(13);
}
impl rsmi_status_t {
    #[doc = "!< No data was found for a given\n!< input"]
    pub const RSMI_STATUS_NO_DATA: rsmi_status_t = rsmi_status_t(14);
}
impl rsmi_status_t {
    #[doc = "!< The data read or provided to\n!< function is not what was expected"]
    pub const RSMI_STATUS_UNEXPECTED_DATA: rsmi_status_t = rsmi_status_t(15);
}
impl rsmi_status_t {
    #[doc = "!< A resource or mutex could not be\n!< acquired because it is already\n!< being used"]
    pub const RSMI_STATUS_BUSY: rsmi_status_t = rsmi_status_t(16);
}
impl rsmi_status_t {
    #[doc = "!< An internal reference counter\n!< exceeded INT32_MAX"]
    pub const RSMI_STATUS_REFCOUNT_OVERFLOW: rsmi_status_t = rsmi_status_t(17);
}
impl rsmi_status_t {
    #[doc = "!< An unknown error occurred"]
    pub const RSMI_STATUS_UNKNOWN_ERROR: rsmi_status_t = rsmi_status_t(4294967295);
}
#[repr(transparent)]
#[doc = " @brief Error codes retured by rocm_smi_lib functions"]
#[must_use]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_status_t(pub ::std::os::raw::c_uint);
impl rsmi_dev_perf_level_t {
    #[doc = "!< Performance level is \"auto\""]
    pub const RSMI_DEV_PERF_LEVEL_AUTO: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(0);
}
impl rsmi_dev_perf_level_t {
    pub const RSMI_DEV_PERF_LEVEL_FIRST: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(0);
}
impl rsmi_dev_perf_level_t {
    #[doc = "!< Keep PowerPlay levels \"low\",\n!< regardless of workload"]
    pub const RSMI_DEV_PERF_LEVEL_LOW: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(1);
}
impl rsmi_dev_perf_level_t {
    #[doc = "!< Keep PowerPlay levels \"high\",\n!< regardless of workload"]
    pub const RSMI_DEV_PERF_LEVEL_HIGH: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(2);
}
impl rsmi_dev_perf_level_t {
    #[doc = "!< Only use values defined by manually\n!< setting the RSMI_CLK_TYPE_SYS speed"]
    pub const RSMI_DEV_PERF_LEVEL_MANUAL: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(3);
}
impl rsmi_dev_perf_level_t {
    #[doc = "!< Stable power state with profiling\n!< clocks"]
    pub const RSMI_DEV_PERF_LEVEL_STABLE_STD: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(4);
}
impl rsmi_dev_perf_level_t {
    #[doc = "!< Stable power state with peak clocks"]
    pub const RSMI_DEV_PERF_LEVEL_STABLE_PEAK: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(5);
}
impl rsmi_dev_perf_level_t {
    #[doc = "!< Stable power state with minimum\n!< memory clock"]
    pub const RSMI_DEV_PERF_LEVEL_STABLE_MIN_MCLK: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(6);
}
impl rsmi_dev_perf_level_t {
    #[doc = "!< Stable power state with minimum\n!< system clock"]
    pub const RSMI_DEV_PERF_LEVEL_STABLE_MIN_SCLK: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(7);
}
impl rsmi_dev_perf_level_t {
    #[doc = "!< Performance determinism state"]
    pub const RSMI_DEV_PERF_LEVEL_DETERMINISM: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(8);
}
impl rsmi_dev_perf_level_t {
    pub const RSMI_DEV_PERF_LEVEL_LAST: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(8);
}
impl rsmi_dev_perf_level_t {
    #[doc = "!< Unknown performance level"]
    pub const RSMI_DEV_PERF_LEVEL_UNKNOWN: rsmi_dev_perf_level_t = rsmi_dev_perf_level_t(256);
}
#[repr(transparent)]
#[doc = " @brief PowerPlay performance levels"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_dev_perf_level_t(pub ::std::os::raw::c_uint);
impl rsmi_sw_component_t {
    pub const RSMI_SW_COMP_FIRST: rsmi_sw_component_t = rsmi_sw_component_t(0);
}
impl rsmi_sw_component_t {
    #[doc = "!< Driver"]
    pub const RSMI_SW_COMP_DRIVER: rsmi_sw_component_t = rsmi_sw_component_t(0);
}
impl rsmi_sw_component_t {
    pub const RSMI_SW_COMP_LAST: rsmi_sw_component_t = rsmi_sw_component_t(0);
}
#[repr(transparent)]
#[doc = " @brief Software components"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_sw_component_t(pub ::std::os::raw::c_uint);
#[doc = " @brief Handle to performance event counter"]
pub type rsmi_event_handle_t = usize;
impl rsmi_event_group_t {
    #[doc = "!< Data Fabric (XGMI) related events"]
    pub const RSMI_EVNT_GRP_XGMI: rsmi_event_group_t = rsmi_event_group_t(0);
}
impl rsmi_event_group_t {
    #[doc = "!< XGMI Outbound data"]
    pub const RSMI_EVNT_GRP_XGMI_DATA_OUT: rsmi_event_group_t = rsmi_event_group_t(10);
}
impl rsmi_event_group_t {
    pub const RSMI_EVNT_GRP_INVALID: rsmi_event_group_t = rsmi_event_group_t(4294967295);
}
#[repr(transparent)]
#[doc = " Event Groups\n\n @brief Enum denoting an event group. The value of the enum is the\n base value for all the event enums in the group."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_event_group_t(pub ::std::os::raw::c_uint);
impl rsmi_event_type_t {
    pub const RSMI_EVNT_FIRST: rsmi_event_type_t = rsmi_event_type_t(0);
}
impl rsmi_event_type_t {
    pub const RSMI_EVNT_XGMI_FIRST: rsmi_event_type_t = rsmi_event_type_t(0);
}
impl rsmi_event_type_t {
    #[doc = "!< NOPs sent to neighbor 0"]
    pub const RSMI_EVNT_XGMI_0_NOP_TX: rsmi_event_type_t = rsmi_event_type_t(0);
}
impl rsmi_event_type_t {
    #[doc = "!< Outgoing requests to\n!< neighbor 0"]
    pub const RSMI_EVNT_XGMI_0_REQUEST_TX: rsmi_event_type_t = rsmi_event_type_t(1);
}
impl rsmi_event_type_t {
    #[doc = "!< Outgoing responses to\n!< neighbor 0"]
    pub const RSMI_EVNT_XGMI_0_RESPONSE_TX: rsmi_event_type_t = rsmi_event_type_t(2);
}
impl rsmi_event_type_t {
    #[doc = " @brief\n\n Data beats sent to neighbor 0; Each beat represents 32 bytes.<br><br>\n\n XGMI throughput can be calculated by multiplying a BEATs event\n such as ::RSMI_EVNT_XGMI_0_BEATS_TX by 32 and dividing by\n the time for which event collection occurred,\n ::rsmi_counter_value_t.time_running (which is in nanoseconds). To get\n bytes per second, multiply this value by 10<sup>9</sup>.<br>\n <br>\n Throughput = BEATS/time_running * 10<sup>9</sup>  (bytes/second)<br>"]
    pub const RSMI_EVNT_XGMI_0_BEATS_TX: rsmi_event_type_t = rsmi_event_type_t(3);
}
impl rsmi_event_type_t {
    #[doc = "!< NOPs sent to neighbor 1"]
    pub const RSMI_EVNT_XGMI_1_NOP_TX: rsmi_event_type_t = rsmi_event_type_t(4);
}
impl rsmi_event_type_t {
    #[doc = "!< Outgoing requests to\n!< neighbor 1"]
    pub const RSMI_EVNT_XGMI_1_REQUEST_TX: rsmi_event_type_t = rsmi_event_type_t(5);
}
impl rsmi_event_type_t {
    #[doc = "!< Outgoing responses to\n!< neighbor 1"]
    pub const RSMI_EVNT_XGMI_1_RESPONSE_TX: rsmi_event_type_t = rsmi_event_type_t(6);
}
impl rsmi_event_type_t {
    #[doc = "!< Data beats sent to\n!< neighbor 1; Each beat\n!< represents 32 bytes"]
    pub const RSMI_EVNT_XGMI_1_BEATS_TX: rsmi_event_type_t = rsmi_event_type_t(7);
}
impl rsmi_event_type_t {
    pub const RSMI_EVNT_XGMI_LAST: rsmi_event_type_t = rsmi_event_type_t(7);
}
impl rsmi_event_type_t {
    pub const RSMI_EVNT_XGMI_DATA_OUT_FIRST: rsmi_event_type_t = rsmi_event_type_t(10);
}
impl rsmi_event_type_t {
    pub const RSMI_EVNT_XGMI_DATA_OUT_0: rsmi_event_type_t = rsmi_event_type_t(10);
}
impl rsmi_event_type_t {
    #[doc = "!< Outbound beats to neighbor 1"]
    pub const RSMI_EVNT_XGMI_DATA_OUT_1: rsmi_event_type_t = rsmi_event_type_t(11);
}
impl rsmi_event_type_t {
    #[doc = "!< Outbound beats to neighbor 2"]
    pub const RSMI_EVNT_XGMI_DATA_OUT_2: rsmi_event_type_t = rsmi_event_type_t(12);
}
impl rsmi_event_type_t {
    #[doc = "!< Outbound beats to neighbor 3"]
    pub const RSMI_EVNT_XGMI_DATA_OUT_3: rsmi_event_type_t = rsmi_event_type_t(13);
}
impl rsmi_event_type_t {
    #[doc = "!< Outbound beats to neighbor 4"]
    pub const RSMI_EVNT_XGMI_DATA_OUT_4: rsmi_event_type_t = rsmi_event_type_t(14);
}
impl rsmi_event_type_t {
    #[doc = "!< Outbound beats to neighbor 5"]
    pub const RSMI_EVNT_XGMI_DATA_OUT_5: rsmi_event_type_t = rsmi_event_type_t(15);
}
impl rsmi_event_type_t {
    pub const RSMI_EVNT_XGMI_DATA_OUT_LAST: rsmi_event_type_t = rsmi_event_type_t(15);
}
impl rsmi_event_type_t {
    pub const RSMI_EVNT_LAST: rsmi_event_type_t = rsmi_event_type_t(15);
}
#[repr(transparent)]
#[doc = " Event types\n @brief Event type enum. Events belonging to a particular event group\n ::rsmi_event_group_t should begin enumerating at the ::rsmi_event_group_t\n value for that group."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_event_type_t(pub ::std::os::raw::c_uint);
impl rsmi_counter_command_t {
    #[doc = "!< Start the counter"]
    pub const RSMI_CNTR_CMD_START: rsmi_counter_command_t = rsmi_counter_command_t(0);
}
impl rsmi_counter_command_t {
    #[doc = "!< Stop the counter; note that this should not\n!< be used before reading."]
    pub const RSMI_CNTR_CMD_STOP: rsmi_counter_command_t = rsmi_counter_command_t(1);
}
#[repr(transparent)]
#[doc = " Event counter commands"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_counter_command_t(pub ::std::os::raw::c_uint);
#[doc = " Counter value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_counter_value_t {
    #[doc = "!< Counter value"]
    pub value: u64,
    #[doc = "!< Time that the counter was enabled\n!< (in nanoseconds)"]
    pub time_enabled: u64,
    #[doc = "!< Time that the counter was running\n!< (in nanoseconds)"]
    pub time_running: u64,
}
impl rsmi_evt_notification_type_t {
    #[doc = "!< VM page fault"]
    pub const RSMI_EVT_NOTIF_VMFAULT: rsmi_evt_notification_type_t =
        rsmi_evt_notification_type_t(1);
}
impl rsmi_evt_notification_type_t {
    pub const RSMI_EVT_NOTIF_FIRST: rsmi_evt_notification_type_t = rsmi_evt_notification_type_t(1);
}
impl rsmi_evt_notification_type_t {
    pub const RSMI_EVT_NOTIF_THERMAL_THROTTLE: rsmi_evt_notification_type_t =
        rsmi_evt_notification_type_t(2);
}
impl rsmi_evt_notification_type_t {
    pub const RSMI_EVT_NOTIF_GPU_PRE_RESET: rsmi_evt_notification_type_t =
        rsmi_evt_notification_type_t(3);
}
impl rsmi_evt_notification_type_t {
    pub const RSMI_EVT_NOTIF_GPU_POST_RESET: rsmi_evt_notification_type_t =
        rsmi_evt_notification_type_t(4);
}
impl rsmi_evt_notification_type_t {
    pub const RSMI_EVT_NOTIF_LAST: rsmi_evt_notification_type_t = rsmi_evt_notification_type_t(4);
}
#[repr(transparent)]
#[doc = " Event notification event types"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_evt_notification_type_t(pub ::std::os::raw::c_uint);
#[doc = " Event notification data returned from event notification API"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_evt_notification_data_t {
    #[doc = "!< Index of device that corresponds to the event"]
    pub dv_ind: u32,
    #[doc = "!< Event type"]
    pub event: rsmi_evt_notification_type_t,
    #[doc = "!< Event message"]
    pub message: [::std::os::raw::c_char; 64usize],
}
impl rsmi_clk_type_t {
    #[doc = "!< System clock"]
    pub const RSMI_CLK_TYPE_SYS: rsmi_clk_type_t = rsmi_clk_type_t(0);
}
impl rsmi_clk_type_t {
    pub const RSMI_CLK_TYPE_FIRST: rsmi_clk_type_t = rsmi_clk_type_t(0);
}
impl rsmi_clk_type_t {
    #[doc = "!< Data Fabric clock (for ASICs\n!< running on a separate clock)"]
    pub const RSMI_CLK_TYPE_DF: rsmi_clk_type_t = rsmi_clk_type_t(1);
}
impl rsmi_clk_type_t {
    #[doc = "!< Display Controller Engine clock"]
    pub const RSMI_CLK_TYPE_DCEF: rsmi_clk_type_t = rsmi_clk_type_t(2);
}
impl rsmi_clk_type_t {
    #[doc = "!< SOC clock"]
    pub const RSMI_CLK_TYPE_SOC: rsmi_clk_type_t = rsmi_clk_type_t(3);
}
impl rsmi_clk_type_t {
    #[doc = "!< Memory clock"]
    pub const RSMI_CLK_TYPE_MEM: rsmi_clk_type_t = rsmi_clk_type_t(4);
}
impl rsmi_clk_type_t {
    #[doc = "!< PCIE clock"]
    pub const RSMI_CLK_TYPE_PCIE: rsmi_clk_type_t = rsmi_clk_type_t(5);
}
impl rsmi_clk_type_t {
    pub const RSMI_CLK_TYPE_LAST: rsmi_clk_type_t = rsmi_clk_type_t(4);
}
impl rsmi_clk_type_t {
    pub const RSMI_CLK_INVALID: rsmi_clk_type_t = rsmi_clk_type_t(4294967295);
}
#[repr(transparent)]
#[doc = " Clock types"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_clk_type_t(pub ::std::os::raw::c_uint);
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature current value."]
    pub const RSMI_TEMP_CURRENT: rsmi_temperature_metric_t = rsmi_temperature_metric_t(0);
}
impl rsmi_temperature_metric_t {
    pub const RSMI_TEMP_FIRST: rsmi_temperature_metric_t = rsmi_temperature_metric_t(0);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature max value."]
    pub const RSMI_TEMP_MAX: rsmi_temperature_metric_t = rsmi_temperature_metric_t(1);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature min value."]
    pub const RSMI_TEMP_MIN: rsmi_temperature_metric_t = rsmi_temperature_metric_t(2);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature hysteresis value for max limit.\n!< (This is an absolute temperature, not a\n!< delta)."]
    pub const RSMI_TEMP_MAX_HYST: rsmi_temperature_metric_t = rsmi_temperature_metric_t(3);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature hysteresis value for min limit.\n!< (This is an absolute temperature,\n!<  not a delta)."]
    pub const RSMI_TEMP_MIN_HYST: rsmi_temperature_metric_t = rsmi_temperature_metric_t(4);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature critical max value, typically\n!<  greater than corresponding temp_max values."]
    pub const RSMI_TEMP_CRITICAL: rsmi_temperature_metric_t = rsmi_temperature_metric_t(5);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature hysteresis value for critical\n!<  limit. (This is an absolute temperature,\n!<  not a delta)."]
    pub const RSMI_TEMP_CRITICAL_HYST: rsmi_temperature_metric_t = rsmi_temperature_metric_t(6);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature emergency max value, for chips\n!<  supporting more than two upper temperature\n!<  limits. Must be equal or greater than\n!<  corresponding temp_crit values."]
    pub const RSMI_TEMP_EMERGENCY: rsmi_temperature_metric_t = rsmi_temperature_metric_t(7);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature hysteresis value for emergency\n!<  limit. (This is an absolute temperature,\n!<  not a delta)."]
    pub const RSMI_TEMP_EMERGENCY_HYST: rsmi_temperature_metric_t = rsmi_temperature_metric_t(8);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature critical min value, typically\n!<  lower than corresponding temperature\n!<  minimum values."]
    pub const RSMI_TEMP_CRIT_MIN: rsmi_temperature_metric_t = rsmi_temperature_metric_t(9);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature hysteresis value for critical\n!< minimum limit. (This is an absolute\n!< temperature, not a delta)."]
    pub const RSMI_TEMP_CRIT_MIN_HYST: rsmi_temperature_metric_t = rsmi_temperature_metric_t(10);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Temperature offset which is added to the"]
    pub const RSMI_TEMP_OFFSET: rsmi_temperature_metric_t = rsmi_temperature_metric_t(11);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Historical minimum temperature."]
    pub const RSMI_TEMP_LOWEST: rsmi_temperature_metric_t = rsmi_temperature_metric_t(12);
}
impl rsmi_temperature_metric_t {
    #[doc = "!< Historical maximum temperature."]
    pub const RSMI_TEMP_HIGHEST: rsmi_temperature_metric_t = rsmi_temperature_metric_t(13);
}
impl rsmi_temperature_metric_t {
    pub const RSMI_TEMP_LAST: rsmi_temperature_metric_t = rsmi_temperature_metric_t(13);
}
#[repr(transparent)]
#[doc = " @brief Temperature Metrics.  This enum is used to identify various\n temperature metrics. Corresponding values will be in millidegress\n Celsius."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_temperature_metric_t(pub ::std::os::raw::c_uint);
impl rsmi_voltage_metric_t {
    #[doc = "!< Voltage current value."]
    pub const RSMI_VOLT_CURRENT: rsmi_voltage_metric_t = rsmi_voltage_metric_t(0);
}
impl rsmi_voltage_metric_t {
    pub const RSMI_VOLT_FIRST: rsmi_voltage_metric_t = rsmi_voltage_metric_t(0);
}
impl rsmi_voltage_metric_t {
    #[doc = "!< Voltage max value."]
    pub const RSMI_VOLT_MAX: rsmi_voltage_metric_t = rsmi_voltage_metric_t(1);
}
impl rsmi_voltage_metric_t {
    #[doc = "!< Voltage critical min value."]
    pub const RSMI_VOLT_MIN_CRIT: rsmi_voltage_metric_t = rsmi_voltage_metric_t(2);
}
impl rsmi_voltage_metric_t {
    #[doc = "!< Voltage min value."]
    pub const RSMI_VOLT_MIN: rsmi_voltage_metric_t = rsmi_voltage_metric_t(3);
}
impl rsmi_voltage_metric_t {
    #[doc = "!< Voltage critical max value."]
    pub const RSMI_VOLT_MAX_CRIT: rsmi_voltage_metric_t = rsmi_voltage_metric_t(4);
}
impl rsmi_voltage_metric_t {
    #[doc = "!< Average voltage."]
    pub const RSMI_VOLT_AVERAGE: rsmi_voltage_metric_t = rsmi_voltage_metric_t(5);
}
impl rsmi_voltage_metric_t {
    #[doc = "!< Historical minimum voltage."]
    pub const RSMI_VOLT_LOWEST: rsmi_voltage_metric_t = rsmi_voltage_metric_t(6);
}
impl rsmi_voltage_metric_t {
    #[doc = "!< Historical maximum voltage."]
    pub const RSMI_VOLT_HIGHEST: rsmi_voltage_metric_t = rsmi_voltage_metric_t(7);
}
impl rsmi_voltage_metric_t {
    pub const RSMI_VOLT_LAST: rsmi_voltage_metric_t = rsmi_voltage_metric_t(7);
}
#[repr(transparent)]
#[doc = " @brief Voltage Metrics.  This enum is used to identify various\n Volatge metrics. Corresponding values will be in millivolt.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_voltage_metric_t(pub ::std::os::raw::c_uint);
impl rsmi_voltage_type_t {
    pub const RSMI_VOLT_TYPE_FIRST: rsmi_voltage_type_t = rsmi_voltage_type_t(0);
}
impl rsmi_voltage_type_t {
    #[doc = "!< Vddgfx GPU\n!< voltage"]
    pub const RSMI_VOLT_TYPE_VDDGFX: rsmi_voltage_type_t = rsmi_voltage_type_t(0);
}
impl rsmi_voltage_type_t {
    pub const RSMI_VOLT_TYPE_LAST: rsmi_voltage_type_t = rsmi_voltage_type_t(0);
}
impl rsmi_voltage_type_t {
    #[doc = "!< Invalid type"]
    pub const RSMI_VOLT_TYPE_INVALID: rsmi_voltage_type_t = rsmi_voltage_type_t(4294967295);
}
#[repr(transparent)]
#[doc = " @brief This ennumeration is used to indicate which type of\n voltage reading should be obtained."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_voltage_type_t(pub ::std::os::raw::c_uint);
impl rsmi_power_profile_preset_masks_t {
    #[doc = "!< Custom Power Profile"]
    pub const RSMI_PWR_PROF_PRST_CUSTOM_MASK: rsmi_power_profile_preset_masks_t =
        rsmi_power_profile_preset_masks_t(1);
}
impl rsmi_power_profile_preset_masks_t {
    #[doc = "!< Video Power Profile"]
    pub const RSMI_PWR_PROF_PRST_VIDEO_MASK: rsmi_power_profile_preset_masks_t =
        rsmi_power_profile_preset_masks_t(2);
}
impl rsmi_power_profile_preset_masks_t {
    #[doc = "!< Power Saving Profile"]
    pub const RSMI_PWR_PROF_PRST_POWER_SAVING_MASK: rsmi_power_profile_preset_masks_t =
        rsmi_power_profile_preset_masks_t(4);
}
impl rsmi_power_profile_preset_masks_t {
    #[doc = "!< Compute Saving Profile"]
    pub const RSMI_PWR_PROF_PRST_COMPUTE_MASK: rsmi_power_profile_preset_masks_t =
        rsmi_power_profile_preset_masks_t(8);
}
impl rsmi_power_profile_preset_masks_t {
    #[doc = "!< VR Power Profile"]
    pub const RSMI_PWR_PROF_PRST_VR_MASK: rsmi_power_profile_preset_masks_t =
        rsmi_power_profile_preset_masks_t(16);
}
impl rsmi_power_profile_preset_masks_t {
    pub const RSMI_PWR_PROF_PRST_3D_FULL_SCR_MASK: rsmi_power_profile_preset_masks_t =
        rsmi_power_profile_preset_masks_t(32);
}
impl rsmi_power_profile_preset_masks_t {
    #[doc = "!< Default Boot Up Profile"]
    pub const RSMI_PWR_PROF_PRST_BOOTUP_DEFAULT: rsmi_power_profile_preset_masks_t =
        rsmi_power_profile_preset_masks_t(64);
}
impl rsmi_power_profile_preset_masks_t {
    pub const RSMI_PWR_PROF_PRST_LAST: rsmi_power_profile_preset_masks_t =
        rsmi_power_profile_preset_masks_t(64);
}
impl rsmi_power_profile_preset_masks_t {
    pub const RSMI_PWR_PROF_PRST_INVALID: rsmi_power_profile_preset_masks_t =
        rsmi_power_profile_preset_masks_t(::std::os::raw::c_ulong::MAX);
}
#[repr(transparent)]
#[doc = " @brief Pre-set Profile Selections. These bitmasks can be AND'd with the\n ::rsmi_power_profile_status_t.available_profiles returned from\n ::rsmi_dev_power_profile_presets_get to determine which power profiles\n are supported by the system."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_power_profile_preset_masks_t(pub ::std::os::raw::c_ulong);
impl rsmi_gpu_block_t {
    #[doc = "!< Used to indicate an\n!< invalid block"]
    pub const RSMI_GPU_BLOCK_INVALID: rsmi_gpu_block_t = rsmi_gpu_block_t(0);
}
impl rsmi_gpu_block_t {
    pub const RSMI_GPU_BLOCK_FIRST: rsmi_gpu_block_t = rsmi_gpu_block_t(1);
}
impl rsmi_gpu_block_t {
    #[doc = "!< UMC block"]
    pub const RSMI_GPU_BLOCK_UMC: rsmi_gpu_block_t = rsmi_gpu_block_t(1);
}
impl rsmi_gpu_block_t {
    #[doc = "!< SDMA block"]
    pub const RSMI_GPU_BLOCK_SDMA: rsmi_gpu_block_t = rsmi_gpu_block_t(2);
}
impl rsmi_gpu_block_t {
    #[doc = "!< GFX block"]
    pub const RSMI_GPU_BLOCK_GFX: rsmi_gpu_block_t = rsmi_gpu_block_t(4);
}
impl rsmi_gpu_block_t {
    #[doc = "!< MMHUB block"]
    pub const RSMI_GPU_BLOCK_MMHUB: rsmi_gpu_block_t = rsmi_gpu_block_t(8);
}
impl rsmi_gpu_block_t {
    #[doc = "!< ATHUB block"]
    pub const RSMI_GPU_BLOCK_ATHUB: rsmi_gpu_block_t = rsmi_gpu_block_t(16);
}
impl rsmi_gpu_block_t {
    #[doc = "!< PCIE_BIF block"]
    pub const RSMI_GPU_BLOCK_PCIE_BIF: rsmi_gpu_block_t = rsmi_gpu_block_t(32);
}
impl rsmi_gpu_block_t {
    #[doc = "!< HDP block"]
    pub const RSMI_GPU_BLOCK_HDP: rsmi_gpu_block_t = rsmi_gpu_block_t(64);
}
impl rsmi_gpu_block_t {
    #[doc = "!< XGMI block"]
    pub const RSMI_GPU_BLOCK_XGMI_WAFL: rsmi_gpu_block_t = rsmi_gpu_block_t(128);
}
impl rsmi_gpu_block_t {
    #[doc = "!< DF block"]
    pub const RSMI_GPU_BLOCK_DF: rsmi_gpu_block_t = rsmi_gpu_block_t(256);
}
impl rsmi_gpu_block_t {
    #[doc = "!< SMN block"]
    pub const RSMI_GPU_BLOCK_SMN: rsmi_gpu_block_t = rsmi_gpu_block_t(512);
}
impl rsmi_gpu_block_t {
    #[doc = "!< SEM block"]
    pub const RSMI_GPU_BLOCK_SEM: rsmi_gpu_block_t = rsmi_gpu_block_t(1024);
}
impl rsmi_gpu_block_t {
    #[doc = "!< MP0 block"]
    pub const RSMI_GPU_BLOCK_MP0: rsmi_gpu_block_t = rsmi_gpu_block_t(2048);
}
impl rsmi_gpu_block_t {
    #[doc = "!< MP1 block"]
    pub const RSMI_GPU_BLOCK_MP1: rsmi_gpu_block_t = rsmi_gpu_block_t(4096);
}
impl rsmi_gpu_block_t {
    #[doc = "!< Fuse block"]
    pub const RSMI_GPU_BLOCK_FUSE: rsmi_gpu_block_t = rsmi_gpu_block_t(8192);
}
impl rsmi_gpu_block_t {
    #[doc = "!< The highest bit position\n!< for supported blocks"]
    pub const RSMI_GPU_BLOCK_LAST: rsmi_gpu_block_t = rsmi_gpu_block_t(8192);
}
impl rsmi_gpu_block_t {
    pub const RSMI_GPU_BLOCK_RESERVED: rsmi_gpu_block_t =
        rsmi_gpu_block_t(::std::os::raw::c_ulong::MAX);
}
#[repr(transparent)]
#[doc = " @brief This enum is used to identify different GPU blocks."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_gpu_block_t(pub ::std::os::raw::c_ulong);
impl rsmi_ras_err_state_t {
    #[doc = "!< No current errors"]
    pub const RSMI_RAS_ERR_STATE_NONE: rsmi_ras_err_state_t = rsmi_ras_err_state_t(0);
}
impl rsmi_ras_err_state_t {
    #[doc = "!< ECC is disabled"]
    pub const RSMI_RAS_ERR_STATE_DISABLED: rsmi_ras_err_state_t = rsmi_ras_err_state_t(1);
}
impl rsmi_ras_err_state_t {
    #[doc = "!< ECC errors present, but type unknown"]
    pub const RSMI_RAS_ERR_STATE_PARITY: rsmi_ras_err_state_t = rsmi_ras_err_state_t(2);
}
impl rsmi_ras_err_state_t {
    #[doc = "!< Single correctable error"]
    pub const RSMI_RAS_ERR_STATE_SING_C: rsmi_ras_err_state_t = rsmi_ras_err_state_t(3);
}
impl rsmi_ras_err_state_t {
    #[doc = "!< Multiple uncorrectable errors"]
    pub const RSMI_RAS_ERR_STATE_MULT_UC: rsmi_ras_err_state_t = rsmi_ras_err_state_t(4);
}
impl rsmi_ras_err_state_t {
    #[doc = "!< Firmware detected error and isolated\n!< page. Treat as uncorrectable."]
    pub const RSMI_RAS_ERR_STATE_POISON: rsmi_ras_err_state_t = rsmi_ras_err_state_t(5);
}
impl rsmi_ras_err_state_t {
    #[doc = "!< ECC is enabled"]
    pub const RSMI_RAS_ERR_STATE_ENABLED: rsmi_ras_err_state_t = rsmi_ras_err_state_t(6);
}
impl rsmi_ras_err_state_t {
    pub const RSMI_RAS_ERR_STATE_LAST: rsmi_ras_err_state_t = rsmi_ras_err_state_t(6);
}
impl rsmi_ras_err_state_t {
    pub const RSMI_RAS_ERR_STATE_INVALID: rsmi_ras_err_state_t = rsmi_ras_err_state_t(4294967295);
}
#[repr(transparent)]
#[doc = " @brief The current ECC state"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_ras_err_state_t(pub ::std::os::raw::c_uint);
impl rsmi_memory_type_t {
    pub const RSMI_MEM_TYPE_FIRST: rsmi_memory_type_t = rsmi_memory_type_t(0);
}
impl rsmi_memory_type_t {
    #[doc = "!< VRAM memory"]
    pub const RSMI_MEM_TYPE_VRAM: rsmi_memory_type_t = rsmi_memory_type_t(0);
}
impl rsmi_memory_type_t {
    #[doc = "!< VRAM memory that is visible"]
    pub const RSMI_MEM_TYPE_VIS_VRAM: rsmi_memory_type_t = rsmi_memory_type_t(1);
}
impl rsmi_memory_type_t {
    #[doc = "!< GTT memory"]
    pub const RSMI_MEM_TYPE_GTT: rsmi_memory_type_t = rsmi_memory_type_t(2);
}
impl rsmi_memory_type_t {
    pub const RSMI_MEM_TYPE_LAST: rsmi_memory_type_t = rsmi_memory_type_t(2);
}
#[repr(transparent)]
#[doc = " @brief Types of memory"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_memory_type_t(pub ::std::os::raw::c_uint);
impl rsmi_freq_ind_t {
    #[doc = "!< Index used for the minimum frequency value"]
    pub const RSMI_FREQ_IND_MIN: rsmi_freq_ind_t = rsmi_freq_ind_t(0);
}
impl rsmi_freq_ind_t {
    #[doc = "!< Index used for the maximum frequency value"]
    pub const RSMI_FREQ_IND_MAX: rsmi_freq_ind_t = rsmi_freq_ind_t(1);
}
impl rsmi_freq_ind_t {
    #[doc = "!< An invalid frequency index"]
    pub const RSMI_FREQ_IND_INVALID: rsmi_freq_ind_t = rsmi_freq_ind_t(4294967295);
}
#[repr(transparent)]
#[doc = " @brief The values of this enum are used as frequency identifiers."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_freq_ind_t(pub ::std::os::raw::c_uint);
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_FIRST: rsmi_fw_block_t = rsmi_fw_block_t(0);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_ASD: rsmi_fw_block_t = rsmi_fw_block_t(0);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_CE: rsmi_fw_block_t = rsmi_fw_block_t(1);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_DMCU: rsmi_fw_block_t = rsmi_fw_block_t(2);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_MC: rsmi_fw_block_t = rsmi_fw_block_t(3);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_ME: rsmi_fw_block_t = rsmi_fw_block_t(4);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_MEC: rsmi_fw_block_t = rsmi_fw_block_t(5);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_MEC2: rsmi_fw_block_t = rsmi_fw_block_t(6);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_PFP: rsmi_fw_block_t = rsmi_fw_block_t(7);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_RLC: rsmi_fw_block_t = rsmi_fw_block_t(8);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_RLC_SRLC: rsmi_fw_block_t = rsmi_fw_block_t(9);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_RLC_SRLG: rsmi_fw_block_t = rsmi_fw_block_t(10);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_RLC_SRLS: rsmi_fw_block_t = rsmi_fw_block_t(11);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_SDMA: rsmi_fw_block_t = rsmi_fw_block_t(12);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_SDMA2: rsmi_fw_block_t = rsmi_fw_block_t(13);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_SMC: rsmi_fw_block_t = rsmi_fw_block_t(14);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_SOS: rsmi_fw_block_t = rsmi_fw_block_t(15);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_TA_RAS: rsmi_fw_block_t = rsmi_fw_block_t(16);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_TA_XGMI: rsmi_fw_block_t = rsmi_fw_block_t(17);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_UVD: rsmi_fw_block_t = rsmi_fw_block_t(18);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_VCE: rsmi_fw_block_t = rsmi_fw_block_t(19);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_VCN: rsmi_fw_block_t = rsmi_fw_block_t(20);
}
impl rsmi_fw_block_t {
    pub const RSMI_FW_BLOCK_LAST: rsmi_fw_block_t = rsmi_fw_block_t(20);
}
#[repr(transparent)]
#[doc = " @brief The values of this enum are used to identify the various firmware\n blocks."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_fw_block_t(pub ::std::os::raw::c_uint);
impl rsmi_xgmi_status_t {
    pub const RSMI_XGMI_STATUS_NO_ERRORS: rsmi_xgmi_status_t = rsmi_xgmi_status_t(0);
}
impl rsmi_xgmi_status_t {
    pub const RSMI_XGMI_STATUS_ERROR: rsmi_xgmi_status_t = rsmi_xgmi_status_t(1);
}
impl rsmi_xgmi_status_t {
    pub const RSMI_XGMI_STATUS_MULTIPLE_ERRORS: rsmi_xgmi_status_t = rsmi_xgmi_status_t(2);
}
#[repr(transparent)]
#[doc = " @brief XGMI Status"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_xgmi_status_t(pub ::std::os::raw::c_uint);
#[doc = " @brief Bitfield used in various RSMI calls"]
pub type rsmi_bit_field_t = u64;
impl rsmi_memory_page_status_t {
    #[doc = "!< Reserved. This gpu page is reserved\n!<  and not available for use"]
    pub const RSMI_MEM_PAGE_STATUS_RESERVED: rsmi_memory_page_status_t =
        rsmi_memory_page_status_t(0);
}
impl rsmi_memory_page_status_t {
    #[doc = "!< Pending. This gpu page is marked\n!<  as bad and will be marked reserved\n!<  at the next window."]
    pub const RSMI_MEM_PAGE_STATUS_PENDING: rsmi_memory_page_status_t =
        rsmi_memory_page_status_t(1);
}
impl rsmi_memory_page_status_t {
    #[doc = "!< Unable to reserve this page"]
    pub const RSMI_MEM_PAGE_STATUS_UNRESERVABLE: rsmi_memory_page_status_t =
        rsmi_memory_page_status_t(2);
}
#[repr(transparent)]
#[doc = " @brief Reserved Memory Page States"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rsmi_memory_page_status_t(pub ::std::os::raw::c_uint);
impl _RSMI_IO_LINK_TYPE {
    #[doc = "!< unknown type."]
    pub const RSMI_IOLINK_TYPE_UNDEFINED: _RSMI_IO_LINK_TYPE = _RSMI_IO_LINK_TYPE(0);
}
impl _RSMI_IO_LINK_TYPE {
    #[doc = "!< PCI Express"]
    pub const RSMI_IOLINK_TYPE_PCIEXPRESS: _RSMI_IO_LINK_TYPE = _RSMI_IO_LINK_TYPE(1);
}
impl _RSMI_IO_LINK_TYPE {
    #[doc = "!< XGMI"]
    pub const RSMI_IOLINK_TYPE_XGMI: _RSMI_IO_LINK_TYPE = _RSMI_IO_LINK_TYPE(2);
}
impl _RSMI_IO_LINK_TYPE {
    #[doc = "!< Number of IO Link types"]
    pub const RSMI_IOLINK_TYPE_NUMIOLINKTYPES: _RSMI_IO_LINK_TYPE = _RSMI_IO_LINK_TYPE(3);
}
impl _RSMI_IO_LINK_TYPE {
    #[doc = "!< Max of IO Link types"]
    pub const RSMI_IOLINK_TYPE_SIZE: _RSMI_IO_LINK_TYPE = _RSMI_IO_LINK_TYPE(4294967295);
}
#[repr(transparent)]
#[doc = " @brief Types for IO Link"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _RSMI_IO_LINK_TYPE(pub ::std::os::raw::c_uint);
#[doc = " @brief Types for IO Link"]
pub use self::_RSMI_IO_LINK_TYPE as RSMI_IO_LINK_TYPE;
impl RSMI_UTILIZATION_COUNTER_TYPE {
    pub const RSMI_UTILIZATION_COUNTER_FIRST: RSMI_UTILIZATION_COUNTER_TYPE =
        RSMI_UTILIZATION_COUNTER_TYPE(0);
}
impl RSMI_UTILIZATION_COUNTER_TYPE {
    pub const RSMI_COARSE_GRAIN_GFX_ACTIVITY: RSMI_UTILIZATION_COUNTER_TYPE =
        RSMI_UTILIZATION_COUNTER_TYPE(0);
}
impl RSMI_UTILIZATION_COUNTER_TYPE {
    #[doc = "!< Memory Activity"]
    pub const RSMI_COARSE_GRAIN_MEM_ACTIVITY: RSMI_UTILIZATION_COUNTER_TYPE =
        RSMI_UTILIZATION_COUNTER_TYPE(1);
}
impl RSMI_UTILIZATION_COUNTER_TYPE {
    pub const RSMI_UTILIZATION_COUNTER_LAST: RSMI_UTILIZATION_COUNTER_TYPE =
        RSMI_UTILIZATION_COUNTER_TYPE(1);
}
#[repr(transparent)]
#[doc = " @brief The utilization counter type"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct RSMI_UTILIZATION_COUNTER_TYPE(pub ::std::os::raw::c_uint);
#[doc = " @brief The utilization counter data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_utilization_counter_t {
    #[doc = "!< Utilization counter type"]
    pub type_: RSMI_UTILIZATION_COUNTER_TYPE,
    #[doc = "!< Utilization counter value"]
    pub value: u64,
}
#[doc = " @brief Reserved Memory Page Record"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_retired_page_record_t {
    #[doc = "!< Start address of page"]
    pub page_address: u64,
    #[doc = "!< Page size"]
    pub page_size: u64,
    #[doc = "!< Page \"reserved\" status"]
    pub status: rsmi_memory_page_status_t,
}
#[doc = " @brief This structure contains information about which power profiles are\n supported by the system for a given device, and which power profile is\n currently active."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_power_profile_status_t {
    #[doc = " Which profiles are supported by this system"]
    pub available_profiles: rsmi_bit_field_t,
    #[doc = " Which power profile is currently active"]
    pub current: rsmi_power_profile_preset_masks_t,
    #[doc = " How many power profiles are available"]
    pub num_profiles: u32,
}
#[doc = " @brief This structure holds information about clock frequencies."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_frequencies_t {
    #[doc = " The number of supported frequencies"]
    pub num_supported: u32,
    #[doc = " The current frequency index"]
    pub current: u32,
    #[doc = " List of frequencies.\n Only the first num_supported frequencies are valid."]
    pub frequency: [u64; 32usize],
}
#[doc = " @brief This structure holds information about the possible PCIe\n bandwidths. Specifically, the possible transfer rates and their\n associated numbers of lanes are stored here."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_pcie_bandwidth_t {
    #[doc = " Transfer rates (T/s) that are possible"]
    pub transfer_rate: rsmi_frequencies_t,
    #[doc = " List of lanes for corresponding transfer rate.\n Only the first num_supported bandwidths are valid."]
    pub lanes: [u32; 32usize],
}
#[doc = " @brief This structure holds version information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_version_t {
    #[doc = "!< Major version"]
    pub major: u32,
    #[doc = "!< Minor version"]
    pub minor: u32,
    #[doc = "!< Patch, build  or stepping version"]
    pub patch: u32,
    #[doc = "!< Build string"]
    pub build: *const ::std::os::raw::c_char,
}
#[doc = " \\endcond\n**\n* @brief This structure represents a range (e.g., frequencies or voltages).\n*/"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_range_t {
    #[doc = "!< Lower bound of range"]
    pub lower_bound: u64,
    #[doc = "!< Upper bound of range"]
    pub upper_bound: u64,
}
#[doc = " @brief This structure represents a point on the frequency-voltage plane."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_od_vddc_point_t {
    #[doc = "!< Frequency coordinate (in Hz)"]
    pub frequency: u64,
    #[doc = "!< Voltage coordinate (in mV)"]
    pub voltage: u64,
}
#[doc = " @brief This structure holds 2 ::rsmi_range_t's, one for frequency and one for\n voltage. These 2 ranges indicate the range of possible values for the\n corresponding ::rsmi_od_vddc_point_t."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_freq_volt_region_t {
    #[doc = "!< The frequency range for this VDDC Curve point"]
    pub freq_range: rsmi_range_t,
    #[doc = "!< The voltage range for this VDDC Curve point"]
    pub volt_range: rsmi_range_t,
}
#[doc = " ::RSMI_NUM_VOLTAGE_CURVE_POINTS number of ::rsmi_od_vddc_point_t's"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_od_volt_curve_t {
    #[doc = " Array of ::RSMI_NUM_VOLTAGE_CURVE_POINTS ::rsmi_od_vddc_point_t's that\n make up the voltage frequency curve points."]
    pub vc_points: [rsmi_od_vddc_point_t; 3usize],
}
#[doc = " @brief This structure holds the frequency-voltage values for a device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_od_volt_freq_data_t {
    #[doc = "!< The current SCLK frequency range"]
    pub curr_sclk_range: rsmi_range_t,
    #[doc = "!< The current MCLK frequency range;\n!< (upper bound only)"]
    pub curr_mclk_range: rsmi_range_t,
    #[doc = "!< The range possible of SCLK values"]
    pub sclk_freq_limits: rsmi_range_t,
    #[doc = "!< The range possible of MCLK values"]
    pub mclk_freq_limits: rsmi_range_t,
    #[doc = " @brief The current voltage curve"]
    pub curve: rsmi_od_volt_curve_t,
    #[doc = "!< The number of voltage curve regions"]
    pub num_regions: u32,
}
#[doc = " @brief Size and version information of metrics data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct metrics_table_header_t {
    #[doc = " \\cond Ignore in docs."]
    pub structure_size: u16,
    pub format_revision: u8,
    pub content_revision: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_gpu_metrics_t {
    #[doc = " \\cond Ignore in docs."]
    pub common_header: metrics_table_header_t,
    pub temperature_edge: u16,
    pub temperature_hotspot: u16,
    pub temperature_mem: u16,
    pub temperature_vrgfx: u16,
    pub temperature_vrsoc: u16,
    pub temperature_vrmem: u16,
    pub average_gfx_activity: u16,
    pub average_umc_activity: u16,
    pub average_mm_activity: u16,
    pub average_socket_power: u16,
    pub energy_accumulator: u64,
    pub system_clock_counter: u64,
    pub average_gfxclk_frequency: u16,
    pub average_socclk_frequency: u16,
    pub average_uclk_frequency: u16,
    pub average_vclk0_frequency: u16,
    pub average_dclk0_frequency: u16,
    pub average_vclk1_frequency: u16,
    pub average_dclk1_frequency: u16,
    pub current_gfxclk: u16,
    pub current_socclk: u16,
    pub current_uclk: u16,
    pub current_vclk0: u16,
    pub current_dclk0: u16,
    pub current_vclk1: u16,
    pub current_dclk1: u16,
    pub throttle_status: u32,
    pub current_fan_speed: u16,
    pub pcie_link_width: u16,
    pub pcie_link_speed: u16,
    pub padding: u16,
    pub gfx_activity_acc: u32,
    pub mem_activity_acc: u32,
    pub temperature_hbm: [u16; 4usize],
}
#[doc = " @brief This structure holds error counts."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_error_count_t {
    #[doc = "!< Accumulated correctable errors"]
    pub correctable_err: u64,
    #[doc = "!< Accumulated uncorrectable errors"]
    pub uncorrectable_err: u64,
}
#[doc = " @brief This structure contains information specific to a process."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_process_info_t {
    #[doc = "!< Process ID"]
    pub process_id: u32,
    #[doc = "!< PASID"]
    pub pasid: u32,
    #[doc = "!< VRAM usage"]
    pub vram_usage: u64,
    #[doc = "!< SDMA usage in microseconds"]
    pub sdma_usage: u64,
    #[doc = "!< Compute Unit usage in percent"]
    pub cu_occupancy: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsmi_func_id_iter_handle {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque handle to function-support object"]
pub type rsmi_func_id_iter_handle_t = *mut rsmi_func_id_iter_handle;
#[doc = " @brief This union holds the value of an ::rsmi_func_id_iter_handle_t. The\n value may be a function name, or an enumerated variant value of types\n such as ::rsmi_memory_type_t, ::rsmi_temperature_metric_t, etc."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union id {
    #[doc = "!< uint64_t representation of value"]
    pub id: u64,
    #[doc = "!< name string (applicable to functions only)"]
    pub name: *const ::std::os::raw::c_char,
    pub __bindgen_anon_1: id__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union id__bindgen_ty_1 {
    pub memory_type: rsmi_memory_type_t,
    pub temp_metric: rsmi_temperature_metric_t,
    pub evnt_type: rsmi_event_type_t,
    pub evnt_group: rsmi_event_group_t,
    pub clk_type: rsmi_clk_type_t,
    pub fw_block: rsmi_fw_block_t,
    pub gpu_block_type: rsmi_gpu_block_t,
}
#[doc = " @brief This union holds the value of an ::rsmi_func_id_iter_handle_t. The\n value may be a function name, or an enumerated variant value of types\n such as ::rsmi_memory_type_t, ::rsmi_temperature_metric_t, etc."]
pub type rsmi_func_id_value_t = id;
extern "C" {
    #[must_use]
    #[doc = "/\n/** @defgroup InitShutAdmin Initialization and Shutdown\n  These functions are used for initialization of ROCm SMI and clean up when\n  done.\n  @{\n/\n/**\n  @brief Initialize ROCm SMI.\n\n  @details When called, this initializes internal data structures,\n  including those corresponding to sources of information that SMI provides.\n\n  @param[in] init_flags Bit flags that tell SMI how to initialze. Values of\n  ::rsmi_init_flags_t may be OR'd together and passed through @p init_flags\n  to modify how RSMI initializes.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call."]
    pub fn rsmi_init(init_flags: u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Shutdown ROCm SMI.\n\n  @details Do any necessary clean up."]
    pub fn rsmi_shut_down() -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "/\n/** @defgroup IDQuer Identifier Queries\n  These functions provide identification information.\n  @{\n/\n/**\n  @brief Get the number of devices that have monitor information.\n\n  @details The number of devices which have monitors is returned. Monitors\n  are referenced by the index which can be between 0 and @p num_devices - 1.\n\n  @param[inout] num_devices Caller provided pointer to uint32_t. Upon\n  successful call, the value num_devices will contain the number of monitor\n  devices.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call."]
    pub fn rsmi_num_monitor_devices(num_devices: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the device id associated with the device with provided device\n  index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p id,\n  this function will write the device id value to the uint64_t pointed to by\n  @p id. This ID is an identification of the type of device, so calling this\n  function for different devices will give the same value if they are kind\n  of device. Consequently, this function should not be used to distinguish\n  one device from another. rsmi_dev_pci_id_get() should be used to get a\n  unique identifier.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the device id will be\n  written\n If this parameter is nullptr, this function will return\n ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n provided arguments.\n\n @retval ::RSMI_STATUS_SUCCESS call was successful\n @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n support this function with the given arguments\n @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_id_get(dv_ind: u32, id: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the SKU for a desired device associated with the device with\n  provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a char @p sku,\n  this function will attempt to obtain the SKU from the Product Information\n  FRU chip, present on server ASICs. It will write the sku value to the\n  char array pointed to by @p sku.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] sku a pointer to char to which the sku will be written\n\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_sku_get(dv_ind: u32, sku: *mut ::std::os::raw::c_char) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the device vendor id associated with the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p id,\n  this function will write the device vendor id value to the uint64_t pointed\n  to by @p id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the device vendor id will\n  be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_vendor_id_get(dv_ind: u32, id: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the name string of a gpu device.\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p name, and a length of this buffer @p len, this function\n  will write the name of the device (up to @p len characters) to the buffer\n  @p name.\n\n  If the integer ID associated with the device is not found in one of the\n  system files containing device name information (e.g.\n  /usr/share/misc/pci.ids), then this function will return the hex device ID\n  as a string. Updating the system name files can be accomplished with\n  \"sudo update-pciids\".\n\n  @param[in] dv_ind a device index\n\n  @param[inout] name a pointer to a caller provided char buffer to which the\n  name will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_name_get(
        dv_ind: u32,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the brand string of a gpu device.\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p brand, and a length of this buffer @p len, this function\n  will write the brand of the device (up to @p len characters) to the buffer\n  @p brand.\n\n  If the sku associated with the device is not found as one of the values\n  contained within rsmi_dev_brand_get, then this function will return the\n  device marketing name as a string instead of the brand name.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] brand a pointer to a caller provided char buffer to which the\n  brand will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p brand.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_brand_get(
        dv_ind: u32,
        brand: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the name string for a give vendor ID\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p name, and a length of this buffer @p len, this function will\n  write the name of the vendor (up to @p len characters) buffer @p name. The\n  @p id may be a device vendor or subsystem vendor ID.\n\n  If the integer ID associated with the vendor is not found in one of the\n  system files containing device name information (e.g.\n  /usr/share/misc/pci.ids), then this function will return the hex vendor ID\n  as a string. Updating the system name files can be accomplished with\n  \"sudo update-pciids\".\n\n  @param[in] dv_ind a device index\n\n  @param[inout] name a pointer to a caller provided char buffer to which the\n  name will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_vendor_name_get(
        dv_ind: u32,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the vram vendor string of a gpu device.\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p brand, and a length of this buffer @p len, this function\n  will write the vram vendor of the device (up to @p len characters) to the\n  buffer @p brand.\n\n  If the vram vendor for the device is not found as one of the values\n  contained within rsmi_dev_vram_vendor_get, then this function will return\n  the string 'unknown' instead of the vram vendor.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] brand a pointer to a caller provided char buffer to which the\n  vram vendor will be written\n\n  @param[in] len the length of the caller provided buffer @p brand.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_vram_vendor_get(
        dv_ind: u32,
        brand: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Get the serial number string for a device\n\n @details Given a device index @p dv_ind, a pointer to a buffer of chars\n @p serial_num, and the length of the provided buffer @p len, this function\n will write the serial number string (up to @p len characters) to the buffer\n pointed to by @p serial_num.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] serial_num a pointer to caller-provided memory to which the\n  serial number will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p serial_num.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_serial_number_get(
        dv_ind: u32,
        serial_num: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the subsystem device id associated with the device with\n  provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p id,\n  this function will write the subsystem device id value to the uint64_t\n  pointed to by @p id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the subsystem device id\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_subsystem_id_get(dv_ind: u32, id: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the name string for the device subsytem\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p name, and a length of this buffer @p len, this function\n  will write the name of the device subsystem (up to @p len characters)\n  to the buffer @p name.\n\n  If the integer ID associated with the sub-system is not found in one of the\n  system files containing device name information (e.g.\n  /usr/share/misc/pci.ids), then this function will return the hex sub-system\n  ID as a string. Updating the system name files can be accomplished with\n  \"sudo update-pciids\".\n\n  @param[in] dv_ind a device index\n\n  @param[inout] name a pointer to a caller provided char buffer to which the\n  name will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_subsystem_name_get(
        dv_ind: u32,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the drm minor number associated with this device\n\n  @details Given a device index @p dv_ind, find its render device file\n  /dev/dri/renderDN where N corresponds to its minor number.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] minor a pointer to a uint32_t into which minor number will\n  be copied\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_INIT_ERROR if failed to get minor number during\n  initialization.\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_drm_render_minor_get(dv_ind: u32, minor: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the device subsystem vendor id associated with the device with\n  provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p id,\n  this function will write the device subsystem vendor id value to the\n  uint64_t pointed to by @p id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the device subsystem vendor\n  id will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_subsystem_vendor_id_get(dv_ind: u32, id: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get Unique ID\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t @p\n  id, this function will write the unique ID of the GPU pointed to @p\n  id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the unique ID of the GPU\n  is written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_unique_id_get(dv_ind: u32, id: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "/\n/** @defgroup PCIeQuer PCIe Queries\n  These functions provide information about PCIe.\n  @{\n/\n/**\n  @brief Get the list of possible PCIe bandwidths that are available.\n\n  @details Given a device index @p dv_ind and a pointer to a to an\n  ::rsmi_pcie_bandwidth_t structure @p bandwidth, this function will fill in\n  @p bandwidth with the possible T/s values and associated number of lanes,\n  and indication of the current selection.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] bandwidth a pointer to a caller provided\n  ::rsmi_pcie_bandwidth_t structure to which the frequency information will be\n  written\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_pci_bandwidth_get(
        dv_ind: u32,
        bandwidth: *mut rsmi_pcie_bandwidth_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the unique PCI device identifier associated for a device\n\n  @details Give a device index @p dv_ind and a pointer to a uint64_t @p\n  bdfid, this function will write the Bus/Device/Function PCI identifier\n  (BDFID) associated with device @p dv_ind to the value pointed to by\n  @p bdfid.\n\n  The format of @p bdfid will be as follows:\n\n      BDFID = ((DOMAIN & 0xffffffff) << 32) | ((BUS & 0xff) << 8) |\n                                   ((DEVICE & 0x1f) <<3 ) | (FUNCTION & 0x7)\n\n  | Name     | Field   |\n  ---------- | ------- |\n  | Domain   | [64:32] |\n  | Reserved | [31:16] |\n  | Bus      | [15: 8] |\n  | Device   | [ 7: 3] |\n  | Function | [ 2: 0] |\n\n  @param[in] dv_ind a device index\n\n  @param[inout] bdfid a pointer to uint64_t to which the device bdfid value\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_pci_id_get(dv_ind: u32, bdfid: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the NUMA node associated with a device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p\n  numa_node, this function will retrieve the NUMA node value associated\n  with device @p dv_ind and store the value at location pointed to by\n  @p numa_node.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] numa_node pointer to location where NUMA node value will\n  be written.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_topo_numa_affinity_get(dv_ind: u32, numa_node: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get PCIe traffic information\n\n  @details Give a device index @p dv_ind and pointers to a uint64_t's, @p\n  sent, @p received and @p max_pkt_sz, this function will write the number\n  of bytes sent and received in 1 second to @p sent and @p received,\n  respectively. The maximum possible packet size will be written to\n  @p max_pkt_sz.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] sent a pointer to uint64_t to which the number of bytes sent\n  will be written in 1 second. If pointer is NULL, it will be ignored.\n\n  @param[inout] received a pointer to uint64_t to which the number of bytes\n  received will be written. If pointer is NULL, it will be ignored.\n\n  @param[inout] max_pkt_sz a pointer to uint64_t to which the maximum packet\n  size will be written. If pointer is NULL, it will be ignored.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments"]
    pub fn rsmi_dev_pci_throughput_get(
        dv_ind: u32,
        sent: *mut u64,
        received: *mut u64,
        max_pkt_sz: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get PCIe replay counter\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t @p\n  counter, this function will write the sum of the number of NAK's received\n  by the GPU and the NAK's generated by the GPU to memory pointed to by @p\n  counter.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] counter a pointer to uint64_t to which the sum of the NAK's\n  received and generated by the GPU is written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_pci_replay_counter_get(dv_ind: u32, counter: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Control the set of allowed PCIe bandwidths that can be used.\n\n  @details Given a device index @p dv_ind and a 64 bit bitmask @p bw_bitmask,\n  this function will limit the set of allowable bandwidths. If a bit in @p\n  bw_bitmask has a value of 1, then the frequency (as ordered in an\n  ::rsmi_frequencies_t returned by ::rsmi_dev_gpu_clk_freq_get()) corresponding\n  to that bit index will be allowed.\n\n  This function will change the performance level to\n  ::RSMI_DEV_PERF_LEVEL_MANUAL in order to modify the set of allowable\n  band_widths. Caller will need to set to ::RSMI_DEV_PERF_LEVEL_AUTO in order\n  to get back to default state.\n\n  All bits with indices greater than or equal to the value of the\n  ::rsmi_frequencies_t::num_supported field of ::rsmi_pcie_bandwidth_t will be\n  ignored.\n\n  @param[in] dv_ind a device index\n\n  @param[in] bw_bitmask A bitmask indicating the indices of the\n  bandwidths that are to be enabled (1) and disabled (0). Only the lowest\n  ::rsmi_frequencies_t::num_supported (of ::rsmi_pcie_bandwidth_t) bits of\n  this mask are relevant.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_pci_bandwidth_set(dv_ind: u32, bw_bitmask: u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "/\n/** @defgroup PowerQuer Power Queries\n  These functions provide information about power usage.\n  @{\n/\n/**\n  @brief Get the average power consumption of the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t\n  @p power, this function will write the current average power consumption\n  (in microwatts) to the uint64_t pointed to by @p power.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] power a pointer to uint64_t to which the average power\n  consumption will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_power_ave_get(dv_ind: u32, sensor_ind: u32, power: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the energy accumulator counter of the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind, a pointer to a uint64_t\n  @p power, and a pointer to a uint64_t @p timestamp, this function will write\n  amount of energy consumed to the uint64_t pointed to by @p power,\n  and the timestamp to the uint64_t pointed to by @p timestamp.\n  The rsmi_dev_power_ave_get() is an average of a short time. This function\n  accumulates all energy consumed.\n\n  @param[in] dv_ind a device index\n  @param[inout] counter_resolution resolution of the counter @p power in\n  micro Joules\n\n  @param[inout] power a pointer to uint64_t to which the energy\n  counter will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[inout] timestamp a pointer to uint64_t to which the timestamp\n  will be written. Resolution: 1 ns.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_energy_count_get(
        dv_ind: u32,
        power: *mut u64,
        counter_resolution: *mut f32,
        timestamp: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the cap on power which, when reached, causes the system to take\n  action to reduce power.\n\n  @details When power use rises above the value @p power, the system will\n  take action to reduce power use. The power level returned through\n  @p power will be in microWatts.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] cap a pointer to a uint64_t that indicates the power cap,\n  in microwatts\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_power_cap_get(dv_ind: u32, sensor_ind: u32, cap: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the default power cap for the device specified by @p dv_ind.\n\n  @details The maximum power cap be temporarily changed by the user. However,\n  this function always returns the default reset power cap. The power level\n  returned through @p power will be in microWatts.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] default_cap a pointer to a uint64_t that indicates the default\n  power cap, in microwatts\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_power_cap_default_get(dv_ind: u32, default_cap: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the range of valid values for the power cap\n\n  @details This function will return the maximum possible valid power cap\n  @p max and the minimum possible valid power cap @p min\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] max a pointer to a uint64_t that indicates the maximum\n  possible power cap, in microwatts\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[inout] min a pointer to a uint64_t that indicates the minimum\n  possible power cap, in microwatts\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_power_cap_range_get(
        dv_ind: u32,
        sensor_ind: u32,
        max: *mut u64,
        min: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "/\n/** @defgroup PowerCont Power Control\n  These functions provide ways to control power usage.\n  @{\n/\n/**\n  @brief Set the power cap value\n\n  @details This function will set the power cap to the provided value @p cap.\n  @p cap must be between the minimum and maximum power cap values set by the\n  system, which can be obtained from ::rsmi_dev_power_cap_range_get.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[in] cap a uint64_t that indicates the desired power cap, in\n  microwatts\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_power_cap_set(dv_ind: u32, sensor_ind: u32, cap: u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Set the power profile\n\n  @details Given a device index @p dv_ind and a @p profile, this function will\n  attempt to set the current profile to the provided profile. The provided\n  profile must be one of the currently supported profiles, as indicated by a\n  call to ::rsmi_dev_power_profile_presets_get()\n\n  @param[in] dv_ind a device index\n\n  @param[in] reserved Not currently used. Set to 0.\n\n  @param[in] profile a ::rsmi_power_profile_preset_masks_t that hold the mask\n  of the desired new power profile\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_power_profile_set(
        dv_ind: u32,
        reserved: u32,
        profile: rsmi_power_profile_preset_masks_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the total amount of memory that exists\n\n  @details Given a device index @p dv_ind, a type of memory @p mem_type, and\n  a pointer to a uint64_t @p total, this function will write the total amount\n  of @p mem_type memory that exists to the location pointed to by @p total.\n\n  @param[in] dv_ind a device index\n\n  @param[in] mem_type The type of memory for which the total amount will be\n  found\n\n  @param[inout] total a pointer to uint64_t to which the total amount of\n  memory will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_memory_total_get(
        dv_ind: u32,
        mem_type: rsmi_memory_type_t,
        total: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the current memory usage\n\n  @details Given a device index @p dv_ind, a type of memory @p mem_type, and\n  a pointer to a uint64_t @p usage, this function will write the amount of\n  @p mem_type memory that that is currently being used to the location\n  pointed to by @p used.\n\n  @param[in] dv_ind a device index\n\n  @param[in] mem_type The type of memory for which the amount being used will\n  be found\n\n  @param[inout] used a pointer to uint64_t to which the amount of memory\n  currently being used will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_memory_usage_get(
        dv_ind: u32,
        mem_type: rsmi_memory_type_t,
        used: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get percentage of time any device memory is being used\n\n  @details Given a device index @p dv_ind, this function returns the\n  percentage of time that any device memory is being used for the specified\n  device.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] busy_percent a pointer to the uint32_t to which the busy\n  percent will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_memory_busy_percent_get(dv_ind: u32, busy_percent: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get information about reserved (\"retired\") memory pages\n\n  @details Given a device index @p dv_ind, this function returns retired page\n  information @p records corresponding to the device with the provided device\n  index @p dv_ind. The number of retired page records is returned through @p\n  num_pages. @p records may be NULL on input. In this case, the number of\n  records available for retrieval will be returned through @p num_pages.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] num_pages a pointer to a uint32. As input, the value passed\n  through this parameter is the number of ::rsmi_retired_page_record_t's that\n  may be safely written to the memory pointed to by @p records. This is the\n  limit on how many records will be written to @p records. On return, @p\n  num_pages will contain the number of records written to @p records, or the\n  number of records that could have been written if enough memory had been\n  provided.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[inout] records A pointer to a block of memory to which the\n  ::rsmi_retired_page_record_t values will be written. This value may be NULL.\n  In this case, this function can be used to query how many records are\n  available to read.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if more records were available\n  than allowed by the provided, allocated memory."]
    pub fn rsmi_dev_memory_reserved_pages_get(
        dv_ind: u32,
        num_pages: *mut u32,
        records: *mut rsmi_retired_page_record_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @defgroup PhysQuer Physical State Queries\n  These functions provide information about the physical characteristics of\n  the device.\n  @{\n/\n/**\n  @brief Get the fan speed in RPMs of the device with the specified device\n  index and 0-based sensor index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t\n  @p speed, this function will write the current fan speed in RPMs to the\n  uint32_t pointed to by @p speed\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] speed a pointer to uint32_t to which the speed will be\n  written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_fan_rpms_get(dv_ind: u32, sensor_ind: u32, speed: *mut i64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the fan speed for the specified device as a value relative to\n  ::RSMI_MAX_FAN_SPEED\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t\n  @p speed, this function will write the current fan speed (a value\n  between 0 and the maximum fan speed, ::RSMI_MAX_FAN_SPEED) to the uint32_t\n  pointed to by @p speed\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] speed a pointer to uint32_t to which the speed will be\n  written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_fan_speed_get(dv_ind: u32, sensor_ind: u32, speed: *mut i64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the max. fan speed of the device with provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t\n  @p max_speed, this function will write the maximum fan speed possible to\n  the uint32_t pointed to by @p max_speed\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] max_speed a pointer to uint32_t to which the maximum speed\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_fan_speed_max_get(
        dv_ind: u32,
        sensor_ind: u32,
        max_speed: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the temperature metric value for the specified metric, from the\n  specified temperature sensor on the specified device.\n\n  @details Given a device index @p dv_ind, a sensor type @p sensor_type, a\n  ::rsmi_temperature_metric_t @p metric and a pointer to an int64_t @p\n  temperature, this function will write the value of the metric indicated by\n  @p metric and @p sensor_type to the memory location @p temperature.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_type part of device from which temperature should be\n  obtained. This should come from the enum ::rsmi_temperature_type_t\n\n  @param[in] metric enum indicated which temperature value should be\n  retrieved\n\n  @param[inout] temperature a pointer to int64_t to which the temperature\n  will be written, in millidegrees Celsius.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_temp_metric_get(
        dv_ind: u32,
        sensor_type: u32,
        metric: rsmi_temperature_metric_t,
        temperature: *mut i64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the voltage metric value for the specified metric, from the\n  specified voltage sensor on the specified device.\n\n  @details Given a device index @p dv_ind, a sensor type @p sensor_type, a\n  ::rsmi_voltage_metric_t @p metric and a pointer to an int64_t @p\n  voltage, this function will write the value of the metric indicated by\n  @p metric and @p sensor_type to the memory location @p voltage.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_type part of device from which voltage should be\n  obtained. This should come from the enum ::rsmi_voltage_type_t\n\n  @param[in] metric enum indicated which voltage value should be\n  retrieved\n\n  @param[inout] voltage a pointer to int64_t to which the voltage\n  will be written, in millivolts.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_volt_metric_get(
        dv_ind: u32,
        sensor_type: rsmi_voltage_type_t,
        metric: rsmi_voltage_metric_t,
        voltage: *mut i64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "/\n/** @defgroup PhysCont Physical State Control\n  These functions provide control over the physical state of a device.\n  @{\n/\n/**\n  @brief Reset the fan to automatic driver control\n\n  @details This function returns control of the fan to the system\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n"]
    pub fn rsmi_dev_fan_reset(dv_ind: u32, sensor_ind: u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Set the fan speed for the specified device with the provided speed,\n  in RPMs.\n\n  @details Given a device index @p dv_ind and a integer value indicating\n  speed @p speed, this function will attempt to set the fan speed to @p speed.\n  An error will be returned if the specified speed is outside the allowable\n  range for the device. The maximum value is 255 and the minimum is 0.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[in] speed the speed to which the function will attempt to set the fan\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_fan_speed_set(dv_ind: u32, sensor_ind: u32, speed: u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get percentage of time device is busy doing any processing\n\n  @details Given a device index @p dv_ind, this function returns the\n  percentage of time that the specified device is busy. The device is\n  considered busy if any one or more of its sub-blocks are working, and idle\n  if none of the sub-blocks are working.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] busy_percent a pointer to the uint32_t to which the busy\n  percent will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_busy_percent_get(dv_ind: u32, busy_percent: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get coarse grain utilization counter of the specified device\n\n  @details Given a device index @p dv_ind, the array of the utilization counters,\n  the size of the array, this function returns the coarse grain utilization counters\n  and timestamp.\n  The counter is the accumulated percentages. Every milliseconds the firmware calculates\n  % busy count and then accumulates that value in the counter. This provides minimally\n  invasive coarse grain GPU usage information.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] utilization_counters Multiple utilization counters can be retreived with a single\n  call. The caller must allocate enough space to the utilization_counters array. The caller also\n  needs to set valid RSMI_UTILIZATION_COUNTER_TYPE type for each element of the array.\n  ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments.\n\n  If the function reutrns RSMI_STATUS_SUCCESS, the counter will be set in the value field of\n  the rsmi_utilization_counter_t.\n\n  @param[in] count The size of @utilization_counters array.\n\n  @param[inout] timestamp The timestamp when the counter is retreived. Resolution: 1 ns.\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_utilization_count_get(
        dv_ind: u32,
        utilization_counters: *mut rsmi_utilization_counter_t,
        count: u32,
        timestamp: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the performance level of the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p\n  perf, this function will write the ::rsmi_dev_perf_level_t to the uint32_t\n  pointed to by @p perf\n\n  @param[in] dv_ind a device index\n\n  @param[inout] perf a pointer to ::rsmi_dev_perf_level_t to which the\n  performance level will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_perf_level_get(dv_ind: u32, perf: *mut rsmi_dev_perf_level_t) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Enter performance determinism mode with provided device index.\n\n  @details Given a device index @p dv_ind and @p clkvalue this function\n  will enable performance determinism mode, which enforces a GFXCLK frequency\n  SoftMax limit per GPU set by the user. This prevents the GFXCLK PLL from\n  stretching when running the same workload on different GPUS, making\n  performance variation minimal. This call will result in the performance\n  level ::rsmi_dev_perf_level_t of the device being\n  ::RSMI_DEV_PERF_LEVEL_DETERMINISM.\n\n  @param[in] dv_ind a device index\n\n  @param[in] clkvalue Softmax value for GFXCLK in MHz.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_perf_determinism_mode_set(dv_ind: u32, clkvalue: u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the overdrive percent associated with the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p od,\n  this function will write the overdrive percentage to the uint32_t pointed\n  to by @p od\n\n  @param[in] dv_ind a device index\n\n  @param[inout] od a pointer to uint32_t to which the overdrive percentage\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_overdrive_level_get(dv_ind: u32, od: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the memory clock overdrive percent associated with the device\n  with provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p od,\n  this function will write the memory overdrive percentage to the uint32_t\n  pointed to by @p od\n\n  @param[in] dv_ind a device index\n\n  @param[inout] od a pointer to uint32_t to which the overdrive percentage\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_mem_overdrive_level_get(dv_ind: u32, od: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the list of possible system clock speeds of device for a\n  specified clock type.\n\n  @details Given a device index @p dv_ind, a clock type @p clk_type, and a\n  pointer to a to an ::rsmi_frequencies_t structure @p f, this function will\n  fill in @p f with the possible clock speeds, and indication of the current\n  clock speed selection.\n\n  @param[in] dv_ind a device index\n\n  @param[in] clk_type the type of clock for which the frequency is desired\n\n  @param[inout] f a pointer to a caller provided ::rsmi_frequencies_t structure\n  to which the frequency information will be written. Frequency values are in\n  Hz.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n  If multiple current frequencies are found, a warning is shown. If no\n  current frequency is found, it is reflected as -1. If frequencies are not\n  read from low to high a warning is shown as well.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_gpu_clk_freq_get(
        dv_ind: u32,
        clk_type: rsmi_clk_type_t,
        f: *mut rsmi_frequencies_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Reset the gpu associated with the device with provided device index\n\n  @details Given a device index @p dv_ind, this function will reset the GPU\n\n  @param[in] dv_ind a device index\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_gpu_reset(dv_ind: i32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief This function retrieves the voltage/frequency curve information\n\n  @details Given a device index @p dv_ind and a pointer to a\n  ::rsmi_od_volt_freq_data_t structure @p odv, this function will populate @p\n  odv. See ::rsmi_od_volt_freq_data_t for more details.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] odv a pointer to an ::rsmi_od_volt_freq_data_t structure\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_od_volt_info_get(
        dv_ind: u32,
        odv: *mut rsmi_od_volt_freq_data_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief This function retrieves the gpu metrics information\n\n  @details Given a device index @p dv_ind and a pointer to a\n  ::rsmi_gpu_metrics_t structure @p pgpu_metrics, this function will populate\n  @p pgpu_metrics. See ::rsmi_gpu_metrics_t for more details.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pgpu_metrics a pointer to an ::rsmi_gpu_metrics_t structure\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_gpu_metrics_info_get(
        dv_ind: u32,
        pgpu_metrics: *mut rsmi_gpu_metrics_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief This function sets the clock range information\n\n  @details Given a device index @p dv_ind, a minimum clock value @p minclkvalue,\n  a maximum clock value @p maxclkvalue and a clock type @p clkType this function\n  will set the sclk|mclk range\n\n  @param[in] dv_ind a device index\n\n  @param[in] minclkvalue value to apply to the clock range. Frequency values\n  are in MHz.\n\n  @param[in] maxclkvalue value to apply to the clock range. Frequency values\n  are in MHz.\n\n  @param[in] clkType RSMI_CLK_TYPE_SYS | RSMI_CLK_TYPE_MEM range type\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_clk_range_set(
        dv_ind: u32,
        minclkvalue: u64,
        maxclkvalue: u64,
        clkType: rsmi_clk_type_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief This function sets the clock frequency information\n\n  @details Given a device index @p dv_ind, a frequency level @p level,\n  a clock value @p clkvalue and a clock type @p clkType this function\n  will set the sclk|mclk range\n\n  @param[in] dv_ind a device index\n\n  @param[in] level RSMI_FREQ_IND_MIN|RSMI_FREQ_IND_MAX to set the\n  minimum (0) or maximum (1) speed.\n\n  @param[in] clkvalue value to apply to the clock range. Frequency values\n  are in MHz.\n\n  @param[in] clkType RSMI_CLK_TYPE_SYS | RSMI_CLK_TYPE_MEM range type\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_od_clk_info_set(
        dv_ind: u32,
        level: rsmi_freq_ind_t,
        clkvalue: u64,
        clkType: rsmi_clk_type_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief This function sets  1 of the 3 voltage curve points.\n\n  @details Given a device index @p dv_ind, a voltage point @p vpoint\n  and a voltage value @p voltvalue this function will set voltage curve point\n\n  @param[in] dv_ind a device index\n\n  @param[in] vpoint voltage point [0|1|2] on the voltage curve\n\n  @param[in] clkvalue clock value component of voltage curve point.\n  Frequency values are in MHz.\n\n  @param[in] voltvalue voltage value component of voltage curve point.\n  Voltage is in mV.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_od_volt_info_set(
        dv_ind: u32,
        vpoint: u32,
        clkvalue: u64,
        voltvalue: u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief This function will retrieve the current valid regions in the\n  frequency/voltage space.\n\n  @details Given a device index @p dv_ind, a pointer to an unsigned integer\n  @p num_regions and a buffer of ::rsmi_freq_volt_region_t structures, @p\n  buffer, this function will populate @p buffer with the current\n  frequency-volt space regions. The caller should assign @p buffer to memory\n  that can be written to by this function. The caller should also\n  indicate the number of ::rsmi_freq_volt_region_t structures that can safely\n  be written to @p buffer in @p num_regions.\n\n  The number of regions to expect this function provide (@p num_regions) can\n  be obtained by calling ::rsmi_dev_od_volt_info_get().\n\n  @param[in] dv_ind a device index\n\n  @param[inout] num_regions As input, this is the number of\n  ::rsmi_freq_volt_region_t structures that can be written to @p buffer. As\n  output, this is the number of ::rsmi_freq_volt_region_t structures that were\n  actually written.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[inout] buffer a caller provided buffer to which\n  ::rsmi_freq_volt_region_t structures will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_od_volt_curve_regions_get(
        dv_ind: u32,
        num_regions: *mut u32,
        buffer: *mut rsmi_freq_volt_region_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the list of available preset power profiles and an indication of\n  which profile is currently active.\n\n  @details Given a device index @p dv_ind and a pointer to a\n  ::rsmi_power_profile_status_t @p status, this function will set the bits of\n  the ::rsmi_power_profile_status_t.available_profiles bit field of @p status to\n  1 if the profile corresponding to the respective\n  ::rsmi_power_profile_preset_masks_t profiles are enabled. For example, if both\n  the VIDEO and VR power profiles are available selections, then\n  ::RSMI_PWR_PROF_PRST_VIDEO_MASK AND'ed with\n  ::rsmi_power_profile_status_t.available_profiles will be non-zero as will\n  ::RSMI_PWR_PROF_PRST_VR_MASK AND'ed with\n  ::rsmi_power_profile_status_t.available_profiles. Additionally,\n  ::rsmi_power_profile_status_t.current will be set to the\n  ::rsmi_power_profile_preset_masks_t of the profile that is currently active.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] status a pointer to ::rsmi_power_profile_status_t that will be\n  populated by a call to this function\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_power_profile_presets_get(
        dv_ind: u32,
        sensor_ind: u32,
        status: *mut rsmi_power_profile_status_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @defgroup PerfCont Clock, Power and Performance Control\n  These functions provide control over clock frequencies, power and\n  performance.\n  @{\n/\n/**\n  @brief Set the PowerPlay performance level associated with the device with\n  provided device index with the provided value.\n\n  @deprecated ::rsmi_dev_perf_level_set_v1() is preferred, with an\n  interface that more closely  matches the rest of the rocm_smi API.\n\n  @details Given a device index @p dv_ind and an ::rsmi_dev_perf_level_t @p\n  perf_level, this function will set the PowerPlay performance level for the\n  device to the value @p perf_lvl.\n\n  @param[in] dv_ind a device index\n\n  @param[in] perf_lvl the value to which the performance level should be set\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_perf_level_set(dv_ind: i32, perf_lvl: rsmi_dev_perf_level_t) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Set the PowerPlay performance level associated with the device with\n  provided device index with the provided value.\n\n  @details Given a device index @p dv_ind and an ::rsmi_dev_perf_level_t @p\n  perf_level, this function will set the PowerPlay performance level for the\n  device to the value @p perf_lvl.\n\n  @param[in] dv_ind a device index\n\n  @param[in] perf_lvl the value to which the performance level should be set\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_perf_level_set_v1(
        dv_ind: u32,
        perf_lvl: rsmi_dev_perf_level_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Set the overdrive percent associated with the device with provided\n  device index with the provided value. See details for WARNING.\n\n  @deprecated This function is deprecated. ::rsmi_dev_overdrive_level_set_v1\n  has the same functionaltiy, with an interface that more closely\n  matches the rest of the rocm_smi API.\n\n  @details Given a device index @p dv_ind and an overdrive level @p od,\n  this function will set the overdrive level for the device to the value\n  @p od. The overdrive level is an integer value between 0 and 20, inclusive,\n  which represents the overdrive percentage; e.g., a value of 5 specifies\n  an overclocking of 5%.\n\n  The overdrive level is specific to the gpu system clock.\n\n  The overdrive level is the percentage above the maximum Performance Level\n  to which overclocking will be limited. The overclocking percentage does\n  not apply to clock speeds other than the maximum. This percentage is\n  limited to 20%.\n\n   ******WARNING******\n  Operating your AMD GPU outside of official AMD specifications or outside of\n  factory settings, including but not limited to the conducting of\n  overclocking (including use of this overclocking software, even if such\n  software has been directly or indirectly provided by AMD or otherwise\n  affiliated in any way with AMD), may cause damage to your AMD GPU, system\n  components and/or result in system failure, as well as cause other problems.\n  DAMAGES CAUSED BY USE OF YOUR AMD GPU OUTSIDE OF OFFICIAL AMD SPECIFICATIONS\n  OR OUTSIDE OF FACTORY SETTINGS ARE NOT COVERED UNDER ANY AMD PRODUCT\n  WARRANTY AND MAY NOT BE COVERED BY YOUR BOARD OR SYSTEM MANUFACTURER'S\n  WARRANTY. Please use this utility with caution.\n\n  @param[in] dv_ind a device index\n\n  @param[in] od the value to which the overdrive level should be set\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_overdrive_level_set(dv_ind: i32, od: u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Set the overdrive percent associated with the device with provided\n  device index with the provided value. See details for WARNING.\n\n  @details Given a device index @p dv_ind and an overdrive level @p od,\n  this function will set the overdrive level for the device to the value\n  @p od. The overdrive level is an integer value between 0 and 20, inclusive,\n  which represents the overdrive percentage; e.g., a value of 5 specifies\n  an overclocking of 5%.\n\n  The overdrive level is specific to the gpu system clock.\n\n  The overdrive level is the percentage above the maximum Performance Level\n  to which overclocking will be limited. The overclocking percentage does\n  not apply to clock speeds other than the maximum. This percentage is\n  limited to 20%.\n\n   ******WARNING******\n  Operating your AMD GPU outside of official AMD specifications or outside of\n  factory settings, including but not limited to the conducting of\n  overclocking (including use of this overclocking software, even if such\n  software has been directly or indirectly provided by AMD or otherwise\n  affiliated in any way with AMD), may cause damage to your AMD GPU, system\n  components and/or result in system failure, as well as cause other problems.\n  DAMAGES CAUSED BY USE OF YOUR AMD GPU OUTSIDE OF OFFICIAL AMD SPECIFICATIONS\n  OR OUTSIDE OF FACTORY SETTINGS ARE NOT COVERED UNDER ANY AMD PRODUCT\n  WARRANTY AND MAY NOT BE COVERED BY YOUR BOARD OR SYSTEM MANUFACTURER'S\n  WARRANTY. Please use this utility with caution.\n\n  @param[in] dv_ind a device index\n\n  @param[in] od the value to which the overdrive level should be set\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_overdrive_level_set_v1(dv_ind: u32, od: u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Control the set of allowed frequencies that can be used for the\n specified clock.\n\n @details Given a device index @p dv_ind, a clock type @p clk_type, and a\n 64 bit bitmask @p freq_bitmask, this function will limit the set of\n allowable frequencies. If a bit in @p freq_bitmask has a value of 1, then\n the frequency (as ordered in an ::rsmi_frequencies_t returned by\n rsmi_dev_gpu_clk_freq_get()) corresponding to that bit index will be\n allowed.\n\n This function will change the performance level to\n ::RSMI_DEV_PERF_LEVEL_MANUAL in order to modify the set of allowable\n frequencies. Caller will need to set to ::RSMI_DEV_PERF_LEVEL_AUTO in order\n to get back to default state.\n\n All bits with indices greater than or equal to\n ::rsmi_frequencies_t::num_supported will be ignored.\n\n  @param[in] dv_ind a device index\n\n  @param[in] clk_type the type of clock for which the set of frequencies\n  will be modified\n\n  @param[in] freq_bitmask A bitmask indicating the indices of the\n  frequencies that are to be enabled (1) and disabled (0). Only the lowest\n  ::rsmi_frequencies_t.num_supported bits of this mask are relevant.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_gpu_clk_freq_set(
        dv_ind: u32,
        clk_type: rsmi_clk_type_t,
        freq_bitmask: u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Get the build version information for the currently running build of\n RSMI.\n\n @details  Get the major, minor, patch and build string for RSMI build\n currently in use through @p version\n\n @param[inout] version A pointer to an ::rsmi_version_t structure that will\n be updated with the version information upon return.\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n"]
    pub fn rsmi_version_get(version: *mut rsmi_version_t) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the driver version string for the current system.\n\n  @details Given a software component @p component, a pointer to a char\n  buffer, @p ver_str, this function will write the driver version string\n  (up to @p len characters) for the current system to @p ver_str. The caller\n  must ensure that it is safe to write at least @p len characters to @p\n  ver_str.\n\n  @param[in] component The component for which the version string is being\n  requested\n\n  @param[inout] ver_str A pointer to a buffer of char's to which the version\n  of @p component will be written\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written."]
    pub fn rsmi_version_str_get(
        component: rsmi_sw_component_t,
        ver_str: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the VBIOS identifer string\n\n  @details Given a device ID @p dv_ind, and a pointer to a char buffer,\n  @p vbios, this function will write the VBIOS string (up to @p len\n  characters) for device @p dv_ind to @p vbios. The caller must ensure that\n  it is safe to write at least @p len characters to @p vbios.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] vbios A pointer to a buffer of char's to which the VBIOS name\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len The number of char's pointed to by @p vbios which can safely\n  be written to by this function.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_vbios_version_get(
        dv_ind: u32,
        vbios: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the firmware versions for a device\n\n  @details Given a device ID @p dv_ind, and a pointer to a uint64_t,\n  @p fw_version, this function will write the FW Versions as a string (up to @p len\n  characters) for device @p dv_ind to @p vbios. The caller must ensure that\n  it is safe to write at least @p len characters to @p vbios.\n\n  @param[in] dv_ind a device index\n\n  @param[in] block The firmware block for which the version is being requested\n\n  @param[inout] fw_version The version for the firmware block\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_firmware_version_get(
        dv_ind: u32,
        block: rsmi_fw_block_t,
        fw_version: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Retrieve the error counts for a GPU block\n\n  @details Given a device index @p dv_ind, an ::rsmi_gpu_block_t @p block and a\n  pointer to an ::rsmi_error_count_t @p ec, this function will write the error\n  count values for the GPU block indicated by @p block to memory pointed to by\n  @p ec.\n\n  @param[in] dv_ind a device index\n\n  @param[in] block The block for which error counts should be retrieved\n\n  @param[inout] ec A pointer to an ::rsmi_error_count_t to which the error\n  counts should be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_ecc_count_get(
        dv_ind: u32,
        block: rsmi_gpu_block_t,
        ec: *mut rsmi_error_count_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Retrieve the enabled ECC bit-mask\n\n  @details Given a device index @p dv_ind, and a pointer to a uint64_t @p\n  enabled_mask, this function will write bits to memory pointed to by\n  @p enabled_blocks. Upon a successful call, @p enabled_blocks can then be\n  AND'd with elements of the ::rsmi_gpu_block_t ennumeration to determine if\n  the corresponding block has ECC enabled. Note that whether a block has ECC\n  enabled or not in the device is independent of whether there is kernel\n  support for error counting for that block. Although a block may be enabled,\n  but there may not be kernel support for reading error counters for that\n  block.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] enabled_blocks A pointer to a uint64_t to which the enabled\n  blocks bits will be written.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_ecc_enabled_get(dv_ind: u32, enabled_blocks: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Retrieve the ECC status for a GPU block\n\n  @details Given a device index @p dv_ind, an ::rsmi_gpu_block_t @p block and\n  a pointer to an ::rsmi_ras_err_state_t @p state, this function will write\n  the current state for the GPU block indicated by @p block to memory pointed\n  to by @p state.\n\n  @param[in] dv_ind a device index\n\n  @param[in] block The block for which error counts should be retrieved\n\n  @param[inout] state A pointer to an ::rsmi_ras_err_state_t to which the\n  ECC state should be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_ecc_status_get(
        dv_ind: u32,
        block: rsmi_gpu_block_t,
        state: *mut rsmi_ras_err_state_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get a description of a provided RSMI error status\n\n  @details Set the provided pointer to a const char *, @p status_string, to\n  a string containing a description of the provided error code @p status.\n\n  @param[in] status The error status for which a description is desired\n\n  @param[inout] status_string A pointer to a const char * which will be made\n  to point to a description of the provided error code\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n"]
    pub fn rsmi_status_string(
        status: rsmi_status_t,
        status_string: *mut *const ::std::os::raw::c_char,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Tell if an event group is supported by a given device\n\n  @details Given a device index @p dv_ind and an event group specifier @p\n  group, tell if @p group type events are supported by the device associated\n  with @p dv_ind\n\n  @param[in] dv_ind device index of device being queried\n\n  @param[in] group ::rsmi_event_group_t identifier of group for which support\n  is being queried\n\n  @retval ::RSMI_STATUS_SUCCESS if the device associatee with @p dv_ind\n  support counting events of the type indicated by @p group.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  group\n"]
    pub fn rsmi_dev_counter_group_supported(
        dv_ind: u32,
        group: rsmi_event_group_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Create a performance counter object\n\n  @details Create a performance counter object of type @p type for the device\n  with a device index of @p dv_ind, and write a handle to the object to the\n  memory location pointed to by @p evnt_handle. @p evnt_handle can be used\n  with other performance event operations. The handle should be deallocated\n  with ::rsmi_dev_counter_destroy() when no longer needed.\n\n  @param[in] dv_ind a device index\n\n  @param[in] type the ::rsmi_event_type_t of performance event to create\n\n  @param[inout] evnt_handle A pointer to a ::rsmi_event_handle_t which will be\n  associated with a newly allocated counter\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_OUT_OF_RESOURCES unable to allocate memory for counter\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_counter_create(
        dv_ind: u32,
        type_: rsmi_event_type_t,
        evnt_handle: *mut rsmi_event_handle_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Deallocate a performance counter object\n\n  @details Deallocate the performance counter object with the provided\n  ::rsmi_event_handle_t @p evnt_handle\n\n  @param[in] evnt_handle handle to event object to be deallocated\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_counter_destroy(evnt_handle: rsmi_event_handle_t) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Issue performance counter control commands\n\n  @details Issue a command @p cmd on the event counter associated with the\n  provided handle @p evt_handle.\n\n  @param[in] evt_handle an event handle\n\n  @param[in] cmd The event counter command to be issued\n\n  @param[inout] cmd_args Currently not used. Should be set to NULL.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_counter_control(
        evt_handle: rsmi_event_handle_t,
        cmd: rsmi_counter_command_t,
        cmd_args: *mut ::std::os::raw::c_void,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Read the current value of a performance counter\n\n  @details Read the current counter value of the counter associated with the\n  provided handle @p evt_handle and write the value to the location pointed\n  to by @p value.\n\n  @param[in] evt_handle an event handle\n\n  @param[inout] value pointer to memory of size of ::rsmi_counter_value_t to\n  which the counter value will be written\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_counter_read(
        evt_handle: rsmi_event_handle_t,
        value: *mut rsmi_counter_value_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the number of currently available counters\n\n  @details Given a device index @p dv_ind, a performance event group @p grp,\n  and a pointer to a uint32_t @p available, this function will write the\n  number of @p grp type counters that are available on the device with index\n  @p dv_ind to the memory that @p available points to.\n\n  @param[in] dv_ind a device index\n\n  @param[in] grp an event device group\n\n  @param[inout] available A pointer to a uint32_t to which the number of\n  available counters will be written\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_counter_available_counters_get(
        dv_ind: u32,
        grp: rsmi_event_group_t,
        available: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get process information about processes currently using GPU\n\n  @details Given a non-NULL pointer to an array @p procs of\n  ::rsmi_process_info_t's, of length *@p num_items, this function will write\n  up to *@p num_items instances of ::rsmi_process_info_t to the memory pointed\n  to by @p procs. These instances contain information about each process\n  utilizing a GPU. If @p procs is not NULL, @p num_items will be updated with\n  the number of processes actually written. If @p procs is NULL, @p num_items\n  will be updated with the number of processes for which there is current\n  process information. Calling this function with @p procs being NULL is a way\n  to determine how much memory should be allocated for when @p procs is not\n  NULL.\n\n  @param[inout] procs a pointer to memory provided by the caller to which\n  process information will be written. This may be NULL in which case only @p\n  num_items will be updated with the number of processes found.\n\n  @param[inout] num_items A pointer to a uint32_t, which on input, should\n  contain the amount of memory in ::rsmi_process_info_t's which have been\n  provided by the @p procs argument. On output, if @p procs is non-NULL, this\n  will be updated with the number ::rsmi_process_info_t structs actually\n  written. If @p procs is NULL, this argument will be updated with the number\n  processes for which there is information.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if there were more\n  processes for which information was available, but not enough space was\n  provided as indicated by @p procs and @p num_items, on input."]
    pub fn rsmi_compute_process_info_get(
        procs: *mut rsmi_process_info_t,
        num_items: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get process information about a specific process\n\n  @details Given a pointer to an ::rsmi_process_info_t @p proc and a process\n  id\n  @p pid, this function will write the process information for @p pid, if\n  available, to the memory pointed to by @p proc.\n\n  @param[in] pid The process ID for which process information is being\n  requested\n\n  @param[inout] proc a pointer to a ::rsmi_process_info_t to which\n  process information for @p pid will be written if it is found.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_NOT_FOUND is returned if there was no process\n  information\n  found for the provided @p pid\n"]
    pub fn rsmi_compute_process_info_by_pid_get(
        pid: u32,
        proc_: *mut rsmi_process_info_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Get the device indices currently being used by a process\n\n  @details Given a process id @p pid, a non-NULL pointer to an array of\n  uint32_t's @p dv_indices of length *@p num_devices, this function will\n  write up to @p num_devices device indices to the memory pointed to by\n  @p dv_indices. If @p dv_indices is not NULL, @p num_devices will be\n  updated with the number of gpu's currently being used by process @p pid.\n  If @p dv_indices is NULL, @p dv_indices will be updated with the number of\n  gpus currently being used by @p pid. Calling this function with @p\n  dv_indices being NULL is a way to determine how much memory is required\n  for when @p dv_indices is not NULL.\n\n  @param[in] pid The process id of the process for which the number of gpus\n  currently being used is requested\n\n  @param[inout] dv_indices a pointer to memory provided by the caller to\n  which indices of devices currently being used by the process will be\n  written. This may be NULL in which case only @p num_devices will be\n  updated with the number of devices being used.\n\n  @param[inout] num_devices A pointer to a uint32_t, which on input, should\n  contain the amount of memory in uint32_t's which have been provided by the\n  @p dv_indices argument. On output, if @p dv_indices is non-NULL, this will\n  be updated with the number uint32_t's actually written. If @p dv_indices is\n  NULL, this argument will be updated with the number devices being used.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if there were more\n  gpu indices that could have been written, but not enough space was\n  provided as indicated by @p dv_indices and @p num_devices, on input.\n"]
    pub fn rsmi_compute_process_gpus_get(
        pid: u32,
        dv_indices: *mut u32,
        num_devices: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Retrieve the XGMI error status for a device\n\n  @details Given a device index @p dv_ind, and a pointer to an\n  ::rsmi_xgmi_status_t @p status, this function will write the current XGMI\n  error state ::rsmi_xgmi_status_t for the device @p dv_ind to the memory\n  pointed to by @p status.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] status A pointer to an ::rsmi_xgmi_status_t to which the\n  XGMI error state should be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_xgmi_error_status(
        dv_ind: u32,
        status: *mut rsmi_xgmi_status_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Reset the XGMI error status for a device\n\n @details Given a device index @p dv_ind, this function will reset the\n current XGMI error state ::rsmi_xgmi_status_t for the device @p dv_ind to\n rsmi_xgmi_status_t::RSMI_XGMI_STATUS_NO_ERRORS\n\n @param[in] dv_ind a device index\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_xgmi_error_reset(dv_ind: u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Retrieve the XGMI hive id for a device\n\n  @details Given a device index @p dv_ind, and a pointer to an\n  uint64_t @p hive_id, this function will write the current XGMI\n  hive id for the device @p dv_ind to the memory pointed to by @p hive_id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] hive_id A pointer to an uint64_t to which the XGMI hive id\n  should be written\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_xgmi_hive_id_get(dv_ind: u32, hive_id: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Retrieve the NUMA CPU node number for a device\n\n  @details Given a device index @p dv_ind, and a pointer to an\n  uint32_t @p numa_node, this function will write the\n  node number of NUMA CPU for the device @p dv_ind to the memory\n  pointed to by @p numa_node.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] numa_node A pointer to an uint32_t to which the\n  numa node number should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_topo_get_numa_node_number(dv_ind: u32, numa_node: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Retrieve the weight for a connection between 2 GPUs\n\n  @details Given a source device index @p dv_ind_src and\n  a destination device index @p dv_ind_dst, and a pointer to an\n  uint64_t @p weight, this function will write the\n  weight for the connection between the device @p dv_ind_src\n  and @p dv_ind_dst to the memory pointed to by @p weight.\n\n  @param[in] dv_ind_src the source device index\n\n  @param[in] dv_ind_dst the destination device index\n\n  @param[inout] weight A pointer to an uint64_t to which the\n  weight for the connection should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_topo_get_link_weight(
        dv_ind_src: u32,
        dv_ind_dst: u32,
        weight: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Retreive minimal and maximal io link bandwidth between 2 GPUs\n\n  @details Given a source device index @p dv_ind_src and\n  a destination device index @p dv_ind_dst,  pointer to an\n  uint64_t @p min_bandwidth, and a pointer to uint64_t @p max_bandwidth,\n  this function will write theoretical minimal and maximal bandwidth limits.\n  API works if src and dst are connected via xgmi and have 1 hop distance.\n\n  @param[in] dv_ind_src the source device index\n\n  @param[in] dv_ind_dst the destination device index\n\n  @param[inout] min_bandwidth A pointer to an uint64_t to which the\n  minimal bandwidth for the connection should be written.\n\n  @param[inout] max_bandwidth A pointer to an uint64_t to which the\n  maximal bandwidth for the connection should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_minmax_bandwidth_get(
        dv_ind_src: u32,
        dv_ind_dst: u32,
        min_bandwidth: *mut u64,
        max_bandwidth: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Retrieve the hops and the connection type between 2 GPUs\n\n  @details Given a source device index @p dv_ind_src and\n  a destination device index @p dv_ind_dst, and a pointer to an\n  uint64_t @p hops and a pointer to an RSMI_IO_LINK_TYPE @p type,\n  this function will write the number of hops and the connection type\n  between the device @p dv_ind_src and @p dv_ind_dst to the memory\n  pointed to by @p hops and @p type.\n\n  @param[in] dv_ind_src the source device index\n\n  @param[in] dv_ind_dst the destination device index\n\n  @param[inout] hops A pointer to an uint64_t to which the\n  hops for the connection should be written.\n\n  @param[inout] type A pointer to an ::RSMI_IO_LINK_TYPE to which the\n  type for the connection should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_topo_get_link_type(
        dv_ind_src: u32,
        dv_ind_dst: u32,
        hops: *mut u64,
        type_: *mut RSMI_IO_LINK_TYPE,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = "  @brief Return P2P availability status between 2 GPUs\n\n  @details Given a source device index @p dv_ind_src and\n  a destination device index @p dv_ind_dst, and a pointer to a\n  bool @accessible, this function will write the P2P connection status\n  between the device @p dv_ind_src and @p dv_ind_dst to the memory\n  pointed to by @p accessible.\n\n  @param[in] dv_ind_src the source device index\n\n  @param[in] dv_ind_dst the destination device index\n\n  @param[inout] accessible A pointer to a bool to which the status for\n  the P2P connection availability should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_is_P2P_accessible(
        dv_ind_src: u32,
        dv_ind_dst: u32,
        accessible: *mut bool,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Get a function name iterator of supported RSMI functions for a device\n\n @details Given a device index @p dv_ind, this function will write a function\n iterator handle to the caller-provided memory pointed to by @p handle. This\n handle can be used to iterate through all the supported functions.\n\n Note that although this function takes in @p dv_ind as an argument,\n ::rsmi_dev_supported_func_iterator_open itself will not be among the\n functions listed as supported. This is because\n ::rsmi_dev_supported_func_iterator_open does not depend on hardware or\n driver support and should always be supported.\n\n @param[in] dv_ind a device index of device for which support information is\n requested\n\n @param[inout] handle A pointer to caller-provided memory to which the\n function iterator will be written.\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_supported_func_iterator_open(
        dv_ind: u32,
        handle: *mut rsmi_func_id_iter_handle_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Get a variant iterator for a given handle\n\n @details Given a ::rsmi_func_id_iter_handle_t @p obj_h, this function will\n write a function iterator handle to the caller-provided memory pointed to\n by @p var_iter. This handle can be used to iterate through all the supported\n variants of the provided handle. @p obj_h may be a handle to a function\n object, as provided by a call to ::rsmi_dev_supported_func_iterator_open, or\n it may be a variant itself (from a call to\n ::rsmi_dev_supported_variant_iterator_open), it which case @p var_iter will\n be an iterator of the sub-variants of @p obj_h (e.g., monitors).\n\n This call allocates a small amount of memory to @p var_iter. To free this memory\n ::rsmi_dev_supported_func_iterator_close should be called on the returned\n iterator handle @p var_iter when it is no longer needed.\n\n @param[in] obj_h an iterator handle for which the variants are being requested\n\n @param[inout] var_iter A pointer to caller-provided memory to which the\n sub-variant iterator will be written.\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_supported_variant_iterator_open(
        obj_h: rsmi_func_id_iter_handle_t,
        var_iter: *mut rsmi_func_id_iter_handle_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Advance a function identifer iterator\n\n @details Given a function id iterator handle (::rsmi_func_id_iter_handle_t)\n @p handle, this function will increment the iterator to point to the next\n identifier. After a successful call to this function, obtaining the value\n of the iterator @p handle will provide the value of the next item in the\n list of functions/variants.\n\n If there are no more items in the list, ::RSMI_STATUS_NO_DATA is returned.\n\n @param[in] handle A pointer to an iterator handle to be incremented\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n @retval ::RSMI_STATUS_NO_DATA is returned when list of identifiers has been\n exhausted\n"]
    pub fn rsmi_func_iter_next(handle: rsmi_func_id_iter_handle_t) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Close a variant iterator handle\n\n @details Given a pointer to an ::rsmi_func_id_iter_handle_t @p handle, this\n function will free the resources being used by the handle\n\n @param[in] handle A pointer to an iterator handle to be closed\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_supported_func_iterator_close(
        handle: *mut rsmi_func_id_iter_handle_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Get the value associated with a function/variant iterator\n\n @details Given an ::rsmi_func_id_iter_handle_t @p handle, this function\n will write the identifier of the function/variant to the user provided\n memory pointed to by @p value.\n\n @p value may point to a function name, a variant id, or a monitor/sensor\n index, depending on what kind of iterator @p handle is\n\n @param[in] handle An iterator for which the value is being requested\n\n @param[inout] value A pointer to an ::rsmi_func_id_value_t provided by the\n caller to which this function will write the value associated with @p handle\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_func_iter_value_get(
        handle: rsmi_func_id_iter_handle_t,
        value: *mut rsmi_func_id_value_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Prepare to collect event notifications for a GPU\n\n @details This function prepares to collect events for the GPU with device\n ID @p dv_ind, by initializing any required system parameters. This call\n may open files which will remain open until ::rsmi_event_notification_stop()\n is called.\n\n @param dv_ind a device index corresponding to the device on which to\n listen for events\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call."]
    pub fn rsmi_event_notification_init(dv_ind: u32) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Specify which events to collect for a device\n\n @details Given a device index @p dv_ind and a @p mask consisting of\n elements of ::rsmi_evt_notification_type_t OR'd together, this function\n will listen for the events specified in @p mask on the device\n corresponding to @p dv_ind.\n\n @param dv_ind a device index corresponding to the device on which to\n listen for events\n\n @param mask Bitmask generated by OR'ing 1 or more elements of\n ::rsmi_evt_notification_type_t indicating which event types to listen for,\n where the rsmi_evt_notification_type_t value indicates the bit field, with\n bit position starting from 1.\n For example, if the mask field is 0x0000000000000003, which means first bit,\n bit 1 (bit position start from 1) and bit 2 are set, which indicate interest\n in receiving RSMI_EVT_NOTIF_VMFAULT (which has a value of 1) and\n RSMI_EVT_NOTIF_THERMAL_THROTTLE event (which has a value of 2).\n\n @retval ::RSMI_STATUS_INIT_ERROR is returned if\n ::rsmi_event_notification_init() has not been called before a call to this\n function\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call"]
    pub fn rsmi_event_notification_mask_set(dv_ind: u32, mask: u64) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Collect event notifications, waiting a specified amount of time\n\n @details Given a time period @p timeout_ms in milliseconds and a caller-\n provided buffer of ::rsmi_evt_notification_data_t's @p data with a length\n (in ::rsmi_evt_notification_data_t's, also specified by the caller) in the\n memory location pointed to by @p num_elem, this function will collect\n ::rsmi_evt_notification_type_t events for up to @p timeout_ms milliseconds,\n and write up to *@p num_elem event items to @p data. Upon return @p num_elem\n is updated with the number of events that were actually written. If events\n are already present when this function is called, it will write the events\n to the buffer then poll for new events if there is still caller-provided\n buffer available to write any new events that would be found.\n\n This function requires prior calls to ::rsmi_event_notification_init() and\n ::rsmi_event_notification_mask_set(). This function polls for the\n occurrance of the events on the respective devices that were previously\n specified by ::rsmi_event_notification_mask_set().\n\n @param[in] timeout_ms number of milliseconds to wait for an event\n to occur\n\n @param[inout] num_elem pointer to uint32_t, provided by the caller. On\n input, this value tells how many ::rsmi_evt_notification_data_t elements\n are being provided by the caller with @p data. On output, the location\n pointed to by @p num_elem will contain the number of items written to\n the provided buffer.\n\n @param[out] data pointer to a caller-provided memory buffer of size\n @p num_elem ::rsmi_evt_notification_data_t to which this function may safely\n write. If there are events found, up to @p num_elem event items will be\n written to @p data.\n\n @retval ::RSMI_STATUS_SUCCESS The function ran successfully. The events\n that were found are written to @p data and @p num_elems is updated\n with the number of elements that were written.\n\n @retval ::RSMI_STATUS_NO_DATA No events were found to collect.\n"]
    pub fn rsmi_event_notification_get(
        timeout_ms: ::std::os::raw::c_int,
        num_elem: *mut u32,
        data: *mut rsmi_evt_notification_data_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Close any file handles and free any resources used by event\n notification for a GPU\n\n @details Any resources used by event notification for the GPU with\n device index @p dv_ind will be free with this\n function. This includes freeing any memory and closing file handles. This\n should be called for every call to ::rsmi_event_notification_init()\n\n @param[in] dv_ind The device index of the GPU for which event\n notification resources will be free\n\n @retval ::RSMI_STATUS_INVALID_ARGS resources for the given device have\n either already been freed, or were never allocated by\n ::rsmi_event_notification_init()\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call"]
    pub fn rsmi_event_notification_stop(dv_ind: u32) -> rsmi_status_t;
}
