/* automatically generated by rust-bindgen 0.69.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const ADL_TRUE: u32 = 1;
pub const ADL_FALSE: u32 = 0;
pub const ADL_MAX_CHAR: u32 = 4096;
pub const ADL_MAX_PATH: u32 = 256;
pub const ADL_MAX_ADAPTERS: u32 = 250;
pub const ADL_MAX_DISPLAYS: u32 = 150;
pub const ADL_MAX_DEVICENAME: u32 = 32;
pub const ADL_ADAPTER_INDEX_ALL: i32 = -1;
pub const ADL_MAIN_API_OPTION_NONE: u32 = 0;
pub const ADL_DDC_OPTION_SWITCHDDC2: u32 = 1;
pub const ADL_DDC_OPTION_RESTORECOMMAND: u32 = 2;
pub const ADL_DDC_OPTION_COMBOWRITEREAD: u32 = 16;
pub const ADL_DDC_OPTION_SENDTOIMMEDIATEDEVICE: u32 = 32;
pub const ADL_DL_I2C_ACTIONREAD: u32 = 1;
pub const ADL_DL_I2C_ACTIONWRITE: u32 = 2;
pub const ADL_DL_I2C_ACTIONREAD_REPEATEDSTART: u32 = 3;
pub const ADL_DL_I2C_ACTIONIS_PRESENT: u32 = 4;
pub const ADL_OK_WAIT: u32 = 4;
pub const ADL_OK_RESTART: u32 = 3;
pub const ADL_OK_MODE_CHANGE: u32 = 2;
pub const ADL_OK_WARNING: u32 = 1;
pub const ADL_OK: u32 = 0;
pub const ADL_ERR: i32 = -1;
pub const ADL_ERR_NOT_INIT: i32 = -2;
pub const ADL_ERR_INVALID_PARAM: i32 = -3;
pub const ADL_ERR_INVALID_PARAM_SIZE: i32 = -4;
pub const ADL_ERR_INVALID_ADL_IDX: i32 = -5;
pub const ADL_ERR_INVALID_CONTROLLER_IDX: i32 = -6;
pub const ADL_ERR_INVALID_DISPLAY_IDX: i32 = -7;
pub const ADL_ERR_NOT_SUPPORTED: i32 = -8;
pub const ADL_ERR_NULL_POINTER: i32 = -9;
pub const ADL_ERR_DISABLED_ADAPTER: i32 = -10;
pub const ADL_ERR_INVALID_CALLBACK: i32 = -11;
pub const ADL_ERR_RESOURCE_CONFLICT: i32 = -12;
pub const ADL_ERR_SET_INCOMPLETE: i32 = -20;
pub const ADL_ERR_NO_XDISPLAY: i32 = -21;
pub const ADL_ERR_CALL_TO_INCOMPATIABLE_DRIVER: i32 = -22;
pub const ADL_ERR_NO_ADMINISTRATOR_PRIVILEGES: i32 = -23;
pub const ADL_ERR_FEATURESYNC_NOT_STARTED: i32 = -24;
pub const ADL_ERR_INVALID_POWER_STATE: i32 = -25;
pub const ADL_DT_MONITOR: u32 = 0;
pub const ADL_DT_TELEVISION: u32 = 1;
pub const ADL_DT_LCD_PANEL: u32 = 2;
pub const ADL_DT_DIGITAL_FLAT_PANEL: u32 = 3;
pub const ADL_DT_COMPONENT_VIDEO: u32 = 4;
pub const ADL_DT_PROJECTOR: u32 = 5;
pub const ADL_DOT_UNKNOWN: u32 = 0;
pub const ADL_DOT_COMPOSITE: u32 = 1;
pub const ADL_DOT_SVIDEO: u32 = 2;
pub const ADL_DOT_ANALOG: u32 = 3;
pub const ADL_DOT_DIGITAL: u32 = 4;
pub const ADL_DISPLAY_COLOR_BRIGHTNESS: u32 = 1;
pub const ADL_DISPLAY_COLOR_CONTRAST: u32 = 2;
pub const ADL_DISPLAY_COLOR_SATURATION: u32 = 4;
pub const ADL_DISPLAY_COLOR_HUE: u32 = 8;
pub const ADL_DISPLAY_COLOR_TEMPERATURE: u32 = 16;
pub const ADL_DISPLAY_COLOR_TEMPERATURE_SOURCE_EDID: u32 = 32;
pub const ADL_DISPLAY_COLOR_TEMPERATURE_SOURCE_USER: u32 = 64;
pub const ADL_DISPLAY_ADJUST_OVERSCAN: u32 = 1;
pub const ADL_DISPLAY_ADJUST_VERT_POS: u32 = 2;
pub const ADL_DISPLAY_ADJUST_HOR_POS: u32 = 4;
pub const ADL_DISPLAY_ADJUST_VERT_SIZE: u32 = 8;
pub const ADL_DISPLAY_ADJUST_HOR_SIZE: u32 = 16;
pub const ADL_DISPLAY_ADJUST_SIZEPOS: u32 = 30;
pub const ADL_DISPLAY_CUSTOMMODES: u32 = 32;
pub const ADL_DISPLAY_ADJUST_UNDERSCAN: u32 = 64;
pub const ADL_DISPLAY_CAPS_DOWNSCALE: u32 = 1;
pub const ADL_DISPLAY_CAPS_SHARPNESS: u32 = 1;
pub const ADL_DESKTOPCONFIG_UNKNOWN: u32 = 0;
pub const ADL_DESKTOPCONFIG_SINGLE: u32 = 1;
pub const ADL_DESKTOPCONFIG_CLONE: u32 = 4;
pub const ADL_DESKTOPCONFIG_BIGDESK_H: u32 = 16;
pub const ADL_DESKTOPCONFIG_BIGDESK_V: u32 = 32;
pub const ADL_DESKTOPCONFIG_BIGDESK_HR: u32 = 64;
pub const ADL_DESKTOPCONFIG_BIGDESK_VR: u32 = 128;
pub const ADL_DESKTOPCONFIG_RANDR12: u32 = 256;
pub const ADL_MAX_DISPLAY_NAME: u32 = 256;
pub const ADL_DISPLAYDDCINFOEX_FLAG_PROJECTORDEVICE: u32 = 1;
pub const ADL_DISPLAYDDCINFOEX_FLAG_EDIDEXTENSION: u32 = 2;
pub const ADL_DISPLAYDDCINFOEX_FLAG_DIGITALDEVICE: u32 = 4;
pub const ADL_DISPLAYDDCINFOEX_FLAG_HDMIAUDIODEVICE: u32 = 8;
pub const ADL_DISPLAYDDCINFOEX_FLAG_SUPPORTS_AI: u32 = 16;
pub const ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC601: u32 = 32;
pub const ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC709: u32 = 64;
pub const ADL_DISPLAY_CONTYPE_UNKNOWN: u32 = 0;
pub const ADL_DISPLAY_CONTYPE_VGA: u32 = 1;
pub const ADL_DISPLAY_CONTYPE_DVI_D: u32 = 2;
pub const ADL_DISPLAY_CONTYPE_DVI_I: u32 = 3;
pub const ADL_DISPLAY_CONTYPE_ATICVDONGLE_NTSC: u32 = 4;
pub const ADL_DISPLAY_CONTYPE_ATICVDONGLE_JPN: u32 = 5;
pub const ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_JPN: u32 = 6;
pub const ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_NTSC: u32 = 7;
pub const ADL_DISPLAY_CONTYPE_PROPRIETARY: u32 = 8;
pub const ADL_DISPLAY_CONTYPE_HDMI_TYPE_A: u32 = 10;
pub const ADL_DISPLAY_CONTYPE_HDMI_TYPE_B: u32 = 11;
pub const ADL_DISPLAY_CONTYPE_SVIDEO: u32 = 12;
pub const ADL_DISPLAY_CONTYPE_COMPOSITE: u32 = 13;
pub const ADL_DISPLAY_CONTYPE_RCA_3COMPONENT: u32 = 14;
pub const ADL_DISPLAY_CONTYPE_DISPLAYPORT: u32 = 15;
pub const ADL_DISPLAY_CONTYPE_EDP: u32 = 16;
pub const ADL_DISPLAY_CONTYPE_WIRELESSDISPLAY: u32 = 17;
pub const ADL_DISPLAY_CONTYPE_USB_TYPE_C: u32 = 18;
pub const ADL_TV_STANDARDS: u32 = 1;
pub const ADL_TV_SCART: u32 = 2;
pub const ADL_STANDARD_NTSC_M: u32 = 1;
pub const ADL_STANDARD_NTSC_JPN: u32 = 2;
pub const ADL_STANDARD_NTSC_N: u32 = 4;
pub const ADL_STANDARD_PAL_B: u32 = 8;
pub const ADL_STANDARD_PAL_COMB_N: u32 = 16;
pub const ADL_STANDARD_PAL_D: u32 = 32;
pub const ADL_STANDARD_PAL_G: u32 = 64;
pub const ADL_STANDARD_PAL_H: u32 = 128;
pub const ADL_STANDARD_PAL_I: u32 = 256;
pub const ADL_STANDARD_PAL_K: u32 = 512;
pub const ADL_STANDARD_PAL_K1: u32 = 1024;
pub const ADL_STANDARD_PAL_L: u32 = 2048;
pub const ADL_STANDARD_PAL_M: u32 = 4096;
pub const ADL_STANDARD_PAL_N: u32 = 8192;
pub const ADL_STANDARD_PAL_SECAM_D: u32 = 16384;
pub const ADL_STANDARD_PAL_SECAM_K: u32 = 32768;
pub const ADL_STANDARD_PAL_SECAM_K1: u32 = 65536;
pub const ADL_STANDARD_PAL_SECAM_L: u32 = 131072;
pub const ADL_CUSTOMIZEDMODEFLAG_MODESUPPORTED: u32 = 1;
pub const ADL_CUSTOMIZEDMODEFLAG_NOTDELETETABLE: u32 = 2;
pub const ADL_CUSTOMIZEDMODEFLAG_INSERTBYDRIVER: u32 = 4;
pub const ADL_CUSTOMIZEDMODEFLAG_INTERLACED: u32 = 8;
pub const ADL_CUSTOMIZEDMODEFLAG_BASEMODE: u32 = 16;
pub const ADL_DISPLAY_CV_DONGLE_D1: u32 = 1;
pub const ADL_DISPLAY_CV_DONGLE_D2: u32 = 2;
pub const ADL_DISPLAY_CV_DONGLE_D3: u32 = 4;
pub const ADL_DISPLAY_CV_DONGLE_D4: u32 = 8;
pub const ADL_DISPLAY_CV_DONGLE_D5: u32 = 16;
pub const ADL_DISPLAY_CV_DONGLE_480I: u32 = 1;
pub const ADL_DISPLAY_CV_DONGLE_480P: u32 = 2;
pub const ADL_DISPLAY_CV_DONGLE_540P: u32 = 4;
pub const ADL_DISPLAY_CV_DONGLE_720P: u32 = 8;
pub const ADL_DISPLAY_CV_DONGLE_1080I: u32 = 16;
pub const ADL_DISPLAY_CV_DONGLE_1080P: u32 = 32;
pub const ADL_DISPLAY_CV_DONGLE_16_9: u32 = 64;
pub const ADL_DISPLAY_CV_DONGLE_720P50: u32 = 128;
pub const ADL_DISPLAY_CV_DONGLE_1080I25: u32 = 256;
pub const ADL_DISPLAY_CV_DONGLE_576I25: u32 = 512;
pub const ADL_DISPLAY_CV_DONGLE_576P50: u32 = 1024;
pub const ADL_DISPLAY_CV_DONGLE_1080P24: u32 = 2048;
pub const ADL_DISPLAY_CV_DONGLE_1080P25: u32 = 4096;
pub const ADL_DISPLAY_CV_DONGLE_1080P30: u32 = 8192;
pub const ADL_DISPLAY_CV_DONGLE_1080P50: u32 = 16384;
pub const ADL_DISPLAY_FORMAT_FORCE_720P: u32 = 1;
pub const ADL_DISPLAY_FORMAT_FORCE_1080I: u32 = 2;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P: u32 = 4;
pub const ADL_DISPLAY_FORMAT_FORCE_720P50: u32 = 8;
pub const ADL_DISPLAY_FORMAT_FORCE_1080I25: u32 = 16;
pub const ADL_DISPLAY_FORMAT_FORCE_576I25: u32 = 32;
pub const ADL_DISPLAY_FORMAT_FORCE_576P50: u32 = 64;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P24: u32 = 128;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P25: u32 = 256;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P30: u32 = 512;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P50: u32 = 1024;
pub const ADL_DISPLAY_FORMAT_CVDONGLEOVERIDE: u32 = 1;
pub const ADL_DISPLAY_FORMAT_CVMODEUNDERSCAN: u32 = 2;
pub const ADL_DISPLAY_FORMAT_FORCECONNECT_SUPPORTED: u32 = 4;
pub const ADL_DISPLAY_FORMAT_RESTRICT_FORMAT_SELECTION: u32 = 8;
pub const ADL_DISPLAY_FORMAT_SETASPECRATIO: u32 = 16;
pub const ADL_DISPLAY_FORMAT_FORCEMODES: u32 = 32;
pub const ADL_DISPLAY_FORMAT_LCDRTCCOEFF: u32 = 64;
pub const ADL_PM_PARAM_DONT_CHANGE: u32 = 0;
pub const ADL_BUSTYPE_PCI: u32 = 0;
pub const ADL_BUSTYPE_AGP: u32 = 1;
pub const ADL_BUSTYPE_PCIE: u32 = 2;
pub const ADL_BUSTYPE_PCIE_GEN2: u32 = 3;
pub const ADL_BUSTYPE_PCIE_GEN3: u32 = 4;
pub const ADL_BUSTYPE_PCIE_GEN4: u32 = 5;
pub const ADL_STEREO_SUPPORTED: u32 = 4;
pub const ADL_STEREO_BLUE_LINE: u32 = 8;
pub const ADL_STEREO_OFF: u32 = 0;
pub const ADL_STEREO_ACTIVE: u32 = 2;
pub const ADL_STEREO_AUTO_HORIZONTAL: u32 = 1073741824;
pub const ADL_STEREO_AUTO_VERTICAL: u32 = 2147483648;
pub const ADL_STEREO_PASSIVE: u32 = 64;
pub const ADL_STEREO_PASSIVE_HORIZ: u32 = 128;
pub const ADL_STEREO_PASSIVE_VERT: u32 = 256;
pub const ADL_STEREO_AUTO_SAMSUNG: u32 = 2048;
pub const ADL_STEREO_AUTO_TSL: u32 = 4096;
pub const ADL_DEEPBITDEPTH_10BPP_SUPPORTED: u32 = 32;
pub const ADL_8BIT_GREYSCALE_SUPPORTED: u32 = 512;
pub const ADL_CUSTOM_TIMING_SUPPORTED: u32 = 1024;
pub const ADL_WORKSTATION_LOADBALANCING_SUPPORTED: u32 = 1;
pub const ADL_WORKSTATION_LOADBALANCING_AVAILABLE: u32 = 2;
pub const ADL_WORKSTATION_LOADBALANCING_DISABLED: u32 = 0;
pub const ADL_WORKSTATION_LOADBALANCING_ENABLED: u32 = 1;
pub const ADL_CONTEXT_SPEED_UNFORCED: u32 = 0;
pub const ADL_CONTEXT_SPEED_FORCEHIGH: u32 = 1;
pub const ADL_CONTEXT_SPEED_FORCELOW: u32 = 2;
pub const ADL_ADAPTER_SPEEDCAPS_SUPPORTED: u32 = 1;
pub const ADL_GLSYNC_PORT_UNKNOWN: u32 = 0;
pub const ADL_GLSYNC_PORT_BNC: u32 = 1;
pub const ADL_GLSYNC_PORT_RJ45PORT1: u32 = 2;
pub const ADL_GLSYNC_PORT_RJ45PORT2: u32 = 3;
pub const ADL_GLSYNC_CONFIGMASK_NONE: u32 = 0;
pub const ADL_GLSYNC_CONFIGMASK_SIGNALSOURCE: u32 = 1;
pub const ADL_GLSYNC_CONFIGMASK_SYNCFIELD: u32 = 2;
pub const ADL_GLSYNC_CONFIGMASK_SAMPLERATE: u32 = 4;
pub const ADL_GLSYNC_CONFIGMASK_SYNCDELAY: u32 = 8;
pub const ADL_GLSYNC_CONFIGMASK_TRIGGEREDGE: u32 = 16;
pub const ADL_GLSYNC_CONFIGMASK_SCANRATECOEFF: u32 = 32;
pub const ADL_GLSYNC_CONFIGMASK_FRAMELOCKCNTL: u32 = 64;
pub const ADL_GLSYNC_FRAMELOCKCNTL_NONE: u32 = 0;
pub const ADL_GLSYNC_FRAMELOCKCNTL_ENABLE: u32 = 1;
pub const ADL_GLSYNC_FRAMELOCKCNTL_DISABLE: u32 = 2;
pub const ADL_GLSYNC_FRAMELOCKCNTL_SWAP_COUNTER_RESET: u32 = 4;
pub const ADL_GLSYNC_FRAMELOCKCNTL_SWAP_COUNTER_ACK: u32 = 8;
pub const ADL_GLSYNC_FRAMELOCKCNTL_VERSION_KMD: u32 = 16;
pub const ADL_GLSYNC_FRAMELOCKCNTL_STATE_ENABLE: u32 = 1;
pub const ADL_GLSYNC_FRAMELOCKCNTL_STATE_KMD: u32 = 16;
pub const ADL_GLSYNC_COUNTER_SWAP: u32 = 1;
pub const ADL_GLSYNC_SIGNALSOURCE_UNDEFINED: u32 = 256;
pub const ADL_GLSYNC_SIGNALSOURCE_FREERUN: u32 = 257;
pub const ADL_GLSYNC_SIGNALSOURCE_BNCPORT: u32 = 258;
pub const ADL_GLSYNC_SIGNALSOURCE_RJ45PORT1: u32 = 259;
pub const ADL_GLSYNC_SIGNALSOURCE_RJ45PORT2: u32 = 260;
pub const ADL_GLSYNC_SIGNALTYPE_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_SIGNALTYPE_480I: u32 = 1;
pub const ADL_GLSYNC_SIGNALTYPE_576I: u32 = 2;
pub const ADL_GLSYNC_SIGNALTYPE_480P: u32 = 3;
pub const ADL_GLSYNC_SIGNALTYPE_576P: u32 = 4;
pub const ADL_GLSYNC_SIGNALTYPE_720P: u32 = 5;
pub const ADL_GLSYNC_SIGNALTYPE_1080P: u32 = 6;
pub const ADL_GLSYNC_SIGNALTYPE_1080I: u32 = 7;
pub const ADL_GLSYNC_SIGNALTYPE_SDI: u32 = 8;
pub const ADL_GLSYNC_SIGNALTYPE_TTL: u32 = 9;
pub const ADL_GLSYNC_SIGNALTYPE_ANALOG: u32 = 10;
pub const ADL_GLSYNC_SYNCFIELD_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_SYNCFIELD_BOTH: u32 = 1;
pub const ADL_GLSYNC_SYNCFIELD_1: u32 = 2;
pub const ADL_GLSYNC_TRIGGEREDGE_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_TRIGGEREDGE_RISING: u32 = 1;
pub const ADL_GLSYNC_TRIGGEREDGE_FALLING: u32 = 2;
pub const ADL_GLSYNC_TRIGGEREDGE_BOTH: u32 = 3;
pub const ADL_GLSYNC_SCANRATECOEFF_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_SCANRATECOEFF_x5: u32 = 1;
pub const ADL_GLSYNC_SCANRATECOEFF_x4: u32 = 2;
pub const ADL_GLSYNC_SCANRATECOEFF_x3: u32 = 3;
pub const ADL_GLSYNC_SCANRATECOEFF_x5_DIV_2: u32 = 4;
pub const ADL_GLSYNC_SCANRATECOEFF_x2: u32 = 5;
pub const ADL_GLSYNC_SCANRATECOEFF_x3_DIV_2: u32 = 6;
pub const ADL_GLSYNC_SCANRATECOEFF_x5_DIV_4: u32 = 7;
pub const ADL_GLSYNC_SCANRATECOEFF_x1: u32 = 8;
pub const ADL_GLSYNC_SCANRATECOEFF_x4_DIV_5: u32 = 9;
pub const ADL_GLSYNC_SCANRATECOEFF_x2_DIV_3: u32 = 10;
pub const ADL_GLSYNC_SCANRATECOEFF_x1_DIV_2: u32 = 11;
pub const ADL_GLSYNC_SCANRATECOEFF_x2_DIV_5: u32 = 12;
pub const ADL_GLSYNC_SCANRATECOEFF_x1_DIV_3: u32 = 13;
pub const ADL_GLSYNC_SCANRATECOEFF_x1_DIV_4: u32 = 14;
pub const ADL_GLSYNC_SCANRATECOEFF_x1_DIV_5: u32 = 15;
pub const ADL_GLSYNC_PORTSTATE_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_PORTSTATE_NOCABLE: u32 = 1;
pub const ADL_GLSYNC_PORTSTATE_IDLE: u32 = 2;
pub const ADL_GLSYNC_PORTSTATE_INPUT: u32 = 3;
pub const ADL_GLSYNC_PORTSTATE_OUTPUT: u32 = 4;
pub const ADL_GLSYNC_LEDTYPE_BNC: u32 = 0;
pub const ADL_GLSYNC_LEDTYPE_RJ45_LEFT: u32 = 0;
pub const ADL_GLSYNC_LEDTYPE_RJ45_RIGHT: u32 = 1;
pub const ADL_GLSYNC_LEDCOLOR_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_LEDCOLOR_NOLIGHT: u32 = 1;
pub const ADL_GLSYNC_LEDCOLOR_YELLOW: u32 = 2;
pub const ADL_GLSYNC_LEDCOLOR_RED: u32 = 3;
pub const ADL_GLSYNC_LEDCOLOR_GREEN: u32 = 4;
pub const ADL_GLSYNC_LEDCOLOR_FLASH_GREEN: u32 = 5;
pub const ADL_GLSYNC_PORTCNTL_NONE: u32 = 0;
pub const ADL_GLSYNC_PORTCNTL_OUTPUT: u32 = 1;
pub const ADL_GLSYNC_MODECNTL_NONE: u32 = 0;
pub const ADL_GLSYNC_MODECNTL_GENLOCK: u32 = 1;
pub const ADL_GLSYNC_MODECNTL_TIMINGSERVER: u32 = 2;
pub const ADL_GLSYNC_MODECNTL_STATUS_NONE: u32 = 0;
pub const ADL_GLSYNC_MODECNTL_STATUS_GENLOCK: u32 = 1;
pub const ADL_GLSYNC_MODECNTL_STATUS_SETMODE_REQUIRED: u32 = 2;
pub const ADL_GLSYNC_MODECNTL_STATUS_GENLOCK_ALLOWED: u32 = 4;
pub const ADL_MAX_GLSYNC_PORTS: u32 = 8;
pub const ADL_MAX_GLSYNC_PORT_LEDS: u32 = 8;
pub const ADL_XFIREX_STATE_NOINTERCONNECT: u32 = 1;
pub const ADL_XFIREX_STATE_DOWNGRADEPIPES: u32 = 2;
pub const ADL_XFIREX_STATE_DOWNGRADEMEM: u32 = 4;
pub const ADL_XFIREX_STATE_REVERSERECOMMENDED: u32 = 8;
pub const ADL_XFIREX_STATE_3DACTIVE: u32 = 16;
pub const ADL_XFIREX_STATE_MASTERONSLAVE: u32 = 32;
pub const ADL_XFIREX_STATE_NODISPLAYCONNECT: u32 = 64;
pub const ADL_XFIREX_STATE_NOPRIMARYVIEW: u32 = 128;
pub const ADL_XFIREX_STATE_DOWNGRADEVISMEM: u32 = 256;
pub const ADL_XFIREX_STATE_LESSTHAN8LANE_MASTER: u32 = 512;
pub const ADL_XFIREX_STATE_LESSTHAN8LANE_SLAVE: u32 = 1024;
pub const ADL_XFIREX_STATE_PEERTOPEERFAILED: u32 = 2048;
pub const ADL_XFIREX_STATE_MEMISDOWNGRADED: u32 = 65536;
pub const ADL_XFIREX_STATE_PIPESDOWNGRADED: u32 = 131072;
pub const ADL_XFIREX_STATE_XFIREXACTIVE: u32 = 262144;
pub const ADL_XFIREX_STATE_VISMEMISDOWNGRADED: u32 = 524288;
pub const ADL_XFIREX_STATE_INVALIDINTERCONNECTION: u32 = 1048576;
pub const ADL_XFIREX_STATE_NONP2PMODE: u32 = 2097152;
pub const ADL_XFIREX_STATE_DOWNGRADEMEMBANKS: u32 = 4194304;
pub const ADL_XFIREX_STATE_MEMBANKSDOWNGRADED: u32 = 8388608;
pub const ADL_XFIREX_STATE_DUALDISPLAYSALLOWED: u32 = 16777216;
pub const ADL_XFIREX_STATE_P2P_APERTURE_MAPPING: u32 = 33554432;
pub const ADL_XFIREX_STATE_P2PFLUSH_REQUIRED: u32 = 33554432;
pub const ADL_XFIREX_STATE_XSP_CONNECTED: u32 = 67108864;
pub const ADL_XFIREX_STATE_ENABLE_CF_REBOOT_REQUIRED: u32 = 134217728;
pub const ADL_XFIREX_STATE_DISABLE_CF_REBOOT_REQUIRED: u32 = 268435456;
pub const ADL_XFIREX_STATE_DRV_HANDLE_DOWNGRADE_KEY: u32 = 536870912;
pub const ADL_XFIREX_STATE_CF_RECONFIG_REQUIRED: u32 = 1073741824;
pub const ADL_XFIREX_STATE_ERRORGETTINGSTATUS: u32 = 2147483648;
pub const ADL_DISPLAY_PIXELFORMAT_UNKNOWN: u32 = 0;
pub const ADL_DISPLAY_PIXELFORMAT_RGB: u32 = 1;
pub const ADL_DISPLAY_PIXELFORMAT_YCRCB444: u32 = 2;
pub const ADL_DISPLAY_PIXELFORMAT_YCRCB422: u32 = 4;
pub const ADL_DISPLAY_PIXELFORMAT_RGB_LIMITED_RANGE: u32 = 8;
pub const ADL_DISPLAY_PIXELFORMAT_RGB_FULL_RANGE: u32 = 1;
pub const ADL_DISPLAY_PIXELFORMAT_YCRCB420: u32 = 16;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_UNKNOWN: u32 = 0;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NONI2C_JP: u32 = 1;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_CV_JPN: u32 = 2;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NA: u32 = 3;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NONI2C_NA: u32 = 4;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_VGA: u32 = 5;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_DVI_D: u32 = 6;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_DVI_I: u32 = 7;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_HDMI_TYPE_A: u32 = 8;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_HDMI_TYPE_B: u32 = 9;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_DISPLAYPORT: u32 = 10;
pub const ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED: u32 = 1;
pub const ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED: u32 = 2;
pub const ADL_DISPLAY_DISPLAYINFO_NONLOCAL: u32 = 4;
pub const ADL_DISPLAY_DISPLAYINFO_FORCIBLESUPPORTED: u32 = 8;
pub const ADL_DISPLAY_DISPLAYINFO_GENLOCKSUPPORTED: u32 = 16;
pub const ADL_DISPLAY_DISPLAYINFO_MULTIVPU_SUPPORTED: u32 = 32;
pub const ADL_DISPLAY_DISPLAYINFO_LDA_DISPLAY: u32 = 64;
pub const ADL_DISPLAY_DISPLAYINFO_MODETIMING_OVERRIDESSUPPORTED: u32 = 128;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_SINGLE: u32 = 256;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_CLONE: u32 = 512;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2VSTRETCH: u32 = 1024;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2HSTRETCH: u32 = 2048;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_EXTENDED: u32 = 4096;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCH1GPU: u32 = 65536;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCHNGPU: u32 = 131072;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED2: u32 = 262144;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED3: u32 = 524288;
pub const ADL_DISPLAY_DISPLAYINFO_SHOWTYPE_PROJECTOR: u32 = 1048576;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NOTACTIVE: u32 = 1;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_SINGLE: u32 = 2;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_CLONE: u32 = 4;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NSTRETCH1GPU: u32 = 8;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NSTRETCHNGPU: u32 = 16;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_2VSTRETCH: u32 = 32;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_2HSTRETCH: u32 = 64;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_EXTENDED: u32 = 128;
pub const ADL_ADAPTER_DISPLAYCAP_PREFERDISPLAY_SUPPORTED: u32 = 256;
pub const ADL_ADAPTER_DISPLAYCAP_BEZEL_SUPPORTED: u32 = 512;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_RESERVED: u32 = 1;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_NOTACTIVE: u32 = 2;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_SINGLE: u32 = 4;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_CLONE: u32 = 8;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_RESERVED1: u32 = 16;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_HSTRETCH: u32 = 32;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_VSTRETCH: u32 = 64;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_VLD: u32 = 128;
pub const ADL_DISPLAY_DISPLAYMAP_OPTION_GPUINFO: u32 = 1;
pub const ADL_DISPLAY_DISPLAYTARGET_PREFERRED: u32 = 1;
pub const ADL_DISPLAY_POSSIBLEMAPRESULT_VALID: u32 = 1;
pub const ADL_DISPLAY_POSSIBLEMAPRESULT_BEZELSUPPORTED: u32 = 2;
pub const ADL_DISPLAY_POSSIBLEMAPRESULT_OVERLAPSUPPORTED: u32 = 4;
pub const ADL_DISPLAY_MODE_COLOURFORMAT_565: u32 = 1;
pub const ADL_DISPLAY_MODE_COLOURFORMAT_8888: u32 = 2;
pub const ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000: u32 = 4;
pub const ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_090: u32 = 8;
pub const ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_180: u32 = 16;
pub const ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_270: u32 = 32;
pub const ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED: u32 = 64;
pub const ADL_DISPLAY_MODE_REFRESHRATE_ONLY: u32 = 128;
pub const ADL_DISPLAY_MODE_PROGRESSIVE_FLAG: u32 = 0;
pub const ADL_DISPLAY_MODE_INTERLACED_FLAG: u32 = 2;
pub const ADL_OSMODEINFOXPOS_DEFAULT: i32 = -640;
pub const ADL_OSMODEINFOYPOS_DEFAULT: u32 = 0;
pub const ADL_OSMODEINFOXRES_DEFAULT: u32 = 640;
pub const ADL_OSMODEINFOYRES_DEFAULT: u32 = 480;
pub const ADL_OSMODEINFOXRES_DEFAULT800: u32 = 800;
pub const ADL_OSMODEINFOYRES_DEFAULT600: u32 = 600;
pub const ADL_OSMODEINFOREFRESHRATE_DEFAULT: u32 = 60;
pub const ADL_OSMODEINFOCOLOURDEPTH_DEFAULT: u32 = 8;
pub const ADL_OSMODEINFOCOLOURDEPTH_DEFAULT16: u32 = 16;
pub const ADL_OSMODEINFOCOLOURDEPTH_DEFAULT24: u32 = 24;
pub const ADL_OSMODEINFOCOLOURDEPTH_DEFAULT32: u32 = 32;
pub const ADL_OSMODEINFOORIENTATION_DEFAULT: u32 = 0;
pub const ADL_OSMODEFLAG_DEFAULT: u32 = 0;
pub const ADL_I2C_MAJOR_API_REV: u32 = 1;
pub const ADL_I2C_MINOR_DEFAULT_API_REV: u32 = 0;
pub const ADL_I2C_MINOR_OEM_API_REV: u32 = 1;
pub const ADL_DL_I2C_LINE_OEM: u32 = 1;
pub const ADL_DL_I2C_LINE_OD_CONTROL: u32 = 2;
pub const ADL_DL_I2C_LINE_OEM2: u32 = 3;
pub const ADL_DL_I2C_LINE_OEM3: u32 = 4;
pub const ADL_DL_I2C_LINE_OEM4: u32 = 5;
pub const ADL_DL_I2C_LINE_OEM5: u32 = 6;
pub const ADL_DL_I2C_LINE_OEM6: u32 = 7;
pub const ADL_DL_I2C_LINE_GPIO: u32 = 8;
pub const ADL_DL_I2C_MAXDATASIZE: u32 = 24;
pub const ADL_DL_I2C_MAXWRITEDATASIZE: u32 = 12;
pub const ADL_DL_I2C_MAXADDRESSLENGTH: u32 = 6;
pub const ADL_DL_I2C_MAXOFFSETLENGTH: u32 = 4;
pub const ADL_DL_I2C_SPEED_50K: u32 = 50;
pub const ADL_DL_I2C_SPEED_100K: u32 = 100;
pub const ADL_DL_I2C_SPEED_1M: u32 = 1000;
pub const ADL_DL_I2C_SPEED_2M: u32 = 2300;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_UNKNOWN: u32 = 0;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_EXPANSIONMODE: u32 = 1;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_USEUNDERSCANSCALING: u32 = 2;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_ITCFLAGENABLE: u32 = 9;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_DOWNSCALE: u32 = 11;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_INTEGER_SCALING: u32 = 12;
pub const ADL_DL_DISPLAYCONTENT_TYPE_GRAPHICS: u32 = 1;
pub const ADL_DL_DISPLAYCONTENT_TYPE_PHOTO: u32 = 2;
pub const ADL_DL_DISPLAYCONTENT_TYPE_CINEMA: u32 = 4;
pub const ADL_DL_DISPLAYCONTENT_TYPE_GAME: u32 = 8;
pub const ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_CENTER: u32 = 0;
pub const ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_FULLSCREEN: u32 = 1;
pub const ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_ASPECTRATIO: u32 = 2;
pub const ADL_DL_DISPLAY_DITHER_DISABLED: u32 = 0;
pub const ADL_DL_DISPLAY_DITHER_DRIVER_DEFAULT: u32 = 1;
pub const ADL_DL_DISPLAY_DITHER_FM6: u32 = 2;
pub const ADL_DL_DISPLAY_DITHER_FM8: u32 = 3;
pub const ADL_DL_DISPLAY_DITHER_FM10: u32 = 4;
pub const ADL_DL_DISPLAY_DITHER_DITH6: u32 = 5;
pub const ADL_DL_DISPLAY_DITHER_DITH8: u32 = 6;
pub const ADL_DL_DISPLAY_DITHER_DITH10: u32 = 7;
pub const ADL_DL_DISPLAY_DITHER_DITH6_NO_FRAME_RAND: u32 = 8;
pub const ADL_DL_DISPLAY_DITHER_DITH8_NO_FRAME_RAND: u32 = 9;
pub const ADL_DL_DISPLAY_DITHER_DITH10_NO_FRAME_RAND: u32 = 10;
pub const ADL_DL_DISPLAY_DITHER_TRUN6: u32 = 11;
pub const ADL_DL_DISPLAY_DITHER_TRUN8: u32 = 12;
pub const ADL_DL_DISPLAY_DITHER_TRUN10: u32 = 13;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_DITH8: u32 = 14;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_DITH6: u32 = 15;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_FM8: u32 = 16;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_FM6: u32 = 17;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_DITH8_FM6: u32 = 18;
pub const ADL_DL_DISPLAY_DITHER_DITH10_FM8: u32 = 19;
pub const ADL_DL_DISPLAY_DITHER_DITH10_FM6: u32 = 20;
pub const ADL_DL_DISPLAY_DITHER_TRUN8_DITH6: u32 = 21;
pub const ADL_DL_DISPLAY_DITHER_TRUN8_FM6: u32 = 22;
pub const ADL_DL_DISPLAY_DITHER_DITH8_FM6: u32 = 23;
pub const ADL_DL_DISPLAY_DITHER_LAST: u32 = 23;
pub const ADL_MAX_EDIDDATA_SIZE: u32 = 256;
pub const ADL_MAX_OVERRIDEEDID_SIZE: u32 = 512;
pub const ADL_MAX_EDID_EXTENSION_BLOCKS: u32 = 3;
pub const ADL_DL_CONTROLLER_OVERLAY_ALPHA: u32 = 0;
pub const ADL_DL_CONTROLLER_OVERLAY_ALPHAPERPIX: u32 = 1;
pub const ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_RESET: u32 = 0;
pub const ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_SET: u32 = 1;
pub const ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_SCAN: u32 = 2;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__AVI: u32 = 1;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__GAMUT: u32 = 2;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__VENDORINFO: u32 = 4;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__HDR: u32 = 8;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__SPD: u32 = 16;
pub const ADL_GAMUT_MATRIX_SD: u32 = 1;
pub const ADL_GAMUT_MATRIX_HD: u32 = 2;
pub const ADL_DL_CLOCKINFO_FLAG_FULLSCREEN3DONLY: u32 = 1;
pub const ADL_DL_CLOCKINFO_FLAG_ALWAYSFULLSCREEN3D: u32 = 2;
pub const ADL_DL_CLOCKINFO_FLAG_VPURECOVERYREDUCED: u32 = 4;
pub const ADL_DL_CLOCKINFO_FLAG_THERMALPROTECTION: u32 = 8;
pub const ADL_DL_POWERXPRESS_GPU_INTEGRATED: u32 = 1;
pub const ADL_DL_POWERXPRESS_GPU_DISCRETE: u32 = 2;
pub const ADL_DL_POWERXPRESS_SWITCH_RESULT_STARTED: u32 = 1;
pub const ADL_DL_POWERXPRESS_SWITCH_RESULT_DECLINED: u32 = 2;
pub const ADL_DL_POWERXPRESS_SWITCH_RESULT_ALREADY: u32 = 3;
pub const ADL_DL_POWERXPRESS_SWITCH_RESULT_DEFERRED: u32 = 5;
pub const ADL_DL_POWERXPRESS_VERSION_MAJOR: u32 = 2;
pub const ADL_DL_POWERXPRESS_VERSION_MINOR: u32 = 0;
pub const ADL_DL_POWERXPRESS_VERSION: u32 = 131072;
pub const ADL_DL_THERMAL_DOMAIN_OTHER: u32 = 0;
pub const ADL_DL_THERMAL_DOMAIN_GPU: u32 = 1;
pub const ADL_DL_THERMAL_FLAG_INTERRUPT: u32 = 1;
pub const ADL_DL_THERMAL_FLAG_FANCONTROL: u32 = 2;
pub const ADL_DL_FANCTRL_SUPPORTS_PERCENT_READ: u32 = 1;
pub const ADL_DL_FANCTRL_SUPPORTS_PERCENT_WRITE: u32 = 2;
pub const ADL_DL_FANCTRL_SUPPORTS_RPM_READ: u32 = 4;
pub const ADL_DL_FANCTRL_SUPPORTS_RPM_WRITE: u32 = 8;
pub const ADL_DL_FANCTRL_SPEED_TYPE_PERCENT: u32 = 1;
pub const ADL_DL_FANCTRL_SPEED_TYPE_RPM: u32 = 2;
pub const ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED: u32 = 1;
pub const ADL_DL_MAX_MVPU_ADAPTERS: u32 = 4;
pub const ADL_DL_MAX_REGISTRY_PATH: u32 = 256;
pub const ADL_DL_MVPU_STATUS_OFF: u32 = 0;
pub const ADL_DL_MVPU_STATUS_ON: u32 = 1;
pub const ADL_ASIC_UNDEFINED: u32 = 0;
pub const ADL_ASIC_DISCRETE: u32 = 1;
pub const ADL_ASIC_INTEGRATED: u32 = 2;
pub const ADL_ASIC_WORKSTATION: u32 = 4;
pub const ADL_ASIC_FIREMV: u32 = 8;
pub const ADL_ASIC_XGP: u32 = 16;
pub const ADL_ASIC_FUSION: u32 = 32;
pub const ADL_ASIC_FIRESTREAM: u32 = 64;
pub const ADL_ASIC_EMBEDDED: u32 = 128;
pub const ADL_ASIC_FIREGL: u32 = 4;
pub const ADL_DL_TIMINGFLAG_DOUBLE_SCAN: u32 = 1;
pub const ADL_DL_TIMINGFLAG_INTERLACED: u32 = 2;
pub const ADL_DL_TIMINGFLAG_H_SYNC_POLARITY: u32 = 4;
pub const ADL_DL_TIMINGFLAG_V_SYNC_POLARITY: u32 = 8;
pub const ADL_DL_MODETIMING_STANDARD_CVT: u32 = 1;
pub const ADL_DL_MODETIMING_STANDARD_GTF: u32 = 2;
pub const ADL_DL_MODETIMING_STANDARD_DMT: u32 = 4;
pub const ADL_DL_MODETIMING_STANDARD_CUSTOM: u32 = 8;
pub const ADL_DL_MODETIMING_STANDARD_DRIVER_DEFAULT: u32 = 16;
pub const ADL_DL_MODETIMING_STANDARD_CVT_RB: u32 = 32;
pub const ADL_XSERVERINFO_XINERAMAACTIVE: u32 = 1;
pub const ADL_XSERVERINFO_RANDR12SUPPORTED: u32 = 2;
pub const ADL_CONTROLLERVECTOR_0: u32 = 1;
pub const ADL_CONTROLLERVECTOR_1: u32 = 2;
pub const ADL_DISPLAY_SLSGRID_ORIENTATION_000: u32 = 1;
pub const ADL_DISPLAY_SLSGRID_ORIENTATION_090: u32 = 2;
pub const ADL_DISPLAY_SLSGRID_ORIENTATION_180: u32 = 4;
pub const ADL_DISPLAY_SLSGRID_ORIENTATION_270: u32 = 8;
pub const ADL_DISPLAY_SLSGRID_CAP_OPTION_RELATIVETO_LANDSCAPE: u32 = 1;
pub const ADL_DISPLAY_SLSGRID_CAP_OPTION_RELATIVETO_CURRENTANGLE: u32 = 2;
pub const ADL_DISPLAY_SLSGRID_PORTAIT_MODE: u32 = 4;
pub const ADL_DISPLAY_SLSGRID_KEEPTARGETROTATION: u32 = 128;
pub const ADL_DISPLAY_SLSGRID_SAMEMODESLS_SUPPORT: u32 = 16;
pub const ADL_DISPLAY_SLSGRID_MIXMODESLS_SUPPORT: u32 = 32;
pub const ADL_DISPLAY_SLSGRID_DISPLAYROTATION_SUPPORT: u32 = 64;
pub const ADL_DISPLAY_SLSGRID_DESKTOPROTATION_SUPPORT: u32 = 128;
pub const ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_FIT: u32 = 256;
pub const ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_FILL: u32 = 512;
pub const ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_EXPAND: u32 = 1024;
pub const ADL_DISPLAY_SLSMAP_IS_SLS: u32 = 4096;
pub const ADL_DISPLAY_SLSMAP_IS_SLSBUILDER: u32 = 8192;
pub const ADL_DISPLAY_SLSMAP_IS_CLONEVT: u32 = 16384;
pub const ADL_DISPLAY_SLSMAPCONFIG_GET_OPTION_RELATIVETO_LANDSCAPE: u32 = 1;
pub const ADL_DISPLAY_SLSMAPCONFIG_GET_OPTION_RELATIVETO_CURRENTANGLE: u32 = 2;
pub const ADL_DISPLAY_SLSMAPCONFIG_CREATE_OPTION_RELATIVETO_LANDSCAPE: u32 = 1;
pub const ADL_DISPLAY_SLSMAPCONFIG_CREATE_OPTION_RELATIVETO_CURRENTANGLE: u32 = 2;
pub const ADL_DISPLAY_SLSMAPCONFIG_REARRANGE_OPTION_RELATIVETO_LANDSCAPE: u32 = 1;
pub const ADL_DISPLAY_SLSMAPCONFIG_REARRANGE_OPTION_RELATIVETO_CURRENTANGLE: u32 = 2;
pub const ADL_SLS_SAMEMODESLS_SUPPORT: u32 = 1;
pub const ADL_SLS_MIXMODESLS_SUPPORT: u32 = 2;
pub const ADL_SLS_DISPLAYROTATIONSLS_SUPPORT: u32 = 4;
pub const ADL_SLS_DESKTOPROTATIONSLS_SUPPORT: u32 = 8;
pub const ADL_SLS_TARGETS_INVALID: u32 = 1;
pub const ADL_SLS_MODES_INVALID: u32 = 2;
pub const ADL_SLS_ROTATIONS_INVALID: u32 = 4;
pub const ADL_SLS_POSITIONS_INVALID: u32 = 8;
pub const ADL_SLS_LAYOUTMODE_INVALID: u32 = 16;
pub const ADL_DISPLAY_SLSDISPLAYOFFSET_VALID: u32 = 2;
pub const ADL_DISPLAY_SLSGRID_RELATIVETO_LANDSCAPE: u32 = 16;
pub const ADL_DISPLAY_SLSGRID_RELATIVETO_CURRENTANGLE: u32 = 32;
pub const ADL_DISPLAY_SLSMAP_BEZELMODE: u32 = 16;
pub const ADL_DISPLAY_SLSMAP_DISPLAYARRANGED: u32 = 2;
pub const ADL_DISPLAY_SLSMAP_CURRENTCONFIG: u32 = 4;
pub const ADL_DISPLAY_SLSMAPINDEXLIST_OPTION_ACTIVE: u32 = 1;
pub const ADL_DISPLAY_BEZELOFFSET_STEPBYSTEPSET: u32 = 4;
pub const ADL_DISPLAY_BEZELOFFSET_COMMIT: u32 = 8;
pub const ADL_PX_CONFIGCAPS_SPLASHSCREEN_SUPPORT: u32 = 1;
pub const ADL_PX_CONFIGCAPS_CF_SUPPORT: u32 = 2;
pub const ADL_PX_CONFIGCAPS_MUXLESS: u32 = 4;
pub const ADL_PX_CONFIGCAPS_PROFILE_COMPLIANT: u32 = 8;
pub const ADL_PX_CONFIGCAPS_NON_AMD_DRIVEN_DISPLAYS: u32 = 16;
pub const ADL_PX_CONFIGCAPS_FIXED_SUPPORT: u32 = 32;
pub const ADL_PX_CONFIGCAPS_DYNAMIC_SUPPORT: u32 = 64;
pub const ADL_PX_CONFIGCAPS_HIDE_AUTO_SWITCH: u32 = 128;
pub const ADL_PX_SCHEMEMASK_FIXED: u32 = 1;
pub const ADL_PX_SCHEMEMASK_DYNAMIC: u32 = 2;
pub const ADL_APP_PROFILE_FILENAME_LENGTH: u32 = 256;
pub const ADL_APP_PROFILE_TIMESTAMP_LENGTH: u32 = 32;
pub const ADL_APP_PROFILE_VERSION_LENGTH: u32 = 32;
pub const ADL_APP_PROFILE_PROPERTY_LENGTH: u32 = 64;
pub const ADL_MAX_RAD_LINK_COUNT: u32 = 15;
pub const ADL_GAMUT_REFERENCE_SOURCE: u32 = 1;
pub const ADL_GAMUT_GAMUT_VIDEO_CONTENT: u32 = 2;
pub const ADL_CUSTOM_WHITE_POINT: u32 = 1;
pub const ADL_CUSTOM_GAMUT: u32 = 2;
pub const ADL_GAMUT_REMAP_ONLY: u32 = 4;
pub const ADL_GAMUT_SPACE_CCIR_709: u32 = 1;
pub const ADL_GAMUT_SPACE_CCIR_601: u32 = 2;
pub const ADL_GAMUT_SPACE_ADOBE_RGB: u32 = 4;
pub const ADL_GAMUT_SPACE_CIE_RGB: u32 = 8;
pub const ADL_GAMUT_SPACE_CUSTOM: u32 = 16;
pub const ADL_GAMUT_SPACE_CCIR_2020: u32 = 32;
pub const ADL_GAMUT_SPACE_APPCTRL: u32 = 64;
pub const ADL_WHITE_POINT_5000K: u32 = 1;
pub const ADL_WHITE_POINT_6500K: u32 = 2;
pub const ADL_WHITE_POINT_7500K: u32 = 4;
pub const ADL_WHITE_POINT_9300K: u32 = 8;
pub const ADL_WHITE_POINT_CUSTOM: u32 = 16;
pub const ADL_GAMUT_WHITEPOINT_DIVIDER: u32 = 10000;
pub const ADL_REGAMMA_COEFFICIENT_A0_DIVIDER: u32 = 10000000;
pub const ADL_REGAMMA_COEFFICIENT_A1A2A3_DIVIDER: u32 = 1000;
pub const ADL_EDID_REGAMMA_COEFFICIENTS: u32 = 1;
pub const ADL_USE_GAMMA_RAMP: u32 = 16;
pub const ADL_APPLY_DEGAMMA: u32 = 32;
pub const ADL_EDID_REGAMMA_PREDEFINED_SRGB: u32 = 2;
pub const ADL_EDID_REGAMMA_PREDEFINED_PQ: u32 = 4;
pub const ADL_EDID_REGAMMA_PREDEFINED_PQ_2084_INTERIM: u32 = 8;
pub const ADL_EDID_REGAMMA_PREDEFINED_36: u32 = 64;
pub const ADL_EDID_REGAMMA_PREDEFINED_BT709: u32 = 128;
pub const ADL_EDID_REGAMMA_PREDEFINED_APPCTRL: u32 = 256;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB656: u32 = 1;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB666: u32 = 2;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888: u32 = 4;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB101010: u32 = 8;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB161616: u32 = 16;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED1: u32 = 32;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED2: u32 = 64;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED3: u32 = 128;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_XRGB_BIAS101010: u32 = 256;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_8BPCC: u32 = 512;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_10BPCC: u32 = 1024;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_12BPCC: u32 = 2048;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_8BPCC: u32 = 4096;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_10BPCC: u32 = 8192;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_12BPCC: u32 = 16384;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_8BPCC: u32 = 32768;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_10BPCC: u32 = 65536;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_12BPCC: u32 = 131072;
pub const ADL_TF_sRGB: u32 = 1;
pub const ADL_TF_BT709: u32 = 2;
pub const ADL_TF_PQ2084: u32 = 4;
pub const ADL_TF_PQ2084_INTERIM: u32 = 8;
pub const ADL_TF_LINEAR_0_1: u32 = 16;
pub const ADL_TF_LINEAR_0_125: u32 = 32;
pub const ADL_TF_DOLBYVISION: u32 = 64;
pub const ADL_TF_GAMMA_22: u32 = 128;
pub const ADL_CS_sRGB: u32 = 1;
pub const ADL_CS_BT601: u32 = 2;
pub const ADL_CS_BT709: u32 = 4;
pub const ADL_CS_BT2020: u32 = 8;
pub const ADL_CS_ADOBE: u32 = 16;
pub const ADL_CS_P3: u32 = 32;
pub const ADL_CS_scRGB_MS_REF: u32 = 64;
pub const ADL_CS_DISPLAY_NATIVE: u32 = 128;
pub const ADL_CS_APP_CONTROL: u32 = 256;
pub const ADL_CS_DOLBYVISION: u32 = 512;
pub const ADL_HDR_CEA861_3: u32 = 1;
pub const ADL_HDR_DOLBYVISION: u32 = 2;
pub const ADL_HDR_FREESYNC_HDR: u32 = 4;
pub const ADL_HDR_FREESYNC_BACKLIGHT_SUPPORT: u32 = 1;
pub const ADL_HDR_FREESYNC_LOCAL_DIMMING: u32 = 2;
pub const ADL_SCA_LOCAL_DIMMING_DISABLE: u32 = 1;
pub const ADL_DEEPBITDEPTH_FORCEOFF: u32 = 0;
pub const ADL_DEEPBITDEPTH_10BPP_AUTO: u32 = 1;
pub const ADL_DEEPBITDEPTH_10BPP_FORCEON: u32 = 2;
pub const ADL_ADAPTER_CONFIGMEMORY_DBD: u32 = 1;
pub const ADL_ADAPTER_CONFIGMEMORY_ROTATE: u32 = 2;
pub const ADL_ADAPTER_CONFIGMEMORY_STEREO_PASSIVE: u32 = 4;
pub const ADL_ADAPTER_CONFIGMEMORY_STEREO_ACTIVE: u32 = 8;
pub const ADL_ADAPTER_CONFIGMEMORY_ENHANCEDVSYNC: u32 = 16;
pub const ADL_ADAPTER_CONFIGMEMORY_TEARFREEVSYNC: u32 = 16;
pub const ADL_MEMORYREQTYPE_VISIBLE: u32 = 1;
pub const ADL_MEMORYREQTYPE_INVISIBLE: u32 = 2;
pub const ADL_MEMORYREQTYPE_GPURESERVEDVISIBLE: u32 = 4;
pub const ADL_ADAPTER_TEAR_FREE_ON: u32 = 1;
pub const ADL_ADAPTER_TEAR_FREE_NOTENOUGHMEM: i32 = -1;
pub const ADL_ADAPTER_TEAR_FREE_OFF_ERR_QUADBUFFERSTEREO: i32 = -2;
pub const ADL_ADAPTER_TEAR_FREE_OFF_ERR_MGPUSLD: i32 = -3;
pub const ADL_ADAPTER_TEAR_FREE_OFF: u32 = 0;
pub const ADL_CROSSDISPLAY_PLATFORM: u32 = 1;
pub const ADL_CROSSDISPLAY_PLATFORM_LASSO: u32 = 2;
pub const ADL_CROSSDISPLAY_PLATFORM_DOCKSTATION: u32 = 4;
pub const ADL_CROSSDISPLAY_OPTION_NONE: u32 = 0;
pub const ADL_CROSSDISPLAY_OPTION_FORCESWITCH: u32 = 1;
pub const ADL_ADAPTERCONFIGSTATE_HEADLESS: u32 = 4;
pub const ADL_ADAPTERCONFIGSTATE_REQUISITE_RENDER: u32 = 1;
pub const ADL_ADAPTERCONFIGSTATE_ANCILLARY_RENDER: u32 = 2;
pub const ADL_ADAPTERCONFIGSTATE_SCATTERGATHER: u32 = 16;
pub const ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_POSITION: u32 = 1;
pub const ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_PANLOCK: u32 = 2;
pub const ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_SIZE: u32 = 8;
pub const ADL_MAX_AUDIO_SAMPLE_RATE_COUNT: u32 = 16;
pub const ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION: u32 = 1;
pub const ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION: u32 = 2;
pub const ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR: u32 = 4;
pub const ADL_OD6_CAPABILITY_POWER_CONTROL: u32 = 8;
pub const ADL_OD6_CAPABILITY_VOLTAGE_CONTROL: u32 = 16;
pub const ADL_OD6_CAPABILITY_PERCENT_ADJUSTMENT: u32 = 32;
pub const ADL_OD6_CAPABILITY_THERMAL_LIMIT_UNLOCK: u32 = 64;
pub const ADL_OD6_CAPABILITY_FANSPEED_IN_RPM: u32 = 128;
pub const ADL_OD6_SUPPORTEDSTATE_PERFORMANCE: u32 = 1;
pub const ADL_OD6_SUPPORTEDSTATE_POWER_SAVING: u32 = 2;
pub const ADL_OD6_GETSTATEINFO_DEFAULT_PERFORMANCE: u32 = 1;
pub const ADL_OD6_GETSTATEINFO_DEFAULT_POWER_SAVING: u32 = 2;
pub const ADL_OD6_GETSTATEINFO_CURRENT: u32 = 3;
pub const ADL_OD6_GETSTATEINFO_CUSTOM_PERFORMANCE: u32 = 4;
pub const ADL_OD6_GETSTATEINFO_CUSTOM_POWER_SAVING: u32 = 5;
pub const ADL_OD6_STATE_PERFORMANCE: u32 = 1;
pub const ADL_OD6_SETSTATE_PERFORMANCE: u32 = 1;
pub const ADL_OD6_SETSTATE_POWER_SAVING: u32 = 2;
pub const ADL_OD6_TCCAPS_THERMAL_CONTROLLER: u32 = 1;
pub const ADL_OD6_TCCAPS_FANSPEED_CONTROL: u32 = 2;
pub const ADL_OD6_TCCAPS_FANSPEED_PERCENT_READ: u32 = 256;
pub const ADL_OD6_TCCAPS_FANSPEED_PERCENT_WRITE: u32 = 512;
pub const ADL_OD6_TCCAPS_FANSPEED_RPM_READ: u32 = 1024;
pub const ADL_OD6_TCCAPS_FANSPEED_RPM_WRITE: u32 = 2048;
pub const ADL_OD6_FANSPEED_TYPE_PERCENT: u32 = 1;
pub const ADL_OD6_FANSPEED_TYPE_RPM: u32 = 2;
pub const ADL_OD6_FANSPEED_USER_DEFINED: u32 = 256;
pub const ADL_ODN_EVENTCOUNTER_THERMAL: u32 = 0;
pub const ADL_ODN_EVENTCOUNTER_VPURECOVERY: u32 = 1;
pub const ADL_PMLOG_MAX_SENSORS: u32 = 256;
pub const ADL_BLAYOUT_VALID_NUMBER_OF_SLOTS: u32 = 1;
pub const ADL_BLAYOUT_VALID_SLOT_SIZES: u32 = 2;
pub const ADL_BLAYOUT_VALID_CONNECTOR_OFFSETS: u32 = 4;
pub const ADL_BLAYOUT_VALID_CONNECTOR_LENGTHS: u32 = 8;
pub const ADL_ADAPTER_MAX_SLOTS: u32 = 4;
pub const ADL_ADAPTER_MAX_CONNECTORS: u32 = 10;
pub const ADL_MAX_CONNECTION_TYPES: u32 = 32;
pub const ADL_MAX_RELATIVE_ADDRESS_LINK_COUNT: u32 = 15;
pub const ADL_MAX_DISPLAY_EDID_DATA_SIZE: u32 = 1024;
pub const ADL_MAX_ERROR_RECORDS_COUNT: u32 = 256;
pub const ADL_MAX_POWER_POLICY: u32 = 6;
pub const ADL_CONNECTION_TYPE_VGA: u32 = 0;
pub const ADL_CONNECTION_TYPE_DVI: u32 = 1;
pub const ADL_CONNECTION_TYPE_DVI_SL: u32 = 2;
pub const ADL_CONNECTION_TYPE_HDMI: u32 = 3;
pub const ADL_CONNECTION_TYPE_DISPLAY_PORT: u32 = 4;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_DVI_SL: u32 = 5;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_DVI_DL: u32 = 6;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_HDMI: u32 = 7;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_VGA: u32 = 8;
pub const ADL_CONNECTION_TYPE_PASSIVE_DONGLE_DP_HDMI: u32 = 9;
pub const ADL_CONNECTION_TYPE_PASSIVE_DONGLE_DP_DVI: u32 = 10;
pub const ADL_CONNECTION_TYPE_MST: u32 = 11;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE: u32 = 12;
pub const ADL_CONNECTION_TYPE_VIRTUAL: u32 = 13;
pub const ADL_CONNECTION_PROPERTY_BITRATE: u32 = 1;
pub const ADL_CONNECTION_PROPERTY_NUMBER_OF_LANES: u32 = 2;
pub const ADL_CONNECTION_PROPERTY_3DCAPS: u32 = 4;
pub const ADL_CONNECTION_PROPERTY_OUTPUT_BANDWIDTH: u32 = 8;
pub const ADL_CONNECTION_PROPERTY_COLORDEPTH: u32 = 16;
pub const ADL_LANECOUNT_UNKNOWN: u32 = 0;
pub const ADL_LANECOUNT_ONE: u32 = 1;
pub const ADL_LANECOUNT_TWO: u32 = 2;
pub const ADL_LANECOUNT_FOUR: u32 = 4;
pub const ADL_LANECOUNT_EIGHT: u32 = 8;
pub const ADL_LANECOUNT_DEF: u32 = 4;
pub const ADL_LINK_BITRATE_UNKNOWN: u32 = 0;
pub const ADL_LINK_BITRATE_1_62_GHZ: u32 = 6;
pub const ADL_LINK_BITRATE_2_7_GHZ: u32 = 10;
pub const ADL_LINK_BITRATE_5_4_GHZ: u32 = 20;
pub const ADL_LINK_BITRATE_8_1_GHZ: u32 = 30;
pub const ADL_LINK_BITRATE_DEF: u32 = 10;
pub const ADL_CONNPROP_S3D_ALTERNATE_TO_FRAME_PACK: u32 = 1;
pub const ADL_COLORDEPTH_UNKNOWN: u32 = 0;
pub const ADL_COLORDEPTH_666: u32 = 1;
pub const ADL_COLORDEPTH_888: u32 = 2;
pub const ADL_COLORDEPTH_101010: u32 = 3;
pub const ADL_COLORDEPTH_121212: u32 = 4;
pub const ADL_COLORDEPTH_141414: u32 = 5;
pub const ADL_COLORDEPTH_161616: u32 = 6;
pub const ADL_COLOR_DEPTH_DEF: u32 = 2;
pub const ADL_EMUL_STATUS_REAL_DEVICE_CONNECTED: u32 = 1;
pub const ADL_EMUL_STATUS_EMULATED_DEVICE_PRESENT: u32 = 2;
pub const ADL_EMUL_STATUS_EMULATED_DEVICE_USED: u32 = 4;
pub const ADL_EMUL_STATUS_LAST_ACTIVE_DEVICE_USED: u32 = 8;
pub const ADL_EMUL_MODE_OFF: u32 = 0;
pub const ADL_EMUL_MODE_ON_CONNECTED: u32 = 1;
pub const ADL_EMUL_MODE_ON_DISCONNECTED: u32 = 2;
pub const ADL_EMUL_MODE_ALWAYS: u32 = 3;
pub const ADL_QUERY_REAL_DATA: u32 = 0;
pub const ADL_QUERY_EMULATED_DATA: u32 = 1;
pub const ADL_QUERY_CURRENT_DATA: u32 = 2;
pub const ADL_EDID_PERSISTANCE_DISABLED: u32 = 0;
pub const ADL_EDID_PERSISTANCE_ENABLED: u32 = 1;
pub const ADL_CONNECTOR_TYPE_UNKNOWN: u32 = 0;
pub const ADL_CONNECTOR_TYPE_VGA: u32 = 1;
pub const ADL_CONNECTOR_TYPE_DVI_D: u32 = 2;
pub const ADL_CONNECTOR_TYPE_DVI_I: u32 = 3;
pub const ADL_CONNECTOR_TYPE_ATICVDONGLE_NA: u32 = 4;
pub const ADL_CONNECTOR_TYPE_ATICVDONGLE_JP: u32 = 5;
pub const ADL_CONNECTOR_TYPE_ATICVDONGLE_NONI2C: u32 = 6;
pub const ADL_CONNECTOR_TYPE_ATICVDONGLE_NONI2C_D: u32 = 7;
pub const ADL_CONNECTOR_TYPE_HDMI_TYPE_A: u32 = 8;
pub const ADL_CONNECTOR_TYPE_HDMI_TYPE_B: u32 = 9;
pub const ADL_CONNECTOR_TYPE_DISPLAYPORT: u32 = 10;
pub const ADL_CONNECTOR_TYPE_EDP: u32 = 11;
pub const ADL_CONNECTOR_TYPE_MINI_DISPLAYPORT: u32 = 12;
pub const ADL_CONNECTOR_TYPE_VIRTUAL: u32 = 13;
pub const ADL_CONNECTOR_TYPE_USB_TYPE_C: u32 = 14;
pub const ADL_FREESYNC_USECASE_STATIC: u32 = 1;
pub const ADL_FREESYNC_USECASE_VIDEO: u32 = 2;
pub const ADL_FREESYNC_USECASE_GAMING: u32 = 4;
pub const ADL_FREESYNC_CAP_SUPPORTED: u32 = 1;
pub const ADL_FREESYNC_CAP_GPUSUPPORTED: u32 = 2;
pub const ADL_FREESYNC_CAP_DISPLAYSUPPORTED: u32 = 4;
pub const ADL_FREESYNC_CAP_CURRENTMODESUPPORTED: u32 = 8;
pub const ADL_FREESYNC_CAP_NOCFXORCFXSUPPORTED: u32 = 16;
pub const ADL_FREESYNC_CAP_NOGENLOCKORGENLOCKSUPPORTED: u32 = 32;
pub const ADL_FREESYNC_CAP_BORDERLESSWINDOWSUPPORTED: u32 = 64;
pub const ADL_FREESYNC_LABEL_UNSUPPORTED: u32 = 0;
pub const ADL_FREESYNC_LABEL_FREESYNC: u32 = 1;
pub const ADL_FREESYNC_LABEL_ADAPTIVE_SYNC: u32 = 2;
pub const ADL_FREESYNC_LABEL_VRR: u32 = 3;
pub const ADL_FREESYNC_LABEL_FREESYNC_PREMIUM: u32 = 4;
pub const ADL_FREESYNC_LABEL_FREESYNC_PREMIUM_PRO: u32 = 5;
pub const ADL_FREESYNC_POWEROPTIMIZATION_SUPPORTED_MASK: u32 = 1;
pub const ADL_FREESYNC_POWEROPTIMIZATION_ENABLED_MASK: u32 = 2;
pub const ADL_FREESYNC_POWEROPTIMIZATION_DEFAULT_VALUE_MASK: u32 = 4;
pub const ADL_MST_COMMANDLINE_PATH_MSG: u32 = 1;
pub const ADL_MST_COMMANDLINE_BROADCAST: u32 = 2;
pub const ADL_CROSSGPUDISPLAYCLONE_AMD_WITH_NONAMD: u32 = 1;
pub const ADL_CROSSGPUDISPLAYCLONE: u32 = 2;
pub const ADL_RADEON_LED_MAX_BRIGHTNESS: u32 = 2;
pub const ADL_RADEON_LED_MAX_SPEED: u32 = 4;
pub const ADL_RADEON_LED_MAX_RGB: u32 = 255;
pub const ADL_RADEON_LED_MAX_MORSE_CODE: u32 = 260;
pub const ADL_RADEON_LED_MAX_LED_ROW_ON_GRID: u32 = 7;
pub const ADL_RADEON_LED_MAX_LED_COLUMN_ON_GRID: u32 = 24;
pub const ADL_REG_DEVICE_FUNCTION_1: u32 = 1;
pub const ADL_FEATURE_NAME_LENGTH: u32 = 16;
pub const ADL_SDK_MAJOR_VERSION: u32 = 17;
pub const ADL_SDK_MINOR_VERSION: u32 = 1;
impl ADLThreadingModel {
    #[doc = "< Default behavior. ADL will not enforce serialization of ADL API executions by multiple threads.  Multiple threads will be allowed to enter to ADL at the same time. Note that ADL library is not guaranteed to be thread-safe. Client that calls ADL_Main_Control_Create have to provide its own mechanism for ADL calls serialization."]
    pub const ADL_THREADING_UNLOCKED: ADLThreadingModel = ADLThreadingModel(0);
}
impl ADLThreadingModel {
    #[doc = "< ADL will enforce serialization of ADL API when called by multiple threads.  Only single thread will be allowed to enter ADL API at the time. This option makes ADL calls thread-safe. You shouldn't use this option if ADL calls will be executed on Linux on x-server rendering thread. It can cause the application to hung."]
    pub const ADL_THREADING_LOCKED: ADLThreadingModel = ADLThreadingModel(1);
}
#[repr(transparent)]
#[doc = "\n \\defgroup thread_model\n Used with \\ref ADL_Main_ControlX2_Create and \\ref ADL2_Main_ControlX2_Create to specify how ADL handles API calls when executed by multiple threads concurrently.\n \\brief Declares ADL threading behavior.\n @{"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLThreadingModel(pub ::std::os::raw::c_int);
impl ADLPurposeCode {
    pub const ADL_PURPOSECODE_NORMAL: ADLPurposeCode = ADLPurposeCode(0);
}
impl ADLPurposeCode {
    pub const ADL_PURPOSECODE_HIDE_MODE_SWITCH: ADLPurposeCode = ADLPurposeCode(1);
}
impl ADLPurposeCode {
    pub const ADL_PURPOSECODE_MODE_SWITCH: ADLPurposeCode = ADLPurposeCode(2);
}
impl ADLPurposeCode {
    pub const ADL_PURPOSECODE_ATTACH_DEVICE: ADLPurposeCode = ADLPurposeCode(3);
}
impl ADLPurposeCode {
    pub const ADL_PURPOSECODE_DETACH_DEVICE: ADLPurposeCode = ADLPurposeCode(4);
}
impl ADLPurposeCode {
    pub const ADL_PURPOSECODE_SETPRIMARY_DEVICE: ADLPurposeCode = ADLPurposeCode(5);
}
impl ADLPurposeCode {
    pub const ADL_PURPOSECODE_GDI_ROTATION: ADLPurposeCode = ADLPurposeCode(6);
}
impl ADLPurposeCode {
    pub const ADL_PURPOSECODE_ATI_ROTATION: ADLPurposeCode = ADLPurposeCode(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLPurposeCode(pub ::std::os::raw::c_int);
impl ADLAngle {
    pub const ADL_ANGLE_LANDSCAPE: ADLAngle = ADLAngle(0);
}
impl ADLAngle {
    pub const ADL_ANGLE_ROTATERIGHT: ADLAngle = ADLAngle(90);
}
impl ADLAngle {
    pub const ADL_ANGLE_ROTATE180: ADLAngle = ADLAngle(180);
}
impl ADLAngle {
    pub const ADL_ANGLE_ROTATELEFT: ADLAngle = ADLAngle(270);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLAngle(pub ::std::os::raw::c_int);
impl ADLOrientationDataType {
    pub const ADL_ORIENTATIONTYPE_OSDATATYPE: ADLOrientationDataType = ADLOrientationDataType(0);
}
impl ADLOrientationDataType {
    pub const ADL_ORIENTATIONTYPE_NONOSDATATYPE: ADLOrientationDataType = ADLOrientationDataType(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLOrientationDataType(pub ::std::os::raw::c_int);
impl ADLPanningMode {
    pub const ADL_PANNINGMODE_NO_PANNING: ADLPanningMode = ADLPanningMode(0);
}
impl ADLPanningMode {
    pub const ADL_PANNINGMODE_AT_LEAST_ONE_NO_PANNING: ADLPanningMode = ADLPanningMode(1);
}
impl ADLPanningMode {
    pub const ADL_PANNINGMODE_ALLOW_PANNING: ADLPanningMode = ADLPanningMode(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLPanningMode(pub ::std::os::raw::c_int);
impl ADLLARGEDESKTOPTYPE {
    pub const ADL_LARGEDESKTOPTYPE_NORMALDESKTOP: ADLLARGEDESKTOPTYPE = ADLLARGEDESKTOPTYPE(0);
}
impl ADLLARGEDESKTOPTYPE {
    pub const ADL_LARGEDESKTOPTYPE_PSEUDOLARGEDESKTOP: ADLLARGEDESKTOPTYPE = ADLLARGEDESKTOPTYPE(1);
}
impl ADLLARGEDESKTOPTYPE {
    pub const ADL_LARGEDESKTOPTYPE_VERYLARGEDESKTOP: ADLLARGEDESKTOPTYPE = ADLLARGEDESKTOPTYPE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLLARGEDESKTOPTYPE(pub ::std::os::raw::c_int);
impl ADLPlatForm {
    pub const GRAPHICS_PLATFORM_DESKTOP: ADLPlatForm = ADLPlatForm(0);
}
impl ADLPlatForm {
    pub const GRAPHICS_PLATFORM_MOBILE: ADLPlatForm = ADLPlatForm(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLPlatForm(pub ::std::os::raw::c_int);
impl ADLGraphicCoreGeneration {
    pub const ADL_GRAPHIC_CORE_GENERATION_UNDEFINED: ADLGraphicCoreGeneration =
        ADLGraphicCoreGeneration(0);
}
impl ADLGraphicCoreGeneration {
    pub const ADL_GRAPHIC_CORE_GENERATION_PRE_GCN: ADLGraphicCoreGeneration =
        ADLGraphicCoreGeneration(1);
}
impl ADLGraphicCoreGeneration {
    pub const ADL_GRAPHIC_CORE_GENERATION_GCN: ADLGraphicCoreGeneration =
        ADLGraphicCoreGeneration(2);
}
impl ADLGraphicCoreGeneration {
    pub const ADL_GRAPHIC_CORE_GENERATION_RDNA: ADLGraphicCoreGeneration =
        ADLGraphicCoreGeneration(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLGraphicCoreGeneration(pub ::std::os::raw::c_int);
impl DceSettingsType {
    pub const DceSetting_HdmiLq: DceSettingsType = DceSettingsType(0);
}
impl DceSettingsType {
    pub const DceSetting_DpSettings: DceSettingsType = DceSettingsType(1);
}
impl DceSettingsType {
    pub const DceSetting_Protection: DceSettingsType = DceSettingsType(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct DceSettingsType(pub ::std::os::raw::c_int);
impl DpLinkRate {
    pub const DPLinkRate_Unknown: DpLinkRate = DpLinkRate(0);
}
impl DpLinkRate {
    pub const DPLinkRate_RBR: DpLinkRate = DpLinkRate(1);
}
impl DpLinkRate {
    pub const DPLinkRate_2_16Gbps: DpLinkRate = DpLinkRate(2);
}
impl DpLinkRate {
    pub const DPLinkRate_2_43Gbps: DpLinkRate = DpLinkRate(3);
}
impl DpLinkRate {
    pub const DPLinkRate_HBR: DpLinkRate = DpLinkRate(4);
}
impl DpLinkRate {
    pub const DPLinkRate_4_32Gbps: DpLinkRate = DpLinkRate(5);
}
impl DpLinkRate {
    pub const DPLinkRate_HBR2: DpLinkRate = DpLinkRate(6);
}
impl DpLinkRate {
    pub const DPLinkRate_HBR3: DpLinkRate = DpLinkRate(7);
}
impl DpLinkRate {
    pub const DPLinkRate_UHBR10: DpLinkRate = DpLinkRate(8);
}
impl DpLinkRate {
    pub const DPLinkRate_UHBR13D5: DpLinkRate = DpLinkRate(9);
}
impl DpLinkRate {
    pub const DPLinkRate_UHBR20: DpLinkRate = DpLinkRate(10);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct DpLinkRate(pub ::std::os::raw::c_int);
impl ADLPXScheme {
    pub const ADL_PX_SCHEME_INVALID: ADLPXScheme = ADLPXScheme(0);
}
impl ADLPXScheme {
    pub const ADL_PX_SCHEME_FIXED: ADLPXScheme = ADLPXScheme(1);
}
impl ADLPXScheme {
    pub const ADL_PX_SCHEME_DYNAMIC: ADLPXScheme = ADLPXScheme(2);
}
#[repr(transparent)]
#[doc = " PX Schemes"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLPXScheme(pub ::std::os::raw::c_int);
impl ADLProfilePropertyType {
    pub const ADL_PROFILEPROPERTY_TYPE_BINARY: ADLProfilePropertyType = ADLProfilePropertyType(0);
}
impl ADLProfilePropertyType {
    pub const ADL_PROFILEPROPERTY_TYPE_BOOLEAN: ADLProfilePropertyType = ADLProfilePropertyType(1);
}
impl ADLProfilePropertyType {
    pub const ADL_PROFILEPROPERTY_TYPE_DWORD: ADLProfilePropertyType = ADLProfilePropertyType(2);
}
impl ADLProfilePropertyType {
    pub const ADL_PROFILEPROPERTY_TYPE_QWORD: ADLProfilePropertyType = ADLProfilePropertyType(3);
}
impl ADLProfilePropertyType {
    pub const ADL_PROFILEPROPERTY_TYPE_ENUMERATED: ADLProfilePropertyType =
        ADLProfilePropertyType(4);
}
impl ADLProfilePropertyType {
    pub const ADL_PROFILEPROPERTY_TYPE_STRING: ADLProfilePropertyType = ADLProfilePropertyType(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLProfilePropertyType(pub ::std::os::raw::c_int);
impl ADL_VIRTUALDISPLAY_TYPE {
    pub const ADL_VIRTUALDISPLAY_NONE: ADL_VIRTUALDISPLAY_TYPE = ADL_VIRTUALDISPLAY_TYPE(0);
}
impl ADL_VIRTUALDISPLAY_TYPE {
    pub const ADL_VIRTUALDISPLAY_XINPUT: ADL_VIRTUALDISPLAY_TYPE = ADL_VIRTUALDISPLAY_TYPE(1);
}
impl ADL_VIRTUALDISPLAY_TYPE {
    pub const ADL_VIRTUALDISPLAY_REMOTEPLAY: ADL_VIRTUALDISPLAY_TYPE = ADL_VIRTUALDISPLAY_TYPE(2);
}
impl ADL_VIRTUALDISPLAY_TYPE {
    pub const ADL_VIRTUALDISPLAY_GENERIC: ADL_VIRTUALDISPLAY_TYPE = ADL_VIRTUALDISPLAY_TYPE(10);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_VIRTUALDISPLAY_TYPE(pub ::std::os::raw::c_int);
impl ADLMultiChannelSplitStateFlag {
    pub const ADLMultiChannelSplit_Unitialized: ADLMultiChannelSplitStateFlag =
        ADLMultiChannelSplitStateFlag(0);
}
impl ADLMultiChannelSplitStateFlag {
    pub const ADLMultiChannelSplit_Disabled: ADLMultiChannelSplitStateFlag =
        ADLMultiChannelSplitStateFlag(1);
}
impl ADLMultiChannelSplitStateFlag {
    pub const ADLMultiChannelSplit_Enabled: ADLMultiChannelSplitStateFlag =
        ADLMultiChannelSplitStateFlag(2);
}
impl ADLMultiChannelSplitStateFlag {
    pub const ADLMultiChannelSplit_SaveProfile: ADLMultiChannelSplitStateFlag =
        ADLMultiChannelSplitStateFlag(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLMultiChannelSplitStateFlag(pub ::std::os::raw::c_int);
impl ADLSampleRate {
    pub const ADLSampleRate_32KHz: ADLSampleRate = ADLSampleRate(0);
}
impl ADLSampleRate {
    pub const ADLSampleRate_44P1KHz: ADLSampleRate = ADLSampleRate(1);
}
impl ADLSampleRate {
    pub const ADLSampleRate_48KHz: ADLSampleRate = ADLSampleRate(2);
}
impl ADLSampleRate {
    pub const ADLSampleRate_88P2KHz: ADLSampleRate = ADLSampleRate(3);
}
impl ADLSampleRate {
    pub const ADLSampleRate_96KHz: ADLSampleRate = ADLSampleRate(4);
}
impl ADLSampleRate {
    pub const ADLSampleRate_176P4KHz: ADLSampleRate = ADLSampleRate(5);
}
impl ADLSampleRate {
    pub const ADLSampleRate_192KHz: ADLSampleRate = ADLSampleRate(6);
}
impl ADLSampleRate {
    pub const ADLSampleRate_384KHz: ADLSampleRate = ADLSampleRate(7);
}
impl ADLSampleRate {
    pub const ADLSampleRate_768KHz: ADLSampleRate = ADLSampleRate(8);
}
impl ADLSampleRate {
    pub const ADLSampleRate_Undefined: ADLSampleRate = ADLSampleRate(9);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLSampleRate(pub ::std::os::raw::c_int);
impl ADLODNControlType {
    pub const ODNControlType_Current: ADLODNControlType = ADLODNControlType(0);
}
impl ADLODNControlType {
    pub const ODNControlType_Default: ADLODNControlType = ADLODNControlType(1);
}
impl ADLODNControlType {
    pub const ODNControlType_Auto: ADLODNControlType = ADLODNControlType(2);
}
impl ADLODNControlType {
    pub const ODNControlType_Manual: ADLODNControlType = ADLODNControlType(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLODNControlType(pub ::std::os::raw::c_int);
impl ADLODNDPMMaskType {
    pub const ADL_ODN_DPM_CLOCK: ADLODNDPMMaskType = ADLODNDPMMaskType(1);
}
impl ADLODNDPMMaskType {
    pub const ADL_ODN_DPM_VDDC: ADLODNDPMMaskType = ADLODNDPMMaskType(2);
}
impl ADLODNDPMMaskType {
    pub const ADL_ODN_DPM_MASK: ADLODNDPMMaskType = ADLODNDPMMaskType(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLODNDPMMaskType(pub ::std::os::raw::c_int);
impl ADLODNFeatureControl {
    pub const ADL_ODN_SCLK_DPM: ADLODNFeatureControl = ADLODNFeatureControl(1);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_MCLK_DPM: ADLODNFeatureControl = ADLODNFeatureControl(2);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_SCLK_VDD: ADLODNFeatureControl = ADLODNFeatureControl(4);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_MCLK_VDD: ADLODNFeatureControl = ADLODNFeatureControl(8);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_FAN_SPEED_MIN: ADLODNFeatureControl = ADLODNFeatureControl(16);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_FAN_SPEED_TARGET: ADLODNFeatureControl = ADLODNFeatureControl(32);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_ACOUSTIC_LIMIT_SCLK: ADLODNFeatureControl = ADLODNFeatureControl(64);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_TEMPERATURE_FAN_MAX: ADLODNFeatureControl = ADLODNFeatureControl(128);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_TEMPERATURE_SYSTEM: ADLODNFeatureControl = ADLODNFeatureControl(256);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_POWER_LIMIT: ADLODNFeatureControl = ADLODNFeatureControl(512);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_SCLK_AUTO_LIMIT: ADLODNFeatureControl = ADLODNFeatureControl(1024);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_MCLK_AUTO_LIMIT: ADLODNFeatureControl = ADLODNFeatureControl(2048);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_SCLK_DPM_MASK_ENABLE: ADLODNFeatureControl = ADLODNFeatureControl(4096);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_MCLK_DPM_MASK_ENABLE: ADLODNFeatureControl = ADLODNFeatureControl(8192);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_MCLK_UNDERCLOCK_ENABLE: ADLODNFeatureControl = ADLODNFeatureControl(16384);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_SCLK_DPM_THROTTLE_NOTIFY: ADLODNFeatureControl = ADLODNFeatureControl(32768);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_POWER_UTILIZATION: ADLODNFeatureControl = ADLODNFeatureControl(65536);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_PERF_TUNING_SLIDER: ADLODNFeatureControl = ADLODNFeatureControl(131072);
}
impl ADLODNFeatureControl {
    pub const ADL_ODN_REMOVE_WATTMAN_PAGE: ADLODNFeatureControl = ADLODNFeatureControl(-2147483648);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLODNFeatureControl(pub ::std::os::raw::c_int);
impl ADLODNExtFeatureControl {
    pub const ADL_ODN_EXT_FEATURE_MEMORY_TIMING_TUNE: ADLODNExtFeatureControl =
        ADLODNExtFeatureControl(1);
}
impl ADLODNExtFeatureControl {
    pub const ADL_ODN_EXT_FEATURE_FAN_ZERO_RPM_CONTROL: ADLODNExtFeatureControl =
        ADLODNExtFeatureControl(2);
}
impl ADLODNExtFeatureControl {
    pub const ADL_ODN_EXT_FEATURE_AUTO_UV_ENGINE: ADLODNExtFeatureControl =
        ADLODNExtFeatureControl(4);
}
impl ADLODNExtFeatureControl {
    pub const ADL_ODN_EXT_FEATURE_AUTO_OC_ENGINE: ADLODNExtFeatureControl =
        ADLODNExtFeatureControl(8);
}
impl ADLODNExtFeatureControl {
    pub const ADL_ODN_EXT_FEATURE_AUTO_OC_MEMORY: ADLODNExtFeatureControl =
        ADLODNExtFeatureControl(16);
}
impl ADLODNExtFeatureControl {
    pub const ADL_ODN_EXT_FEATURE_FAN_CURVE: ADLODNExtFeatureControl = ADLODNExtFeatureControl(32);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLODNExtFeatureControl(pub ::std::os::raw::c_int);
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_AC_TIMING: ADLODNExtSettingId = ADLODNExtSettingId(0);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_ZERO_RPM_CONTROL: ADLODNExtSettingId = ADLODNExtSettingId(1);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_AUTO_UV_ENGINE: ADLODNExtSettingId = ADLODNExtSettingId(2);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_AUTO_OC_ENGINE: ADLODNExtSettingId = ADLODNExtSettingId(3);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_AUTO_OC_MEMORY: ADLODNExtSettingId = ADLODNExtSettingId(4);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_1: ADLODNExtSettingId = ADLODNExtSettingId(5);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_SPEED_1: ADLODNExtSettingId = ADLODNExtSettingId(6);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_2: ADLODNExtSettingId = ADLODNExtSettingId(7);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_SPEED_2: ADLODNExtSettingId = ADLODNExtSettingId(8);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_3: ADLODNExtSettingId = ADLODNExtSettingId(9);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_SPEED_3: ADLODNExtSettingId = ADLODNExtSettingId(10);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_4: ADLODNExtSettingId =
        ADLODNExtSettingId(11);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_SPEED_4: ADLODNExtSettingId = ADLODNExtSettingId(12);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_5: ADLODNExtSettingId =
        ADLODNExtSettingId(13);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_PARAMETER_FAN_CURVE_SPEED_5: ADLODNExtSettingId = ADLODNExtSettingId(14);
}
impl ADLODNExtSettingId {
    pub const ADL_ODN_POWERGAUGE: ADLODNExtSettingId = ADLODNExtSettingId(15);
}
impl ADLODNExtSettingId {
    pub const ODN_COUNT: ADLODNExtSettingId = ADLODNExtSettingId(16);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLODNExtSettingId(pub ::std::os::raw::c_int);
impl ADLOD8FeatureControl {
    pub const ADL_OD8_GFXCLK_LIMITS: ADLOD8FeatureControl = ADLOD8FeatureControl(1);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_GFXCLK_CURVE: ADLOD8FeatureControl = ADLOD8FeatureControl(2);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_UCLK_MAX: ADLOD8FeatureControl = ADLOD8FeatureControl(4);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_POWER_LIMIT: ADLOD8FeatureControl = ADLOD8FeatureControl(8);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_ACOUSTIC_LIMIT_SCLK: ADLOD8FeatureControl = ADLOD8FeatureControl(16);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_FAN_SPEED_MIN: ADLOD8FeatureControl = ADLOD8FeatureControl(32);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_TEMPERATURE_FAN: ADLOD8FeatureControl = ADLOD8FeatureControl(64);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_TEMPERATURE_SYSTEM: ADLOD8FeatureControl = ADLOD8FeatureControl(128);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_MEMORY_TIMING_TUNE: ADLOD8FeatureControl = ADLOD8FeatureControl(256);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_FAN_ZERO_RPM_CONTROL: ADLOD8FeatureControl = ADLOD8FeatureControl(512);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_AUTO_UV_ENGINE: ADLOD8FeatureControl = ADLOD8FeatureControl(1024);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_AUTO_OC_ENGINE: ADLOD8FeatureControl = ADLOD8FeatureControl(2048);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_AUTO_OC_MEMORY: ADLOD8FeatureControl = ADLOD8FeatureControl(4096);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_FAN_CURVE: ADLOD8FeatureControl = ADLOD8FeatureControl(8192);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_WS_AUTO_FAN_ACOUSTIC_LIMIT: ADLOD8FeatureControl =
        ADLOD8FeatureControl(16384);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_GFXCLK_QUADRATIC_CURVE: ADLOD8FeatureControl = ADLOD8FeatureControl(32768);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_OPTIMIZED_GPU_POWER_MODE: ADLOD8FeatureControl = ADLOD8FeatureControl(65536);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_ODVOLTAGE_LIMIT: ADLOD8FeatureControl = ADLOD8FeatureControl(131072);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_ADV_OC_LIMITS: ADLOD8FeatureControl = ADLOD8FeatureControl(262144);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET: ADLOD8FeatureControl =
        ADLOD8FeatureControl(524288);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_AUTO_CURVE_OPTIMIZER: ADLOD8FeatureControl = ADLOD8FeatureControl(1048576);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_GFX_VOLTAGE_LIMIT: ADLOD8FeatureControl = ADLOD8FeatureControl(2097152);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_TDC_LIMIT: ADLOD8FeatureControl = ADLOD8FeatureControl(4194304);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_FULL_CONTROL_MODE: ADLOD8FeatureControl = ADLOD8FeatureControl(8388608);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_POWER_SAVING_FEATURE_CONTROL: ADLOD8FeatureControl =
        ADLOD8FeatureControl(16777216);
}
impl ADLOD8FeatureControl {
    pub const ADL_OD8_POWER_GAUGE: ADLOD8FeatureControl = ADLOD8FeatureControl(33554432);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLOD8FeatureControl(pub ::std::os::raw::c_int);
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_FMAX: ADLOD8SettingId = ADLOD8SettingId(0);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_FMIN: ADLOD8SettingId = ADLOD8SettingId(1);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_FREQ1: ADLOD8SettingId = ADLOD8SettingId(2);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_VOLTAGE1: ADLOD8SettingId = ADLOD8SettingId(3);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_FREQ2: ADLOD8SettingId = ADLOD8SettingId(4);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_VOLTAGE2: ADLOD8SettingId = ADLOD8SettingId(5);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_FREQ3: ADLOD8SettingId = ADLOD8SettingId(6);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_VOLTAGE3: ADLOD8SettingId = ADLOD8SettingId(7);
}
impl ADLOD8SettingId {
    pub const OD8_UCLK_FMAX: ADLOD8SettingId = ADLOD8SettingId(8);
}
impl ADLOD8SettingId {
    pub const OD8_POWER_PERCENTAGE: ADLOD8SettingId = ADLOD8SettingId(9);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_MIN_SPEED: ADLOD8SettingId = ADLOD8SettingId(10);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_ACOUSTIC_LIMIT: ADLOD8SettingId = ADLOD8SettingId(11);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_TARGET_TEMP: ADLOD8SettingId = ADLOD8SettingId(12);
}
impl ADLOD8SettingId {
    pub const OD8_OPERATING_TEMP_MAX: ADLOD8SettingId = ADLOD8SettingId(13);
}
impl ADLOD8SettingId {
    pub const OD8_AC_TIMING: ADLOD8SettingId = ADLOD8SettingId(14);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_ZERORPM_CONTROL: ADLOD8SettingId = ADLOD8SettingId(15);
}
impl ADLOD8SettingId {
    pub const OD8_AUTO_UV_ENGINE_CONTROL: ADLOD8SettingId = ADLOD8SettingId(16);
}
impl ADLOD8SettingId {
    pub const OD8_AUTO_OC_ENGINE_CONTROL: ADLOD8SettingId = ADLOD8SettingId(17);
}
impl ADLOD8SettingId {
    pub const OD8_AUTO_OC_MEMORY_CONTROL: ADLOD8SettingId = ADLOD8SettingId(18);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_TEMPERATURE_1: ADLOD8SettingId = ADLOD8SettingId(19);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_SPEED_1: ADLOD8SettingId = ADLOD8SettingId(20);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_TEMPERATURE_2: ADLOD8SettingId = ADLOD8SettingId(21);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_SPEED_2: ADLOD8SettingId = ADLOD8SettingId(22);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_TEMPERATURE_3: ADLOD8SettingId = ADLOD8SettingId(23);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_SPEED_3: ADLOD8SettingId = ADLOD8SettingId(24);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_TEMPERATURE_4: ADLOD8SettingId = ADLOD8SettingId(25);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_SPEED_4: ADLOD8SettingId = ADLOD8SettingId(26);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_TEMPERATURE_5: ADLOD8SettingId = ADLOD8SettingId(27);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_CURVE_SPEED_5: ADLOD8SettingId = ADLOD8SettingId(28);
}
impl ADLOD8SettingId {
    pub const OD8_WS_FAN_AUTO_FAN_ACOUSTIC_LIMIT: ADLOD8SettingId = ADLOD8SettingId(29);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_CURVE_COEFFICIENT_A: ADLOD8SettingId = ADLOD8SettingId(30);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_CURVE_COEFFICIENT_B: ADLOD8SettingId = ADLOD8SettingId(31);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_CURVE_COEFFICIENT_C: ADLOD8SettingId = ADLOD8SettingId(32);
}
impl ADLOD8SettingId {
    pub const OD8_GFXCLK_CURVE_VFT_FMIN: ADLOD8SettingId = ADLOD8SettingId(33);
}
impl ADLOD8SettingId {
    pub const OD8_UCLK_FMIN: ADLOD8SettingId = ADLOD8SettingId(34);
}
impl ADLOD8SettingId {
    pub const OD8_FAN_ZERO_RPM_STOP_TEMPERATURE: ADLOD8SettingId = ADLOD8SettingId(35);
}
impl ADLOD8SettingId {
    pub const OD8_OPTIMZED_POWER_MODE: ADLOD8SettingId = ADLOD8SettingId(36);
}
impl ADLOD8SettingId {
    pub const OD8_OD_VOLTAGE: ADLOD8SettingId = ADLOD8SettingId(37);
}
impl ADLOD8SettingId {
    pub const OD8_ADV_OC_LIMITS_SETTING: ADLOD8SettingId = ADLOD8SettingId(38);
}
impl ADLOD8SettingId {
    pub const OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_1: ADLOD8SettingId = ADLOD8SettingId(39);
}
impl ADLOD8SettingId {
    pub const OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_2: ADLOD8SettingId = ADLOD8SettingId(40);
}
impl ADLOD8SettingId {
    pub const OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_3: ADLOD8SettingId = ADLOD8SettingId(41);
}
impl ADLOD8SettingId {
    pub const OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_4: ADLOD8SettingId = ADLOD8SettingId(42);
}
impl ADLOD8SettingId {
    pub const OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_5: ADLOD8SettingId = ADLOD8SettingId(43);
}
impl ADLOD8SettingId {
    pub const OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_6: ADLOD8SettingId = ADLOD8SettingId(44);
}
impl ADLOD8SettingId {
    pub const OD8_AUTO_CURVE_OPTIMIZER_SETTING: ADLOD8SettingId = ADLOD8SettingId(45);
}
impl ADLOD8SettingId {
    pub const OD8_GFX_VOLTAGE_LIMIT_SETTING: ADLOD8SettingId = ADLOD8SettingId(46);
}
impl ADLOD8SettingId {
    pub const OD8_TDC_PERCENTAGE: ADLOD8SettingId = ADLOD8SettingId(47);
}
impl ADLOD8SettingId {
    pub const OD8_FULL_CONTROL_MODE_SETTING: ADLOD8SettingId = ADLOD8SettingId(48);
}
impl ADLOD8SettingId {
    pub const OD8_IDLE_POWER_SAVING_FEATURE_CONTROL: ADLOD8SettingId = ADLOD8SettingId(49);
}
impl ADLOD8SettingId {
    pub const OD8_RUNTIME_POWER_SAVING_FEATURE_CONTROL: ADLOD8SettingId = ADLOD8SettingId(50);
}
impl ADLOD8SettingId {
    pub const OD8_POWER_GAUGE: ADLOD8SettingId = ADLOD8SettingId(51);
}
impl ADLOD8SettingId {
    pub const OD8_COUNT: ADLOD8SettingId = ADLOD8SettingId(52);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLOD8SettingId(pub ::std::os::raw::c_int);
impl ADLSensorType {
    pub const SENSOR_MAXTYPES: ADLSensorType = ADLSensorType(0);
}
impl ADLSensorType {
    pub const PMLOG_CLK_GFXCLK: ADLSensorType = ADLSensorType(1);
}
impl ADLSensorType {
    pub const PMLOG_CLK_MEMCLK: ADLSensorType = ADLSensorType(2);
}
impl ADLSensorType {
    pub const PMLOG_CLK_SOCCLK: ADLSensorType = ADLSensorType(3);
}
impl ADLSensorType {
    pub const PMLOG_CLK_UVDCLK1: ADLSensorType = ADLSensorType(4);
}
impl ADLSensorType {
    pub const PMLOG_CLK_UVDCLK2: ADLSensorType = ADLSensorType(5);
}
impl ADLSensorType {
    pub const PMLOG_CLK_VCECLK: ADLSensorType = ADLSensorType(6);
}
impl ADLSensorType {
    pub const PMLOG_CLK_VCNCLK: ADLSensorType = ADLSensorType(7);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_EDGE: ADLSensorType = ADLSensorType(8);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_MEM: ADLSensorType = ADLSensorType(9);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_VRVDDC: ADLSensorType = ADLSensorType(10);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_VRMVDD: ADLSensorType = ADLSensorType(11);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_LIQUID: ADLSensorType = ADLSensorType(12);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_PLX: ADLSensorType = ADLSensorType(13);
}
impl ADLSensorType {
    pub const PMLOG_FAN_RPM: ADLSensorType = ADLSensorType(14);
}
impl ADLSensorType {
    pub const PMLOG_FAN_PERCENTAGE: ADLSensorType = ADLSensorType(15);
}
impl ADLSensorType {
    pub const PMLOG_SOC_VOLTAGE: ADLSensorType = ADLSensorType(16);
}
impl ADLSensorType {
    pub const PMLOG_SOC_POWER: ADLSensorType = ADLSensorType(17);
}
impl ADLSensorType {
    pub const PMLOG_SOC_CURRENT: ADLSensorType = ADLSensorType(18);
}
impl ADLSensorType {
    pub const PMLOG_INFO_ACTIVITY_GFX: ADLSensorType = ADLSensorType(19);
}
impl ADLSensorType {
    pub const PMLOG_INFO_ACTIVITY_MEM: ADLSensorType = ADLSensorType(20);
}
impl ADLSensorType {
    pub const PMLOG_GFX_VOLTAGE: ADLSensorType = ADLSensorType(21);
}
impl ADLSensorType {
    pub const PMLOG_MEM_VOLTAGE: ADLSensorType = ADLSensorType(22);
}
impl ADLSensorType {
    pub const PMLOG_ASIC_POWER: ADLSensorType = ADLSensorType(23);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_VRSOC: ADLSensorType = ADLSensorType(24);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_VRMVDD0: ADLSensorType = ADLSensorType(25);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_VRMVDD1: ADLSensorType = ADLSensorType(26);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_HOTSPOT: ADLSensorType = ADLSensorType(27);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_GFX: ADLSensorType = ADLSensorType(28);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_SOC: ADLSensorType = ADLSensorType(29);
}
impl ADLSensorType {
    pub const PMLOG_GFX_POWER: ADLSensorType = ADLSensorType(30);
}
impl ADLSensorType {
    pub const PMLOG_GFX_CURRENT: ADLSensorType = ADLSensorType(31);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_CPU: ADLSensorType = ADLSensorType(32);
}
impl ADLSensorType {
    pub const PMLOG_CPU_POWER: ADLSensorType = ADLSensorType(33);
}
impl ADLSensorType {
    pub const PMLOG_CLK_CPUCLK: ADLSensorType = ADLSensorType(34);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_STATUS: ADLSensorType = ADLSensorType(35);
}
impl ADLSensorType {
    pub const PMLOG_CLK_VCN1CLK1: ADLSensorType = ADLSensorType(36);
}
impl ADLSensorType {
    pub const PMLOG_CLK_VCN1CLK2: ADLSensorType = ADLSensorType(37);
}
impl ADLSensorType {
    pub const PMLOG_SMART_POWERSHIFT_CPU: ADLSensorType = ADLSensorType(38);
}
impl ADLSensorType {
    pub const PMLOG_SMART_POWERSHIFT_DGPU: ADLSensorType = ADLSensorType(39);
}
impl ADLSensorType {
    pub const PMLOG_BUS_SPEED: ADLSensorType = ADLSensorType(40);
}
impl ADLSensorType {
    pub const PMLOG_BUS_LANES: ADLSensorType = ADLSensorType(41);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_LIQUID0: ADLSensorType = ADLSensorType(42);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_LIQUID1: ADLSensorType = ADLSensorType(43);
}
impl ADLSensorType {
    pub const PMLOG_CLK_FCLK: ADLSensorType = ADLSensorType(44);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_STATUS_CPU: ADLSensorType = ADLSensorType(45);
}
impl ADLSensorType {
    pub const PMLOG_SSPAIRED_ASICPOWER: ADLSensorType = ADLSensorType(46);
}
impl ADLSensorType {
    pub const PMLOG_SSTOTAL_POWERLIMIT: ADLSensorType = ADLSensorType(47);
}
impl ADLSensorType {
    pub const PMLOG_SSAPU_POWERLIMIT: ADLSensorType = ADLSensorType(48);
}
impl ADLSensorType {
    pub const PMLOG_SSDGPU_POWERLIMIT: ADLSensorType = ADLSensorType(49);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_HOTSPOT_GCD: ADLSensorType = ADLSensorType(50);
}
impl ADLSensorType {
    pub const PMLOG_TEMPERATURE_HOTSPOT_MCD: ADLSensorType = ADLSensorType(51);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_EDGE_PERCENTAGE: ADLSensorType = ADLSensorType(52);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_HOTSPOT_PERCENTAGE: ADLSensorType = ADLSensorType(53);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_HOTSPOT_GCD_PERCENTAGE: ADLSensorType = ADLSensorType(54);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_HOTSPOT_MCD_PERCENTAGE: ADLSensorType = ADLSensorType(55);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_MEM_PERCENTAGE: ADLSensorType = ADLSensorType(56);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_VR_GFX_PERCENTAGE: ADLSensorType = ADLSensorType(57);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_VR_MEM0_PERCENTAGE: ADLSensorType = ADLSensorType(58);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_VR_MEM1_PERCENTAGE: ADLSensorType = ADLSensorType(59);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_VR_SOC_PERCENTAGE: ADLSensorType = ADLSensorType(60);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_LIQUID0_PERCENTAGE: ADLSensorType = ADLSensorType(61);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_LIQUID1_PERCENTAGE: ADLSensorType = ADLSensorType(62);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TEMP_PLX_PERCENTAGE: ADLSensorType = ADLSensorType(63);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TDC_GFX_PERCENTAGE: ADLSensorType = ADLSensorType(64);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TDC_SOC_PERCENTAGE: ADLSensorType = ADLSensorType(65);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_TDC_USR_PERCENTAGE: ADLSensorType = ADLSensorType(66);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_PPT0_PERCENTAGE: ADLSensorType = ADLSensorType(67);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_PPT1_PERCENTAGE: ADLSensorType = ADLSensorType(68);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_PPT2_PERCENTAGE: ADLSensorType = ADLSensorType(69);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_PPT3_PERCENTAGE: ADLSensorType = ADLSensorType(70);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_FIT_PERCENTAGE: ADLSensorType = ADLSensorType(71);
}
impl ADLSensorType {
    pub const PMLOG_THROTTLER_GFX_APCC_PLUS_PERCENTAGE: ADLSensorType = ADLSensorType(72);
}
impl ADLSensorType {
    pub const PMLOG_BOARD_POWER: ADLSensorType = ADLSensorType(73);
}
impl ADLSensorType {
    pub const PMLOG_MAX_SENSORS_REAL: ADLSensorType = ADLSensorType(74);
}
#[repr(transparent)]
#[doc = " \\deprecated Replaced with ADL_PMLOG_SENSORS"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLSensorType(pub ::std::os::raw::c_int);
impl ADL_THROTTLE_NOTIFICATION {
    pub const ADL_PMLOG_THROTTLE_POWER: ADL_THROTTLE_NOTIFICATION = ADL_THROTTLE_NOTIFICATION(1);
}
impl ADL_THROTTLE_NOTIFICATION {
    pub const ADL_PMLOG_THROTTLE_THERMAL: ADL_THROTTLE_NOTIFICATION = ADL_THROTTLE_NOTIFICATION(2);
}
impl ADL_THROTTLE_NOTIFICATION {
    pub const ADL_PMLOG_THROTTLE_CURRENT: ADL_THROTTLE_NOTIFICATION = ADL_THROTTLE_NOTIFICATION(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_THROTTLE_NOTIFICATION(pub ::std::os::raw::c_int);
impl ADL_PMLOG_SENSORS {
    pub const ADL_SENSOR_MAXTYPES: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(0);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_GFXCLK: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(1);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_MEMCLK: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(2);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_SOCCLK: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(3);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_UVDCLK1: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(4);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_UVDCLK2: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(5);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_VCECLK: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(6);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_VCNCLK: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(7);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_EDGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(8);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_MEM: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(9);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_VRVDDC: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(10);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_VRMVDD: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(11);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_LIQUID: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(12);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_PLX: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(13);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_FAN_RPM: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(14);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_FAN_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(15);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_SOC_VOLTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(16);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_SOC_POWER: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(17);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_SOC_CURRENT: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(18);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_INFO_ACTIVITY_GFX: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(19);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_INFO_ACTIVITY_MEM: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(20);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_GFX_VOLTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(21);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_MEM_VOLTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(22);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_ASIC_POWER: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(23);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_VRSOC: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(24);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_VRMVDD0: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(25);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_VRMVDD1: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(26);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_HOTSPOT: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(27);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_GFX: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(28);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_SOC: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(29);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_GFX_POWER: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(30);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_GFX_CURRENT: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(31);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_CPU: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(32);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CPU_POWER: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(33);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_CPUCLK: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(34);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_STATUS: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(35);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_VCN1CLK1: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(36);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_VCN1CLK2: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(37);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_SMART_POWERSHIFT_CPU: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(38);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_SMART_POWERSHIFT_DGPU: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(39);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_BUS_SPEED: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(40);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_BUS_LANES: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(41);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_LIQUID0: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(42);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_LIQUID1: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(43);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_CLK_FCLK: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(44);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_STATUS_CPU: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(45);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_SSPAIRED_ASICPOWER: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(46);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_SSTOTAL_POWERLIMIT: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(47);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_SSAPU_POWERLIMIT: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(48);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_SSDGPU_POWERLIMIT: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(49);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_HOTSPOT_GCD: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(50);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_TEMPERATURE_HOTSPOT_MCD: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(51);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_EDGE_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(52);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_PERCENTAGE: ADL_PMLOG_SENSORS =
        ADL_PMLOG_SENSORS(53);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_GCD_PERCENTAGE: ADL_PMLOG_SENSORS =
        ADL_PMLOG_SENSORS(54);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_MCD_PERCENTAGE: ADL_PMLOG_SENSORS =
        ADL_PMLOG_SENSORS(55);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_MEM_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(56);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_VR_GFX_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(57);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_VR_MEM0_PERCENTAGE: ADL_PMLOG_SENSORS =
        ADL_PMLOG_SENSORS(58);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_VR_MEM1_PERCENTAGE: ADL_PMLOG_SENSORS =
        ADL_PMLOG_SENSORS(59);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_VR_SOC_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(60);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_LIQUID0_PERCENTAGE: ADL_PMLOG_SENSORS =
        ADL_PMLOG_SENSORS(61);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_LIQUID1_PERCENTAGE: ADL_PMLOG_SENSORS =
        ADL_PMLOG_SENSORS(62);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TEMP_PLX_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(63);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TDC_GFX_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(64);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TDC_SOC_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(65);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_TDC_USR_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(66);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_PPT0_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(67);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_PPT1_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(68);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_PPT2_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(69);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_PPT3_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(70);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_FIT_PERCENTAGE: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(71);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_THROTTLER_GFX_APCC_PLUS_PERCENTAGE: ADL_PMLOG_SENSORS =
        ADL_PMLOG_SENSORS(72);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_BOARD_POWER: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(73);
}
impl ADL_PMLOG_SENSORS {
    pub const ADL_PMLOG_MAX_SENSORS_REAL: ADL_PMLOG_SENSORS = ADL_PMLOG_SENSORS(74);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_PMLOG_SENSORS(pub ::std::os::raw::c_int);
#[doc = " \\defgroup define_D3DKMT_HANDLE\n @{\n Handle can be used to create Device Handle when using CreateDevice()"]
pub type ADL_D3DKMT_HANDLE = ::std::os::raw::c_uint;
impl ADL_RAS_ERROR_INJECTION_MODE {
    pub const ADL_RAS_ERROR_INJECTION_MODE_SINGLE: ADL_RAS_ERROR_INJECTION_MODE =
        ADL_RAS_ERROR_INJECTION_MODE(1);
}
impl ADL_RAS_ERROR_INJECTION_MODE {
    pub const ADL_RAS_ERROR_INJECTION_MODE_MULTIPLE: ADL_RAS_ERROR_INJECTION_MODE =
        ADL_RAS_ERROR_INJECTION_MODE(2);
}
#[repr(transparent)]
#[doc = " @}"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_RAS_ERROR_INJECTION_MODE(pub ::std::os::raw::c_int);
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_UMC: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(0);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_SDMA: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(1);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_GFX_HUB: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(2);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_MMHUB: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(3);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_ATHUB: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(4);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_PCIE_BIF: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(5);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_HDP: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(6);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_XGMI_WAFL: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(7);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_DF: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(8);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_SMN: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(9);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_SEM: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(10);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_MP0: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(11);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_MP1: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(12);
}
impl ADL_RAS_BLOCK_ID {
    pub const ADL_RAS_BLOCK_ID_FUSE: ADL_RAS_BLOCK_ID = ADL_RAS_BLOCK_ID(13);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_RAS_BLOCK_ID(pub ::std::os::raw::c_int);
impl ADL_MEM_SUB_BLOCK_ID {
    pub const ADL_RAS__UMC_HBM: ADL_MEM_SUB_BLOCK_ID = ADL_MEM_SUB_BLOCK_ID(0);
}
impl ADL_MEM_SUB_BLOCK_ID {
    pub const ADL_RAS__UMC_SRAM: ADL_MEM_SUB_BLOCK_ID = ADL_MEM_SUB_BLOCK_ID(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_MEM_SUB_BLOCK_ID(pub ::std::os::raw::c_int);
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__NONE: _ADL_RAS_ERROR_TYPE = _ADL_RAS_ERROR_TYPE(0);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__PARITY: _ADL_RAS_ERROR_TYPE = _ADL_RAS_ERROR_TYPE(1);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__SINGLE_CORRECTABLE: _ADL_RAS_ERROR_TYPE = _ADL_RAS_ERROR_TYPE(2);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE: _ADL_RAS_ERROR_TYPE =
        _ADL_RAS_ERROR_TYPE(3);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__MULTI_UNCORRECTABLE: _ADL_RAS_ERROR_TYPE = _ADL_RAS_ERROR_TYPE(4);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__PARITY_MULTI_UNCORRECTABLE: _ADL_RAS_ERROR_TYPE =
        _ADL_RAS_ERROR_TYPE(5);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE: _ADL_RAS_ERROR_TYPE =
        _ADL_RAS_ERROR_TYPE(6);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE: _ADL_RAS_ERROR_TYPE =
        _ADL_RAS_ERROR_TYPE(7);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__POISON: _ADL_RAS_ERROR_TYPE = _ADL_RAS_ERROR_TYPE(8);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__PARITY_POISON: _ADL_RAS_ERROR_TYPE = _ADL_RAS_ERROR_TYPE(9);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__SINGLE_CORRECTABLE_POISON: _ADL_RAS_ERROR_TYPE =
        _ADL_RAS_ERROR_TYPE(10);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_POISON: _ADL_RAS_ERROR_TYPE =
        _ADL_RAS_ERROR_TYPE(11);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__MULTI_UNCORRECTABLE_POISON: _ADL_RAS_ERROR_TYPE =
        _ADL_RAS_ERROR_TYPE(12);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__PARITY_MULTI_UNCORRECTABLE_POISON: _ADL_RAS_ERROR_TYPE =
        _ADL_RAS_ERROR_TYPE(13);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE_POISON: _ADL_RAS_ERROR_TYPE =
        _ADL_RAS_ERROR_TYPE(14);
}
impl _ADL_RAS_ERROR_TYPE {
    pub const ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE_POISON:
        _ADL_RAS_ERROR_TYPE = _ADL_RAS_ERROR_TYPE(15);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ADL_RAS_ERROR_TYPE(pub ::std::os::raw::c_int);
pub use self::_ADL_RAS_ERROR_TYPE as ADL_RAS_ERROR_TYPE;
impl ADL_RAS_INJECTION_METHOD {
    pub const ADL_RAS_ERROR__UMC_METH_COHERENT: ADL_RAS_INJECTION_METHOD =
        ADL_RAS_INJECTION_METHOD(0);
}
impl ADL_RAS_INJECTION_METHOD {
    pub const ADL_RAS_ERROR__UMC_METH_SINGLE_SHOT: ADL_RAS_INJECTION_METHOD =
        ADL_RAS_INJECTION_METHOD(1);
}
impl ADL_RAS_INJECTION_METHOD {
    pub const ADL_RAS_ERROR__UMC_METH_PERSISTENT: ADL_RAS_INJECTION_METHOD =
        ADL_RAS_INJECTION_METHOD(2);
}
impl ADL_RAS_INJECTION_METHOD {
    pub const ADL_RAS_ERROR__UMC_METH_PERSISTENT_DISABLE: ADL_RAS_INJECTION_METHOD =
        ADL_RAS_INJECTION_METHOD(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_RAS_INJECTION_METHOD(pub ::std::os::raw::c_int);
impl ADL_DRIVER_EVENT_TYPE {
    pub const ADL_EVENT_ID_AUTO_FEATURE_COMPLETED: ADL_DRIVER_EVENT_TYPE =
        ADL_DRIVER_EVENT_TYPE(30);
}
impl ADL_DRIVER_EVENT_TYPE {
    pub const ADL_EVENT_ID_FEATURE_AVAILABILITY: ADL_DRIVER_EVENT_TYPE = ADL_DRIVER_EVENT_TYPE(31);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_DRIVER_EVENT_TYPE(pub ::std::os::raw::c_int);
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_DVR: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(0);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_TURBOSYNC: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(1);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_FRAMEMETRICSMONITOR: ADL_UIFEATURES_GROUP =
        ADL_UIFEATURES_GROUP(2);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_FRTC: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(3);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_XVISION: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(4);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_BLOCKCHAIN: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(5);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_GAMEINTELLIGENCE: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(6);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_CHILL: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(7);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_DELAG: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(8);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_BOOST: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(9);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_USU: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(10);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_XGMI: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(11);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_PROVSR: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(12);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_SMA: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(13);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_CAMERA: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(14);
}
impl ADL_UIFEATURES_GROUP {
    pub const ADL_UIFEATURES_GROUP_FRTCPRO: ADL_UIFEATURES_GROUP = ADL_UIFEATURES_GROUP(15);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_UIFEATURES_GROUP(pub ::std::os::raw::c_int);
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_OFF: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(0);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_Static: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(1);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_Rainbow: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(2);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_Swirl: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(3);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_Chase: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(4);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_Bounce: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(5);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_MorseCode: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(6);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_ColorCycle: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(7);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_Breathing: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(8);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_CustomPattern: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(9);
}
impl ADL_RADEON_USB_LED_BAR_CONTROLS {
    pub const RadeonLEDBarControl_MAX: ADL_RADEON_USB_LED_BAR_CONTROLS =
        ADL_RADEON_USB_LED_BAR_CONTROLS(10);
}
#[repr(transparent)]
#[doc = "\n\\brief\n\n\n\n\n \\nosubgrouping\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_RADEON_USB_LED_BAR_CONTROLS(pub ::std::os::raw::c_int);
impl ADL_RADEON_USB_LED_CONTROL_CONFIGS {
    pub const RadeonLEDPattern_Speed: ADL_RADEON_USB_LED_CONTROL_CONFIGS =
        ADL_RADEON_USB_LED_CONTROL_CONFIGS(0);
}
impl ADL_RADEON_USB_LED_CONTROL_CONFIGS {
    pub const RadeonLEDPattern_Brightness: ADL_RADEON_USB_LED_CONTROL_CONFIGS =
        ADL_RADEON_USB_LED_CONTROL_CONFIGS(1);
}
impl ADL_RADEON_USB_LED_CONTROL_CONFIGS {
    pub const RadeonLEDPattern_Direction: ADL_RADEON_USB_LED_CONTROL_CONFIGS =
        ADL_RADEON_USB_LED_CONTROL_CONFIGS(2);
}
impl ADL_RADEON_USB_LED_CONTROL_CONFIGS {
    pub const RadeonLEDPattern_Color: ADL_RADEON_USB_LED_CONTROL_CONFIGS =
        ADL_RADEON_USB_LED_CONTROL_CONFIGS(3);
}
impl ADL_RADEON_USB_LED_CONTROL_CONFIGS {
    pub const RadeonLEDPattern_MAX: ADL_RADEON_USB_LED_CONTROL_CONFIGS =
        ADL_RADEON_USB_LED_CONTROL_CONFIGS(4);
}
#[repr(transparent)]
#[doc = "\n\\brief\n\n\n\n\n \\nosubgrouping\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_RADEON_USB_LED_CONTROL_CONFIGS(pub ::std::os::raw::c_int);
impl ADL_USER_SETTINGS {
    pub const ADL_USER_SETTINGS_ENHANCEDSYNC: ADL_USER_SETTINGS = ADL_USER_SETTINGS(1);
}
impl ADL_USER_SETTINGS {
    pub const ADL_USER_SETTINGS_CHILL_PROFILE: ADL_USER_SETTINGS = ADL_USER_SETTINGS(2);
}
impl ADL_USER_SETTINGS {
    pub const ADL_USER_SETTINGS_DELAG_PROFILE: ADL_USER_SETTINGS = ADL_USER_SETTINGS(4);
}
impl ADL_USER_SETTINGS {
    pub const ADL_USER_SETTINGS_BOOST_PROFILE: ADL_USER_SETTINGS = ADL_USER_SETTINGS(8);
}
impl ADL_USER_SETTINGS {
    pub const ADL_USER_SETTINGS_USU_PROFILE: ADL_USER_SETTINGS = ADL_USER_SETTINGS(16);
}
impl ADL_USER_SETTINGS {
    pub const ADL_USER_SETTINGS_CVDC_PROFILE: ADL_USER_SETTINGS = ADL_USER_SETTINGS(32);
}
impl ADL_USER_SETTINGS {
    pub const ADL_USER_SETTINGS_SCE_PROFILE: ADL_USER_SETTINGS = ADL_USER_SETTINGS(64);
}
impl ADL_USER_SETTINGS {
    pub const ADL_USER_SETTINGS_PROVSR: ADL_USER_SETTINGS = ADL_USER_SETTINGS(128);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_USER_SETTINGS(pub ::std::os::raw::c_int);
#[doc = "\n\\brief Structure containing information about the graphics adapter.\n\n This structure is used to store various information about the graphics adapter.  This\n information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various settings upon the user's request.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AdapterInfo {
    #[doc = " Size of the structure."]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " The ADL index handle. One GPU may be associated with one or two index handles"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The unique device ID associated with this adapter."]
    pub strUDID: [::std::os::raw::c_char; 256usize],
    #[doc = " The BUS number associated with this adapter."]
    pub iBusNumber: ::std::os::raw::c_int,
    #[doc = " The driver number associated with this adapter."]
    pub iDeviceNumber: ::std::os::raw::c_int,
    #[doc = " The function number."]
    pub iFunctionNumber: ::std::os::raw::c_int,
    #[doc = " The vendor ID associated with this adapter."]
    pub iVendorID: ::std::os::raw::c_int,
    #[doc = " Adapter name."]
    pub strAdapterName: [::std::os::raw::c_char; 256usize],
    #[doc = " Display name. For example, \"\\\\\\\\Display0\" for Windows or \":0:0\" for Linux."]
    pub strDisplayName: [::std::os::raw::c_char; 256usize],
    #[doc = " Present or not; 1 if present and 0 if not present.It the logical adapter is present, the display name such as \\\\\\\\.\\\\Display1 can be found from OS"]
    pub iPresent: ::std::os::raw::c_int,
    #[doc = " Exist or not; 1 is exist and 0 is not present."]
    pub iExist: ::std::os::raw::c_int,
    #[doc = " Driver registry path."]
    pub strDriverPath: [::std::os::raw::c_char; 256usize],
    #[doc = " Driver registry path Ext for."]
    pub strDriverPathExt: [::std::os::raw::c_char; 256usize],
    #[doc = " PNP string from Windows."]
    pub strPNPString: [::std::os::raw::c_char; 256usize],
    #[doc = " It is generated from EnumDisplayDevices."]
    pub iOSDisplayIndex: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the graphics adapter.\n\n This structure is used to store various information about the graphics adapter.  This\n information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various settings upon the user's request.\n \\nosubgrouping\n"]
pub type LPAdapterInfo = *mut AdapterInfo;
#[doc = "\n\\brief Structure containing information about an controller mode\n\n This structure is used to store information of an controller mode\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAdapterCaps {
    #[doc = " AdapterID for this adapter"]
    pub iAdapterID: ::std::os::raw::c_int,
    #[doc = " Number of controllers for this adapter"]
    pub iNumControllers: ::std::os::raw::c_int,
    #[doc = " Number of displays for this adapter"]
    pub iNumDisplays: ::std::os::raw::c_int,
    #[doc = " Number of overlays for this adapter"]
    pub iNumOverlays: ::std::os::raw::c_int,
    #[doc = " Number of GLSyncConnectors"]
    pub iNumOfGLSyncConnectors: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the adapter caps"]
    pub iCapsMask: ::std::os::raw::c_int,
    #[doc = " The bit identifies the adapter caps \\ref define_adapter_caps"]
    pub iCapsValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing additional information about the ASIC memory\n\n This structure is used to store additional information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMemoryInfo2 {
    #[doc = " Memory size in bytes."]
    pub iMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Memory type in string."]
    pub strMemoryType: [::std::os::raw::c_char; 256usize],
    #[doc = " Highest default performance level Memory bandwidth in Mbytes/s"]
    pub iMemoryBandwidth: ::std::os::raw::c_longlong,
    #[doc = " HyperMemory size in bytes."]
    pub iHyperMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Invisible Memory size in bytes."]
    pub iInvisibleMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Visible Memory size in bytes."]
    pub iVisibleMemorySize: ::std::os::raw::c_longlong,
}
#[doc = "\n\\brief Structure containing additional information about the ASIC memory\n\n This structure is used to store additional information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMemoryInfo3 {
    #[doc = " Memory size in bytes."]
    pub iMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Memory type in string."]
    pub strMemoryType: [::std::os::raw::c_char; 256usize],
    #[doc = " Highest default performance level Memory bandwidth in Mbytes/s"]
    pub iMemoryBandwidth: ::std::os::raw::c_longlong,
    #[doc = " HyperMemory size in bytes."]
    pub iHyperMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Invisible Memory size in bytes."]
    pub iInvisibleMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Visible Memory size in bytes."]
    pub iVisibleMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Vram vendor ID"]
    pub iVramVendorRevId: ::std::os::raw::c_longlong,
}
#[doc = "\n\\brief Structure containing additional information about the ASIC memory\n\n This structure is used to store additional information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMemoryInfoX4 {
    #[doc = " Memory size in bytes."]
    pub iMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Memory type in string."]
    pub strMemoryType: [::std::os::raw::c_char; 256usize],
    #[doc = " Highest default performance level Memory bandwidth in Mbytes/s"]
    pub iMemoryBandwidth: ::std::os::raw::c_longlong,
    #[doc = " HyperMemory size in bytes."]
    pub iHyperMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Invisible Memory size in bytes."]
    pub iInvisibleMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Visible Memory size in bytes."]
    pub iVisibleMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Vram vendor ID"]
    pub iVramVendorRevId: ::std::os::raw::c_longlong,
    #[doc = " Memory Bandiwidth that is calculated and finalized on the driver side, grab and go."]
    pub iMemoryBandwidthX2: ::std::os::raw::c_longlong,
    #[doc = " Memory Bit Rate that is calculated and finalized on the driver side, grab and go."]
    pub iMemoryBitRateX2: ::std::os::raw::c_longlong,
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_Unsupported: ADLvRamVendors = ADLvRamVendors(0);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_SAMSUNG: ADLvRamVendors = ADLvRamVendors(1);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_INFINEON: ADLvRamVendors = ADLvRamVendors(2);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_ELPIDA: ADLvRamVendors = ADLvRamVendors(3);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_ETRON: ADLvRamVendors = ADLvRamVendors(4);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_NANYA: ADLvRamVendors = ADLvRamVendors(5);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_HYNIX: ADLvRamVendors = ADLvRamVendors(6);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_MOSEL: ADLvRamVendors = ADLvRamVendors(7);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_WINBOND: ADLvRamVendors = ADLvRamVendors(8);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_ESMT: ADLvRamVendors = ADLvRamVendors(9);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_MICRON: ADLvRamVendors = ADLvRamVendors(15);
}
impl ADLvRamVendors {
    pub const ADLvRamVendor_Undefined: ADLvRamVendors = ADLvRamVendors(16);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLvRamVendors(pub ::std::os::raw::c_int);
#[doc = "\n\\brief Structure containing information about components of ASIC GCN architecture\n\n  Elements of GCN info are compute units, number of Tex (Texture filtering units)  , number of ROPs (render back-ends).\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGcnInfo {
    pub CuCount: ::std::os::raw::c_int,
    pub TexCount: ::std::os::raw::c_int,
    pub RopCount: ::std::os::raw::c_int,
    pub ASICFamilyId: ::std::os::raw::c_int,
    pub ASICRevisionId: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information related virtual segment config information.\n\n This structure is used to store information related virtual segment config\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLVirtualSegmentSettingsOutput {
    pub virtualSegmentSupported: ::std::os::raw::c_int,
    pub virtualSegmentDefault: ::std::os::raw::c_int,
    pub virtualSegmentCurrent: ::std::os::raw::c_int,
    pub iMinSizeInMB: ::std::os::raw::c_int,
    pub iMaxSizeInMB: ::std::os::raw::c_int,
    pub icurrentSizeInMB: ::std::os::raw::c_int,
    pub idefaultSizeInMB: ::std::os::raw::c_int,
    pub iMask: ::std::os::raw::c_int,
    pub iValue: ::std::os::raw::c_int,
}
#[doc = "\n \\brief Structure containing information about the Chipset.\n\n This structure is used to store various information about the Chipset.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLChipSetInfo {
    #[doc = "< Bus type."]
    pub iBusType: ::std::os::raw::c_int,
    pub iBusSpeedType: ::std::os::raw::c_int,
    #[doc = "< Number of PCIE lanes."]
    pub iMaxPCIELaneWidth: ::std::os::raw::c_int,
    #[doc = "< Current PCIE Lane Width"]
    pub iCurrentPCIELaneWidth: ::std::os::raw::c_int,
    #[doc = "< Bit mask or AGP transfer speed."]
    pub iSupportedAGPSpeeds: ::std::os::raw::c_int,
    #[doc = "< Current AGP speed"]
    pub iCurrentAGPSpeed: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the ASIC memory.\n\n This structure is used to store various information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMemoryInfo {
    #[doc = " Memory size in bytes."]
    pub iMemorySize: ::std::os::raw::c_longlong,
    #[doc = " Memory type in string."]
    pub strMemoryType: [::std::os::raw::c_char; 256usize],
    #[doc = " Memory bandwidth in Mbytes/s."]
    pub iMemoryBandwidth: ::std::os::raw::c_longlong,
}
#[doc = "\n\\brief Structure containing information about memory required by type\n\n This structure is returned by ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration\n will return the Memory used.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMemoryRequired {
    pub iMemoryReq: ::std::os::raw::c_longlong,
    #[doc = " Memory in bytes required"]
    pub iType: ::std::os::raw::c_int,
    #[doc = " Type of Memory \\ref define_adl_validmemoryrequiredfields"]
    pub iDisplayFeatureValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the features associated with a display\n\n This structure is a parameter to ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration\n will return the Memory used.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMemoryDisplayFeatures {
    pub iDisplayIndex: ::std::os::raw::c_int,
    #[doc = " ADL Display index"]
    pub iDisplayFeatureValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing DDC information.\n\n This structure is used to store various DDC information that can be returned to the user.\n Note that all fields of type int are actually defined as unsigned int types within the driver.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDDCInfo {
    #[doc = " Size of the structure"]
    pub ulSize: ::std::os::raw::c_int,
    #[doc = " Indicates whether the attached display supports DDC. If this field is zero on return, no other DDC information fields will be used."]
    pub ulSupportsDDC: ::std::os::raw::c_int,
    #[doc = " Returns the manufacturer ID of the display device. Should be zeroed if this information is not available."]
    pub ulManufacturerID: ::std::os::raw::c_int,
    #[doc = " Returns the product ID of the display device. Should be zeroed if this information is not available."]
    pub ulProductID: ::std::os::raw::c_int,
    #[doc = " Returns the name of the display device. Should be zeroed if this information is not available."]
    pub cDisplayName: [::std::os::raw::c_char; 256usize],
    #[doc = " Returns the maximum Horizontal supported resolution. Should be zeroed if this information is not available."]
    pub ulMaxHResolution: ::std::os::raw::c_int,
    #[doc = " Returns the maximum Vertical supported resolution. Should be zeroed if this information is not available."]
    pub ulMaxVResolution: ::std::os::raw::c_int,
    #[doc = " Returns the maximum supported refresh rate. Should be zeroed if this information is not available."]
    pub ulMaxRefresh: ::std::os::raw::c_int,
    #[doc = " Returns the display device preferred timing mode's horizontal resolution."]
    pub ulPTMCx: ::std::os::raw::c_int,
    #[doc = " Returns the display device preferred timing mode's vertical resolution."]
    pub ulPTMCy: ::std::os::raw::c_int,
    #[doc = " Returns the display device preferred timing mode's refresh rate."]
    pub ulPTMRefreshRate: ::std::os::raw::c_int,
    #[doc = " Return EDID flags."]
    pub ulDDCInfoFlag: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing DDC information.\n\n This structure is used to store various DDC information that can be returned to the user.\n Note that all fields of type int are actually defined as unsigned int types within the driver.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDDCInfo2 {
    #[doc = " Size of the structure"]
    pub ulSize: ::std::os::raw::c_int,
    #[doc = " Indicates whether the attached display supports DDC. If this field is zero on return, no other DDC\n information fields will be used."]
    pub ulSupportsDDC: ::std::os::raw::c_int,
    #[doc = " Returns the manufacturer ID of the display device. Should be zeroed if this information is not available."]
    pub ulManufacturerID: ::std::os::raw::c_int,
    #[doc = " Returns the product ID of the display device. Should be zeroed if this information is not available."]
    pub ulProductID: ::std::os::raw::c_int,
    #[doc = " Returns the name of the display device. Should be zeroed if this information is not available."]
    pub cDisplayName: [::std::os::raw::c_char; 256usize],
    #[doc = " Returns the maximum Horizontal supported resolution. Should be zeroed if this information is not available."]
    pub ulMaxHResolution: ::std::os::raw::c_int,
    #[doc = " Returns the maximum Vertical supported resolution. Should be zeroed if this information is not available."]
    pub ulMaxVResolution: ::std::os::raw::c_int,
    #[doc = " Returns the maximum supported refresh rate. Should be zeroed if this information is not available."]
    pub ulMaxRefresh: ::std::os::raw::c_int,
    #[doc = " Returns the display device preferred timing mode's horizontal resolution."]
    pub ulPTMCx: ::std::os::raw::c_int,
    #[doc = " Returns the display device preferred timing mode's vertical resolution."]
    pub ulPTMCy: ::std::os::raw::c_int,
    #[doc = " Returns the display device preferred timing mode's refresh rate."]
    pub ulPTMRefreshRate: ::std::os::raw::c_int,
    #[doc = " Return EDID flags."]
    pub ulDDCInfoFlag: ::std::os::raw::c_int,
    #[doc = " Returns 1 if the display supported packed pixel, 0 otherwise"]
    pub bPackedPixelSupported: ::std::os::raw::c_int,
    #[doc = " Returns the Pixel formats the display supports \\ref define_ddcinfo_pixelformats"]
    pub iPanelPixelFormat: ::std::os::raw::c_int,
    #[doc = " Return EDID serial ID."]
    pub ulSerialID: ::std::os::raw::c_int,
    #[doc = " Return minimum monitor luminance data"]
    pub ulMinLuminanceData: ::std::os::raw::c_int,
    #[doc = " Return average monitor luminance data"]
    pub ulAvgLuminanceData: ::std::os::raw::c_int,
    #[doc = " Return maximum monitor luminance data"]
    pub ulMaxLuminanceData: ::std::os::raw::c_int,
    #[doc = " Bit vector of supported transfer functions \\ref define_source_content_TF"]
    pub iSupportedTransferFunction: ::std::os::raw::c_int,
    #[doc = " Bit vector of supported color spaces \\ref define_source_content_CS"]
    pub iSupportedColorSpace: ::std::os::raw::c_int,
    #[doc = " Display Red Chromaticity X coordinate multiplied by 10000"]
    pub iNativeDisplayChromaticityRedX: ::std::os::raw::c_int,
    #[doc = " Display Red Chromaticity Y coordinate multiplied by 10000"]
    pub iNativeDisplayChromaticityRedY: ::std::os::raw::c_int,
    #[doc = " Display Green Chromaticity X coordinate multiplied by 10000"]
    pub iNativeDisplayChromaticityGreenX: ::std::os::raw::c_int,
    #[doc = " Display Green Chromaticity Y coordinate multiplied by 10000"]
    pub iNativeDisplayChromaticityGreenY: ::std::os::raw::c_int,
    #[doc = " Display Blue Chromaticity X coordinate multiplied by 10000"]
    pub iNativeDisplayChromaticityBlueX: ::std::os::raw::c_int,
    #[doc = " Display Blue Chromaticity Y coordinate multiplied by 10000"]
    pub iNativeDisplayChromaticityBlueY: ::std::os::raw::c_int,
    #[doc = " Display White Point X coordinate multiplied by 10000"]
    pub iNativeDisplayChromaticityWhitePointX: ::std::os::raw::c_int,
    #[doc = " Display White Point Y coordinate multiplied by 10000"]
    pub iNativeDisplayChromaticityWhitePointY: ::std::os::raw::c_int,
    #[doc = " Display diffuse screen reflectance 0-1 (100%) in units of 0.01"]
    pub iDiffuseScreenReflectance: ::std::os::raw::c_int,
    #[doc = " Display specular screen reflectance 0-1 (100%) in units of 0.01"]
    pub iSpecularScreenReflectance: ::std::os::raw::c_int,
    #[doc = " Bit vector of supported color spaces \\ref define_HDR_support"]
    pub iSupportedHDR: ::std::os::raw::c_int,
    #[doc = " Bit vector for freesync flags"]
    pub iFreesyncFlags: ::std::os::raw::c_int,
    #[doc = " Return minimum monitor luminance without dimming data"]
    pub ulMinLuminanceNoDimmingData: ::std::os::raw::c_int,
    pub ulMaxBacklightMaxLuminanceData: ::std::os::raw::c_int,
    pub ulMinBacklightMaxLuminanceData: ::std::os::raw::c_int,
    pub ulMaxBacklightMinLuminanceData: ::std::os::raw::c_int,
    pub ulMinBacklightMinLuminanceData: ::std::os::raw::c_int,
    pub iReserved: [::std::os::raw::c_int; 4usize],
}
#[doc = "\n\\brief Structure containing information controller Gamma settings.\n\n This structure is used to store the red, green and blue color channel information for the.\n controller gamma setting. This information is returned by ADL, and it can also be used to\n set the controller gamma setting.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGamma {
    #[doc = " Red color channel gamma value."]
    pub fRed: f32,
    #[doc = " Green color channel gamma value."]
    pub fGreen: f32,
    #[doc = " Blue color channel gamma value."]
    pub fBlue: f32,
}
#[doc = "\n\\brief Structure containing information about component video custom modes.\n\n This structure is used to store the component video custom mode.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLCustomMode {
    #[doc = " Custom mode flags.  They are returned by the ADL driver."]
    pub iFlags: ::std::os::raw::c_int,
    #[doc = " Custom mode width."]
    pub iModeWidth: ::std::os::raw::c_int,
    #[doc = " Custom mode height."]
    pub iModeHeight: ::std::os::raw::c_int,
    #[doc = " Custom mode base width."]
    pub iBaseModeWidth: ::std::os::raw::c_int,
    #[doc = " Custom mode base height."]
    pub iBaseModeHeight: ::std::os::raw::c_int,
    #[doc = " Custom mode refresh rate."]
    pub iRefreshRate: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing Clock information for OD5 calls.\n\n This structure is used to retrieve clock information for OD5 calls.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGetClocksOUT {
    pub ulHighCoreClock: ::std::os::raw::c_long,
    pub ulHighMemoryClock: ::std::os::raw::c_long,
    pub ulHighVddc: ::std::os::raw::c_long,
    pub ulCoreMin: ::std::os::raw::c_long,
    pub ulCoreMax: ::std::os::raw::c_long,
    pub ulMemoryMin: ::std::os::raw::c_long,
    pub ulMemoryMax: ::std::os::raw::c_long,
    pub ulActivityPercent: ::std::os::raw::c_long,
    pub ulCurrentCoreClock: ::std::os::raw::c_long,
    pub ulCurrentMemoryClock: ::std::os::raw::c_long,
    pub ulReserved: ::std::os::raw::c_long,
}
#[doc = "\n\\brief Structure containing HDTV information for display calls.\n\n This structure is used to retrieve HDTV information for display calls.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayConfig {
    #[doc = " Size of the structure"]
    pub ulSize: ::std::os::raw::c_long,
    #[doc = " HDTV connector type."]
    pub ulConnectorType: ::std::os::raw::c_long,
    #[doc = " HDTV capabilities."]
    pub ulDeviceData: ::std::os::raw::c_long,
    #[doc = " Overridden HDTV capabilities."]
    pub ulOverridedDeviceData: ::std::os::raw::c_long,
    #[doc = " Reserved field"]
    pub ulReserved: ::std::os::raw::c_long,
}
#[doc = "\n\\brief Structure containing information about the display device.\n\n This structure is used to store display device information\n such as display index, type, name, connection status, mapped adapter and controller indexes,\n whether or not multiple VPUs are supported, local display connections or not (through Lasso), etc.\n This information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various display device related settings upon the user's request.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayID {
    #[doc = " The logical display index belonging to this adapter."]
    pub iDisplayLogicalIndex: ::std::os::raw::c_int,
    #[doc = "\\brief The physical display index.\n For example, display index 2 from adapter 2 can be used by current adapter 1.\\n\n So current adapter may enumerate this adapter as logical display 7 but the physical display\n index is still 2."]
    pub iDisplayPhysicalIndex: ::std::os::raw::c_int,
    #[doc = " The persistent logical adapter index for the display."]
    pub iDisplayLogicalAdapterIndex: ::std::os::raw::c_int,
    #[doc = "\\brief The persistent physical adapter index for the display.\n It can be the current adapter or a non-local adapter. \\n\n If this adapter index is different than the current adapter,\n the Display Non Local flag is set inside DisplayInfoValue."]
    pub iDisplayPhysicalAdapterIndex: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the display device.\n\n This structure is used to store various information about the display device.  This\n information can be returned to the user, or used to access various driver calls to set\n or fetch various display-device-related settings upon the user's request\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayInfo {
    #[doc = " The DisplayID structure"]
    pub displayID: ADLDisplayID,
    #[doc = "\\deprecated The controller index to which the display is mapped.\\n Will not be used in the future\\n"]
    pub iDisplayControllerIndex: ::std::os::raw::c_int,
    #[doc = " The display's EDID name."]
    pub strDisplayName: [::std::os::raw::c_char; 256usize],
    #[doc = " The display's manufacturer name."]
    pub strDisplayManufacturerName: [::std::os::raw::c_char; 256usize],
    #[doc = " The Display type. For example: CRT, TV, CV, DFP."]
    pub iDisplayType: ::std::os::raw::c_int,
    #[doc = " The display output type. For example: HDMI, SVIDEO, COMPONENT VIDEO."]
    pub iDisplayOutputType: ::std::os::raw::c_int,
    #[doc = " The connector type for the device."]
    pub iDisplayConnector: ::std::os::raw::c_int,
    #[doc = "\\brief The bit mask identifies the number of bits ADLDisplayInfo is currently using. \\n\n It will be the sum all the bit definitions in ADL_DISPLAY_DISPLAYINFO_xxx."]
    pub iDisplayInfoMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the display status. \\ref define_displayinfomask"]
    pub iDisplayInfoValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the display port MST device.\n\n This structure is used to store various MST information about the display port device.  This\n information can be returned to the user, or used to access various driver calls to\n fetch various display-device-related settings upon the user's request\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayDPMSTInfo {
    #[doc = " The ADLDisplayID structure"]
    pub displayID: ADLDisplayID,
    #[doc = " total bandwidth available on the DP connector"]
    pub iTotalAvailableBandwidthInMpbs: ::std::os::raw::c_int,
    #[doc = " bandwidth allocated to this display"]
    pub iAllocatedBandwidthInMbps: ::std::os::raw::c_int,
    #[doc = " string identifier for the display"]
    pub strGlobalUniqueIdentifier: [::std::os::raw::c_char; 256usize],
    #[doc = " The link count of relative address, rad[0] upto rad[linkCount] are valid"]
    pub radLinkCount: ::std::os::raw::c_int,
    #[doc = " The physical connector ID, used to identify the physical DP port"]
    pub iPhysicalConnectorID: ::std::os::raw::c_int,
    #[doc = " Relative address, address scheme starts from source side"]
    pub rad: [::std::os::raw::c_char; 15usize],
}
#[doc = "\n\\brief Structure containing the display mode definition used per controller.\n\n This structure is used to store the display mode definition used per controller.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayMode {
    #[doc = " Vertical resolution (in pixels)."]
    pub iPelsHeight: ::std::os::raw::c_int,
    #[doc = " Horizontal resolution (in pixels)."]
    pub iPelsWidth: ::std::os::raw::c_int,
    #[doc = " Color depth."]
    pub iBitsPerPel: ::std::os::raw::c_int,
    #[doc = " Refresh rate."]
    pub iDisplayFrequency: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing detailed timing parameters.\n\n This structure is used to store the detailed timing parameters.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDetailedTiming {
    #[doc = " Size of the structure."]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Timing flags. \\ref define_detailed_timing_flags"]
    pub sTimingFlags: ::std::os::raw::c_short,
    #[doc = " Total width (columns)."]
    pub sHTotal: ::std::os::raw::c_short,
    #[doc = " Displayed width."]
    pub sHDisplay: ::std::os::raw::c_short,
    #[doc = " Horizontal sync signal offset."]
    pub sHSyncStart: ::std::os::raw::c_short,
    #[doc = " Horizontal sync signal width."]
    pub sHSyncWidth: ::std::os::raw::c_short,
    #[doc = " Total height (rows)."]
    pub sVTotal: ::std::os::raw::c_short,
    #[doc = " Displayed height."]
    pub sVDisplay: ::std::os::raw::c_short,
    #[doc = " Vertical sync signal offset."]
    pub sVSyncStart: ::std::os::raw::c_short,
    #[doc = " Vertical sync signal width."]
    pub sVSyncWidth: ::std::os::raw::c_short,
    #[doc = " Pixel clock value."]
    pub sPixelClock: ::std::os::raw::c_short,
    #[doc = " Overscan right."]
    pub sHOverscanRight: ::std::os::raw::c_short,
    #[doc = " Overscan left."]
    pub sHOverscanLeft: ::std::os::raw::c_short,
    #[doc = " Overscan bottom."]
    pub sVOverscanBottom: ::std::os::raw::c_short,
    #[doc = " Overscan top."]
    pub sVOverscanTop: ::std::os::raw::c_short,
    pub sOverscan8B: ::std::os::raw::c_short,
    pub sOverscanGR: ::std::os::raw::c_short,
}
#[doc = "\n\\brief Structure containing display mode information.\n\n This structure is used to store the display mode information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayModeInfo {
    #[doc = " Timing standard of the current mode. \\ref define_modetiming_standard"]
    pub iTimingStandard: ::std::os::raw::c_int,
    #[doc = " Applicable timing standards for the current mode."]
    pub iPossibleStandard: ::std::os::raw::c_int,
    #[doc = " Refresh rate factor."]
    pub iRefreshRate: ::std::os::raw::c_int,
    #[doc = " Num of pixels in a row."]
    pub iPelsWidth: ::std::os::raw::c_int,
    #[doc = " Num of pixels in a column."]
    pub iPelsHeight: ::std::os::raw::c_int,
    #[doc = " Detailed timing parameters."]
    pub sDetailedTiming: ADLDetailedTiming,
}
#[doc = "\n \\brief Structure containing information about display property.\n\n This structure is used to store the display property for the current adapter.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayProperty {
    #[doc = " Must be set to sizeof the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Must be set to \\ref ADL_DL_DISPLAYPROPERTY_TYPE_EXPANSIONMODE or \\ref ADL_DL_DISPLAYPROPERTY_TYPE_USEUNDERSCANSCALING"]
    pub iPropertyType: ::std::os::raw::c_int,
    #[doc = " Get or Set \\ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_CENTER or \\ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_FULLSCREEN or \\ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_ASPECTRATIO or \\ref ADL_DL_DISPLAYPROPERTY_TYPE_ITCFLAGENABLE"]
    pub iExpansionMode: ::std::os::raw::c_int,
    #[doc = " Display Property supported? 1: Supported, 0: Not supported"]
    pub iSupport: ::std::os::raw::c_int,
    #[doc = " Display Property current value"]
    pub iCurrent: ::std::os::raw::c_int,
    #[doc = " Display Property Default value"]
    pub iDefault: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Clock.\n\n This structure is used to store the clock information for the current adapter\n such as core clock and memory clock info.\n\\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLClockInfo {
    #[doc = " Core clock in 10 KHz."]
    pub iCoreClock: ::std::os::raw::c_int,
    #[doc = " Memory clock in 10 KHz."]
    pub iMemoryClock: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about I2C.\n\n This structure is used to store the I2C information for the current adapter.\n This structure is used by the ADL_Display_WriteAndReadI2C() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLI2C {
    #[doc = " Size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Numerical value representing hardware I2C."]
    pub iLine: ::std::os::raw::c_int,
    #[doc = " The 7-bit I2C slave device address, shifted one bit to the left."]
    pub iAddress: ::std::os::raw::c_int,
    #[doc = " The offset of the data from the address."]
    pub iOffset: ::std::os::raw::c_int,
    #[doc = " Read from or write to slave device. \\ref ADL_DL_I2C_ACTIONREAD or \\ref ADL_DL_I2C_ACTIONWRITE or \\ref ADL_DL_I2C_ACTIONREAD_REPEATEDSTART"]
    pub iAction: ::std::os::raw::c_int,
    #[doc = " I2C clock speed in KHz."]
    pub iSpeed: ::std::os::raw::c_int,
    #[doc = " A numerical value representing the number of bytes to be sent or received on the I2C bus."]
    pub iDataSize: ::std::os::raw::c_int,
    #[doc = " Address of the characters which are to be sent or received on the I2C bus."]
    pub pcData: *mut ::std::os::raw::c_char,
}
#[doc = "\n\\brief Structure containing information about EDID data.\n\n This structure is used to store the information about EDID data for the adapter.\n This structure is used by the ADL_Display_EdidData_Get() and ADL_Display_EdidData_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayEDIDData {
    #[doc = " Size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Set to 0"]
    pub iFlag: ::std::os::raw::c_int,
    #[doc = " Size of cEDIDData. Set by ADL_Display_EdidData_Get() upon return"]
    pub iEDIDSize: ::std::os::raw::c_int,
    #[doc = " 0, 1 or 2. If set to 3 or above an error ADL_ERR_INVALID_PARAM is generated"]
    pub iBlockIndex: ::std::os::raw::c_int,
    #[doc = " EDID data"]
    pub cEDIDData: [::std::os::raw::c_char; 256usize],
    #[doc = " Reserved"]
    pub iReserved: [::std::os::raw::c_int; 4usize],
}
#[doc = "\n\\brief Structure containing information about input of controller overlay adjustment.\n\n This structure is used to store the information about input of controller overlay adjustment for the adapter.\n This structure is used by the ADL_Display_ControllerOverlayAdjustmentCaps_Get, ADL_Display_ControllerOverlayAdjustmentData_Get, and\n ADL_Display_ControllerOverlayAdjustmentData_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLControllerOverlayInput {
    #[doc = " Should be set to the sizeof the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = "\\ref ADL_DL_CONTROLLER_OVERLAY_ALPHA or \\ref ADL_DL_CONTROLLER_OVERLAY_ALPHAPERPIX"]
    pub iOverlayAdjust: ::std::os::raw::c_int,
    #[doc = " Data."]
    pub iValue: ::std::os::raw::c_int,
    #[doc = " Should be 0."]
    pub iReserved: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about overlay adjustment.\n\n This structure is used to store the information about overlay adjustment for the adapter.\n This structure is used by the ADLControllerOverlayInfo() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAdjustmentinfo {
    #[doc = " Default value"]
    pub iDefault: ::std::os::raw::c_int,
    #[doc = " Minimum value"]
    pub iMin: ::std::os::raw::c_int,
    #[doc = " Maximum Value"]
    pub iMax: ::std::os::raw::c_int,
    #[doc = " Step value"]
    pub iStep: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about controller overlay information.\n\n This structure is used to store information about controller overlay info for the adapter.\n This structure is used by the ADL_Display_ControllerOverlayAdjustmentCaps_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLControllerOverlayInfo {
    #[doc = " Should be set to the sizeof the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Data."]
    pub sOverlayInfo: ADLAdjustmentinfo,
    #[doc = " Should be 0."]
    pub iReserved: [::std::os::raw::c_int; 3usize],
}
#[doc = "\n\\brief Structure containing GL-Sync module information.\n\n This structure is used to retrieve GL-Sync module information for\n Workstation Framelock/Genlock.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGLSyncModuleID {
    #[doc = " Unique GL-Sync module ID."]
    pub iModuleID: ::std::os::raw::c_int,
    #[doc = " GL-Sync GPU port index (to be passed into ADLGLSyncGenlockConfig.lSignalSource and ADLGlSyncPortControl.lSignalSource)."]
    pub iGlSyncGPUPort: ::std::os::raw::c_int,
    #[doc = " GL-Sync module firmware version of Boot Sector."]
    pub iFWBootSectorVersion: ::std::os::raw::c_int,
    #[doc = " GL-Sync module firmware version of User Sector."]
    pub iFWUserSectorVersion: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing GL-Sync ports capabilities.\n\n This structure is used to retrieve hardware capabilities for the ports of the GL-Sync module\n for Workstation Framelock/Genlock (such as port type and number of associated LEDs).\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGLSyncPortCaps {
    #[doc = " Port type. Bitfield of ADL_GLSYNC_PORTTYPE_*  \\ref define_glsync"]
    pub iPortType: ::std::os::raw::c_int,
    #[doc = " Number of LEDs associated for this port."]
    pub iNumOfLEDs: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing GL-Sync Genlock settings.\n\n This structure is used to get and set genlock settings for the GPU ports of the GL-Sync module\n for Workstation Framelock/Genlock.\\n\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGLSyncGenlockConfig {
    #[doc = " Specifies what fields in this structure are valid \\ref define_glsync"]
    pub iValidMask: ::std::os::raw::c_int,
    #[doc = " Delay (ms) generating a sync signal."]
    pub iSyncDelay: ::std::os::raw::c_int,
    #[doc = " Vector of framelock control bits. Bitfield of ADL_GLSYNC_FRAMELOCKCNTL_* \\ref define_glsync"]
    pub iFramelockCntlVector: ::std::os::raw::c_int,
    #[doc = " Source of the sync signal. Either GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_* \\ref define_glsync"]
    pub iSignalSource: ::std::os::raw::c_int,
    #[doc = " Use sampled sync signal. A value of 0 specifies no sampling."]
    pub iSampleRate: ::std::os::raw::c_int,
    #[doc = " For interlaced sync signals, the value can be ADL_GLSYNC_SYNCFIELD_1 or *_BOTH \\ref define_glsync"]
    pub iSyncField: ::std::os::raw::c_int,
    #[doc = " The signal edge that should trigger synchronization. ADL_GLSYNC_TRIGGEREDGE_* \\ref define_glsync"]
    pub iTriggerEdge: ::std::os::raw::c_int,
    #[doc = " Scan rate multiplier applied to the sync signal. ADL_GLSYNC_SCANRATECOEFF_* \\ref define_glsync"]
    pub iScanRateCoeff: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing GL-Sync port information.\n\n This structure is used to get status of the GL-Sync ports (BNC or RJ45s)\n for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGlSyncPortInfo {
    #[doc = " Type of GL-Sync port (ADL_GLSYNC_PORT_*)."]
    pub iPortType: ::std::os::raw::c_int,
    #[doc = " The number of LEDs for this port. It's also filled within ADLGLSyncPortCaps."]
    pub iNumOfLEDs: ::std::os::raw::c_int,
    #[doc = " Port state ADL_GLSYNC_PORTSTATE_*  \\ref define_glsync"]
    pub iPortState: ::std::os::raw::c_int,
    #[doc = " Scanned frequency for this port (vertical refresh rate in milliHz; 60000 means 60 Hz)."]
    pub iFrequency: ::std::os::raw::c_int,
    #[doc = " Used for ADL_GLSYNC_PORT_BNC. It is ADL_GLSYNC_SIGNALTYPE_*   \\ref define_glsync"]
    pub iSignalType: ::std::os::raw::c_int,
    #[doc = " Used for ADL_GLSYNC_PORT_RJ45PORT*. It is GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_*.  \\ref define_glsync"]
    pub iSignalSource: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing GL-Sync port control settings.\n\n This structure is used to configure the GL-Sync ports (RJ45s only)\n for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGlSyncPortControl {
    #[doc = " Port to control ADL_GLSYNC_PORT_RJ45PORT1 or ADL_GLSYNC_PORT_RJ45PORT2   \\ref define_glsync"]
    pub iPortType: ::std::os::raw::c_int,
    #[doc = " Port control data ADL_GLSYNC_PORTCNTL_*   \\ref define_glsync"]
    pub iControlVector: ::std::os::raw::c_int,
    #[doc = " Source of the sync signal. Either GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_*   \\ref define_glsync"]
    pub iSignalSource: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing GL-Sync mode of a display.\n\n This structure is used to get and set GL-Sync mode settings for a display connected to\n an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGlSyncMode {
    #[doc = " Mode control vector. Bitfield of ADL_GLSYNC_MODECNTL_*   \\ref define_glsync"]
    pub iControlVector: ::std::os::raw::c_int,
    #[doc = " Mode status vector. Bitfield of ADL_GLSYNC_MODECNTL_STATUS_*   \\ref define_glsync"]
    pub iStatusVector: ::std::os::raw::c_int,
    #[doc = " Index of GL-Sync connector used to genlock the display/controller."]
    pub iGLSyncConnectorIndex: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing GL-Sync mode of a display.\n\n This structure is used to get and set GL-Sync mode settings for a display connected to\n an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGlSyncMode2 {
    #[doc = " Mode control vector. Bitfield of ADL_GLSYNC_MODECNTL_*   \\ref define_glsync"]
    pub iControlVector: ::std::os::raw::c_int,
    #[doc = " Mode status vector. Bitfield of ADL_GLSYNC_MODECNTL_STATUS_*   \\ref define_glsync"]
    pub iStatusVector: ::std::os::raw::c_int,
    #[doc = " Index of GL-Sync connector used to genlock the display/controller."]
    pub iGLSyncConnectorIndex: ::std::os::raw::c_int,
    #[doc = " Index of the display to which this GLSync applies to."]
    pub iDisplayIndex: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing the packet info of a display.\n\n This structure is used to get and set the packet information of a display.\n This structure is used by ADLDisplayDataPacket.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLInfoPacket {
    pub hb0: ::std::os::raw::c_char,
    pub hb1: ::std::os::raw::c_char,
    pub hb2: ::std::os::raw::c_char,
    #[doc = " sb0~sb27"]
    pub sb: [::std::os::raw::c_char; 28usize],
}
#[doc = "\n\\brief Structure containing the AVI packet info of a display.\n\n This structure is used to get and set AVI the packet info of a display.\n This structure is used by ADLDisplayDataPacket.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAVIInfoPacket {
    #[doc = " byte 3, bit 7"]
    pub bPB3_ITC: ::std::os::raw::c_char,
    #[doc = " byte 5, bit [7:4]."]
    pub bPB5: ::std::os::raw::c_char,
}
#[doc = "\n\\brief Structure containing the Overdrive clock setting.\n\n This structure is used to get the Overdrive clock setting.\n This structure is used by ADLAdapterODClockInfo.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODClockSetting {
    #[doc = " Default clock"]
    pub iDefaultClock: ::std::os::raw::c_int,
    #[doc = " Current clock"]
    pub iCurrentClock: ::std::os::raw::c_int,
    #[doc = " Maximum clock"]
    pub iMaxClock: ::std::os::raw::c_int,
    #[doc = " Minimum clock"]
    pub iMinClock: ::std::os::raw::c_int,
    #[doc = " Requested clock"]
    pub iRequestedClock: ::std::os::raw::c_int,
    #[doc = " Step"]
    pub iStepClock: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing the Overdrive clock information.\n\n This structure is used to get the Overdrive clock information.\n This structure is used by the ADL_Display_ODClockInfo_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAdapterODClockInfo {
    #[doc = " Size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Flag \\ref define_clockinfo_flags"]
    pub iFlags: ::std::os::raw::c_int,
    #[doc = " Memory Clock"]
    pub sMemoryClock: ADLODClockSetting,
    #[doc = " Engine Clock"]
    pub sEngineClock: ADLODClockSetting,
}
#[doc = "\n\\brief Structure containing the Overdrive clock configuration.\n\n This structure is used to set the Overdrive clock configuration.\n This structure is used by the ADL_Display_ODClockConfig_Set() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAdapterODClockConfig {
    #[doc = " Size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Flag \\ref define_clockinfo_flags"]
    pub iFlags: ::std::os::raw::c_int,
    #[doc = " Memory Clock"]
    pub iMemoryClock: ::std::os::raw::c_int,
    #[doc = " Engine Clock"]
    pub iEngineClock: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about current power management related activity.\n\n This structure is used to store information about current power management related activity.\n This structure (Overdrive 5 interfaces) is used by the ADL_PM_CurrentActivity_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPMActivity {
    #[doc = " Must be set to the size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Current engine clock."]
    pub iEngineClock: ::std::os::raw::c_int,
    #[doc = " Current memory clock."]
    pub iMemoryClock: ::std::os::raw::c_int,
    #[doc = " Current core voltage."]
    pub iVddc: ::std::os::raw::c_int,
    #[doc = " GPU utilization."]
    pub iActivityPercent: ::std::os::raw::c_int,
    #[doc = " Performance level index."]
    pub iCurrentPerformanceLevel: ::std::os::raw::c_int,
    #[doc = " Current PCIE bus speed."]
    pub iCurrentBusSpeed: ::std::os::raw::c_int,
    #[doc = " Number of PCIE bus lanes."]
    pub iCurrentBusLanes: ::std::os::raw::c_int,
    #[doc = " Maximum number of PCIE bus lanes."]
    pub iMaximumBusLanes: ::std::os::raw::c_int,
    #[doc = " Reserved for future purposes."]
    pub iReserved: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about thermal controller.\n\n This structure is used to store information about thermal controller.\n This structure is used by ADL_PM_ThermalDevices_Enum.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLThermalControllerInfo {
    #[doc = " Must be set to the size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Possible valies: \\ref ADL_DL_THERMAL_DOMAIN_OTHER or \\ref ADL_DL_THERMAL_DOMAIN_GPU."]
    pub iThermalDomain: ::std::os::raw::c_int,
    #[doc = "    GPU 0, 1, etc."]
    pub iDomainIndex: ::std::os::raw::c_int,
    #[doc = " Possible valies: \\ref ADL_DL_THERMAL_FLAG_INTERRUPT or \\ref ADL_DL_THERMAL_FLAG_FANCONTROL"]
    pub iFlags: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about thermal controller temperature.\n\n This structure is used to store information about thermal controller temperature.\n This structure is used by the ADL_PM_Temperature_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLTemperature {
    #[doc = " Must be set to the size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Temperature in millidegrees Celsius."]
    pub iTemperature: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about thermal controller fan speed.\n\n This structure is used to store information about thermal controller fan speed.\n This structure is used by the ADL_PM_FanSpeedInfo_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLFanSpeedInfo {
    #[doc = " Must be set to the size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " \\ref define_fanctrl"]
    pub iFlags: ::std::os::raw::c_int,
    #[doc = " Minimum possible fan speed value in percents."]
    pub iMinPercent: ::std::os::raw::c_int,
    #[doc = " Maximum possible fan speed value in percents."]
    pub iMaxPercent: ::std::os::raw::c_int,
    #[doc = " Minimum possible fan speed value in RPM."]
    pub iMinRPM: ::std::os::raw::c_int,
    #[doc = " Maximum possible fan speed value in RPM."]
    pub iMaxRPM: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about fan speed reported by thermal controller.\n\n This structure is used to store information about fan speed reported by thermal controller.\n This structure is used by the ADL_Overdrive5_FanSpeed_Get() and ADL_Overdrive5_FanSpeed_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLFanSpeedValue {
    #[doc = " Must be set to the size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Possible valies: \\ref ADL_DL_FANCTRL_SPEED_TYPE_PERCENT or \\ref ADL_DL_FANCTRL_SPEED_TYPE_RPM"]
    pub iSpeedType: ::std::os::raw::c_int,
    #[doc = " Fan speed value"]
    pub iFanSpeed: ::std::os::raw::c_int,
    #[doc = " The only flag for now is: \\ref ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED"]
    pub iFlags: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing the range of Overdrive parameter.\n\n This structure is used to store information about the range of Overdrive parameter.\n This structure is used by ADLODParameters.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODParameterRange {
    #[doc = " Minimum parameter value."]
    pub iMin: ::std::os::raw::c_int,
    #[doc = " Maximum parameter value."]
    pub iMax: ::std::os::raw::c_int,
    #[doc = " Parameter step value."]
    pub iStep: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive parameters.\n\n This structure is used to store information about Overdrive parameters.\n This structure is used by the ADL_Overdrive5_ODParameters_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODParameters {
    #[doc = " Must be set to the size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Number of standard performance states."]
    pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
    #[doc = " Indicates whether the GPU is capable to measure its activity."]
    pub iActivityReportingSupported: ::std::os::raw::c_int,
    #[doc = " Indicates whether the GPU supports discrete performance levels or performance range."]
    pub iDiscretePerformanceLevels: ::std::os::raw::c_int,
    #[doc = " Reserved for future use."]
    pub iReserved: ::std::os::raw::c_int,
    #[doc = " Engine clock range."]
    pub sEngineClock: ADLODParameterRange,
    #[doc = " Memory clock range."]
    pub sMemoryClock: ADLODParameterRange,
    #[doc = " Core voltage range."]
    pub sVddc: ADLODParameterRange,
}
#[doc = "\n\\brief Structure containing information about Overdrive level.\n\n This structure is used to store information about Overdrive level.\n This structure is used by ADLODPerformanceLevels.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODPerformanceLevel {
    #[doc = " Engine clock."]
    pub iEngineClock: ::std::os::raw::c_int,
    #[doc = " Memory clock."]
    pub iMemoryClock: ::std::os::raw::c_int,
    #[doc = " Core voltage."]
    pub iVddc: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive performance levels.\n\n This structure is used to store information about Overdrive performance levels.\n This structure is used by the ADL_Overdrive5_ODPerformanceLevels_Get() and ADL_Overdrive5_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODPerformanceLevels {
    #[doc = " Must be set to sizeof( \\ref ADLODPerformanceLevels ) + sizeof( \\ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)"]
    pub iSize: ::std::os::raw::c_int,
    pub iReserved: ::std::os::raw::c_int,
    #[doc = " Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements."]
    pub aLevels: [ADLODPerformanceLevel; 1usize],
}
#[doc = "\n\\brief Structure containing information about the proper CrossfireX chains combinations.\n\n This structure is used to store information about the CrossfireX chains combination for a particular adapter.\n This structure is used by the ADL_Adapter_Crossfire_Caps(), ADL_Adapter_Crossfire_Get(), and ADL_Adapter_Crossfire_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLCrossfireComb {
    #[doc = " Number of adapters in this combination."]
    pub iNumLinkAdapter: ::std::os::raw::c_int,
    #[doc = " A list of ADL indexes of the linked adapters in this combination."]
    pub iAdaptLink: [::std::os::raw::c_int; 3usize],
}
#[doc = "\n\\brief Structure containing CrossfireX state and error information.\n\n This structure is used to store state and error information about a particular adapter CrossfireX combination.\n This structure is used by the ADL_Adapter_Crossfire_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLCrossfireInfo {
    #[doc = " Current error code of this CrossfireX combination."]
    pub iErrorCode: ::std::os::raw::c_int,
    #[doc = " Current \\ref define_crossfirestate"]
    pub iState: ::std::os::raw::c_int,
    #[doc = " If CrossfireX is supported by this combination. The value is either \\ref ADL_TRUE or \\ref ADL_FALSE."]
    pub iSupported: ::std::os::raw::c_int,
}
#[doc = "\n \\brief Structure containing information about the BIOS.\n\n This structure is used to store various information about the Chipset.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLBiosInfo {
    #[doc = "< Part number."]
    pub strPartNumber: [::std::os::raw::c_char; 256usize],
    #[doc = "< Version number."]
    pub strVersion: [::std::os::raw::c_char; 256usize],
    #[doc = "< BIOS date in yyyy/mm/dd hh:mm format."]
    pub strDate: [::std::os::raw::c_char; 256usize],
}
#[doc = "\n \\brief Structure containing information about adapter location.\n\n This structure is used to store information about adapter location.\n This structure is used by ADLMVPUStatus.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAdapterLocation {
    #[doc = " PCI Bus number : 8 bits"]
    pub iBus: ::std::os::raw::c_int,
    #[doc = " Device number : 5 bits"]
    pub iDevice: ::std::os::raw::c_int,
    #[doc = " Function number : 3 bits"]
    pub iFunction: ::std::os::raw::c_int,
}
#[doc = "\n \\brief Structure containing information about adapter location.\n\n This structure is used to store information about adapter location.\n This structure is used by ADLMVPUStatus.\n \\nosubgrouping\n"]
pub type ADLBdf = ADLAdapterLocation;
#[doc = "\n \\brief Structure containing version information\n\n This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLVersionsInfo {
    #[doc = " Driver Release (Packaging) Version (e.g. 8.71-100128n-094835E-ATI)"]
    pub strDriverVer: [::std::os::raw::c_char; 256usize],
    #[doc = " Catalyst Version(e.g. \"10.1\")."]
    pub strCatalystVersion: [::std::os::raw::c_char; 256usize],
    #[doc = " Web link to an XML file with information about the latest AMD drivers and locations (e.g. \"http://www.amd.com/us/driverxml\" )"]
    pub strCatalystWebLink: [::std::os::raw::c_char; 256usize],
}
#[doc = "\n \\brief Structure containing version information\n\n This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLVersionsInfoX2 {
    #[doc = " Driver Release (Packaging) Version (e.g. \"16.20.1035-160621a-303814C\")"]
    pub strDriverVer: [::std::os::raw::c_char; 256usize],
    #[doc = " Catalyst Version(e.g. \"15.8\")."]
    pub strCatalystVersion: [::std::os::raw::c_char; 256usize],
    #[doc = " Crimson Version(e.g. \"16.6.2\")."]
    pub strCrimsonVersion: [::std::os::raw::c_char; 256usize],
    #[doc = " Web link to an XML file with information about the latest AMD drivers and locations (e.g. \"http://support.amd.com/drivers/xml/driver_09_us.xml\" )"]
    pub strCatalystWebLink: [::std::os::raw::c_char; 256usize],
}
#[doc = "\n \\brief Structure containing information about MultiVPU capabilities.\n\n This structure is used to store information about MultiVPU capabilities.\n This structure is used by the ADL_Display_MVPUCaps_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMVPUCaps {
    #[doc = " Must be set to sizeof( ADLMVPUCaps )."]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Number of adapters."]
    pub iAdapterCount: ::std::os::raw::c_int,
    #[doc = " Bits set for all possible MVPU masters. \\ref MVPU_ADAPTER_0 .. \\ref MVPU_ADAPTER_3"]
    pub iPossibleMVPUMasters: ::std::os::raw::c_int,
    #[doc = " Bits set for all possible MVPU slaves. \\ref MVPU_ADAPTER_0 .. \\ref MVPU_ADAPTER_3"]
    pub iPossibleMVPUSlaves: ::std::os::raw::c_int,
    #[doc = " Registry path for each adapter."]
    pub cAdapterPath: [[::std::os::raw::c_char; 256usize]; 4usize],
}
#[doc = "\n \\brief Structure containing information about MultiVPU status.\n\n This structure is used to store information about MultiVPU status.\n Ths structure is used by the ADL_Display_MVPUStatus_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMVPUStatus {
    #[doc = " Must be set to sizeof( ADLMVPUStatus )."]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Number of active adapters."]
    pub iActiveAdapterCount: ::std::os::raw::c_int,
    #[doc = " MVPU status."]
    pub iStatus: ::std::os::raw::c_int,
    #[doc = " PCI Bus/Device/Function for each active adapter participating in MVPU."]
    pub aAdapterLocation: [ADLAdapterLocation; 4usize],
}
#[doc = "\n \\brief Structure containing information about the activatable source.\n\n This structure is used to store activatable source information\n This information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLActivatableSource {
    #[doc = " The Persistent logical Adapter Index."]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The number of Activatable Sources."]
    pub iNumActivatableSources: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the number of bits ActivatableSourceValue is using. (Not currently used)"]
    pub iActivatableSourceMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the status.  (Not currently used)"]
    pub iActivatableSourceValue: ::std::os::raw::c_int,
}
#[doc = "\n \\brief Structure containing information about display mode.\n\n This structure is used to store the display mode for the current adapter\n such as X, Y positions, screen resolutions, orientation,\n color depth, refresh rate, progressive or interlace mode, etc.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMode {
    #[doc = " Adapter index."]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " Display IDs."]
    pub displayID: ADLDisplayID,
    #[doc = " Screen position X coordinate."]
    pub iXPos: ::std::os::raw::c_int,
    #[doc = " Screen position Y coordinate."]
    pub iYPos: ::std::os::raw::c_int,
    #[doc = " Screen resolution Width."]
    pub iXRes: ::std::os::raw::c_int,
    #[doc = " Screen resolution Height."]
    pub iYRes: ::std::os::raw::c_int,
    #[doc = " Screen Color Depth. E.g., 16, 32."]
    pub iColourDepth: ::std::os::raw::c_int,
    #[doc = " Screen refresh rate. Could be fractional E.g. 59.97"]
    pub fRefreshRate: f32,
    #[doc = " Screen orientation. E.g., 0, 90, 180, 270."]
    pub iOrientation: ::std::os::raw::c_int,
    #[doc = " Vista mode flag indicating Progressive or Interlaced mode."]
    pub iModeFlag: ::std::os::raw::c_int,
    #[doc = " The bit mask identifying the number of bits this Mode is currently using. It is the sum of all the bit definitions defined in \\ref define_displaymode"]
    pub iModeMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifying the display status. The detailed definition is in  \\ref define_displaymode"]
    pub iModeValue: ::std::os::raw::c_int,
}
#[doc = "\n \\brief Structure containing information about display target information.\n\n This structure is used to store the display target information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayTarget {
    #[doc = " The Display ID."]
    pub displayID: ADLDisplayID,
    #[doc = " The display map index identify this manner and the desktop surface."]
    pub iDisplayMapIndex: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the number of bits DisplayTarget is currently using. It is the sum of all the bit definitions defined in \\ref ADL_DISPLAY_DISPLAYTARGET_PREFERRED."]
    pub iDisplayTargetMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the display status. The detailed definition is in \\ref ADL_DISPLAY_DISPLAYTARGET_PREFERRED."]
    pub iDisplayTargetValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the display SLS bezel Mode information.\n\n This structure is used to store the display SLS bezel Mode information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagADLBezelTransientMode {
    #[doc = " Adapter Index"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " SLS Map Index"]
    pub iSLSMapIndex: ::std::os::raw::c_int,
    #[doc = " The mode index"]
    pub iSLSModeIndex: ::std::os::raw::c_int,
    #[doc = " The mode"]
    pub displayMode: ADLMode,
    #[doc = " The number of bezel offsets belongs to this map"]
    pub iNumBezelOffset: ::std::os::raw::c_int,
    #[doc = " The first bezel offset array index in the native mode array"]
    pub iFirstBezelOffsetArrayIndex: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the bits this structure is currently using. It will be the total OR of all the bit definitions."]
    pub iSLSBezelTransientModeMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the display status. The detail definition is defined below."]
    pub iSLSBezelTransientModeValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the display SLS bezel Mode information.\n\n This structure is used to store the display SLS bezel Mode information.\n \\nosubgrouping\n"]
pub type ADLBezelTransientMode = tagADLBezelTransientMode;
#[doc = "\n \\brief Structure containing information about the adapter display manner.\n\n This structure is used to store adapter display manner information\n This information can be returned to the user. Alternatively, it can be used to access various driver calls to\n fetch various display device related display manner settings upon the user's request.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAdapterDisplayCap {
    #[doc = " The Persistent logical Adapter Index."]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the number of bits AdapterDisplayCap is currently using. Sum all the bits defined in ADL_ADAPTER_DISPLAYCAP_XXX"]
    pub iAdapterDisplayCapMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the status. Refer to ADL_ADAPTER_DISPLAYCAP_XXX"]
    pub iAdapterDisplayCapValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about display mapping.\n\n This structure is used to store the display mapping data such as display manner.\n For displays with horizontal or vertical stretch manner,\n this structure also stores the display order, display row, and column data.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayMap {
    #[doc = " The current display map index. It is the OS desktop index. For example, if the OS index 1 is showing clone mode, the display map will be 1."]
    pub iDisplayMapIndex: ::std::os::raw::c_int,
    #[doc = " The Display Mode for the current map"]
    pub displayMode: ADLMode,
    #[doc = " The number of display targets belongs to this map\\n"]
    pub iNumDisplayTarget: ::std::os::raw::c_int,
    #[doc = " The first target array index in the Target array\\n"]
    pub iFirstDisplayTargetArrayIndex: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the number of bits DisplayMap is currently using. It is the sum of all the bit definitions defined in ADL_DISPLAY_DISPLAYMAP_MANNER_xxx."]
    pub iDisplayMapMask: ::std::os::raw::c_int,
    #[doc = "The bit mask identifies the display status. The detailed definition is in ADL_DISPLAY_DISPLAYMAP_MANNER_xxx."]
    pub iDisplayMapValue: ::std::os::raw::c_int,
}
#[doc = "\n \\brief Structure containing information about the display device possible map for one GPU\n\n This structure is used to store the display device possible map\n This information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPossibleMap {
    #[doc = " The current PossibleMap index. Each PossibleMap is assigned an index"]
    pub iIndex: ::std::os::raw::c_int,
    #[doc = " The adapter index identifying the GPU for which to validate these Maps & Targets"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " Number of display Maps for this GPU to be validated"]
    pub iNumDisplayMap: ::std::os::raw::c_int,
    #[doc = " The display Maps list to validate"]
    pub displayMap: *mut ADLDisplayMap,
    #[doc = " the number of display Targets for these display Maps"]
    pub iNumDisplayTarget: ::std::os::raw::c_int,
    #[doc = " The display Targets list for these display Maps to be validated."]
    pub displayTarget: *mut ADLDisplayTarget,
}
#[doc = "\n \\brief Structure containing information about display possible mapping.\n\n This structure is used to store the display possible mapping's controller index for the current display.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPossibleMapping {
    #[doc = "< The display index. Each display is assigned an index."]
    pub iDisplayIndex: ::std::os::raw::c_int,
    #[doc = "< The controller index to which display is mapped."]
    pub iDisplayControllerIndex: ::std::os::raw::c_int,
    #[doc = "< The supported display manner."]
    pub iDisplayMannerSupported: ::std::os::raw::c_int,
}
#[doc = "\n \\brief Structure containing information about the validated display device possible map result.\n\n This structure is used to store the validated display device possible map result\n This information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPossibleMapResult {
    #[doc = " The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1."]
    pub iIndex: ::std::os::raw::c_int,
    pub iPossibleMapResultMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the possible map result. The detail definition is defined in ADL_DISPLAY_POSSIBLEMAPRESULT_XXX."]
    pub iPossibleMapResultValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the display SLS Grid information.\n\n This structure is used to store the display SLS Grid information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSLSGrid {
    #[doc = " The Adapter index."]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The grid index."]
    pub iSLSGridIndex: ::std::os::raw::c_int,
    #[doc = " The grid row."]
    pub iSLSGridRow: ::std::os::raw::c_int,
    #[doc = " The grid column."]
    pub iSLSGridColumn: ::std::os::raw::c_int,
    #[doc = " The grid bit mask identifies the number of bits DisplayMap is currently using. Sum of all bits defined in ADL_DISPLAY_SLSGRID_ORIENTATION_XXX"]
    pub iSLSGridMask: ::std::os::raw::c_int,
    #[doc = " The grid bit value identifies the display status. Refer to ADL_DISPLAY_SLSGRID_ORIENTATION_XXX"]
    pub iSLSGridValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the display SLS Map information.\n\n This structure is used to store the display SLS Map information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSLSMap {
    #[doc = " The Adapter Index"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1."]
    pub iSLSMapIndex: ::std::os::raw::c_int,
    #[doc = " Indicate the current grid"]
    pub grid: ADLSLSGrid,
    #[doc = " OS surface index"]
    pub iSurfaceMapIndex: ::std::os::raw::c_int,
    #[doc = "  Screen orientation. E.g., 0, 90, 180, 270"]
    pub iOrientation: ::std::os::raw::c_int,
    #[doc = " The number of display targets belongs to this map"]
    pub iNumSLSTarget: ::std::os::raw::c_int,
    #[doc = " The first target array index in the Target array"]
    pub iFirstSLSTargetArrayIndex: ::std::os::raw::c_int,
    #[doc = " The number of native modes belongs to this map"]
    pub iNumNativeMode: ::std::os::raw::c_int,
    #[doc = " The first native mode array index in the native mode array"]
    pub iFirstNativeModeArrayIndex: ::std::os::raw::c_int,
    #[doc = " The number of bezel modes belongs to this map"]
    pub iNumBezelMode: ::std::os::raw::c_int,
    #[doc = " The first bezel mode array index in the native mode array"]
    pub iFirstBezelModeArrayIndex: ::std::os::raw::c_int,
    #[doc = " The number of bezel offsets belongs to this map"]
    pub iNumBezelOffset: ::std::os::raw::c_int,
    #[doc = " The first bezel offset array index in the"]
    pub iFirstBezelOffsetArrayIndex: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the number of bits DisplayMap is currently using. Sum all the bit definitions defined in ADL_DISPLAY_SLSMAP_XXX."]
    pub iSLSMapMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the display map status. Refer to ADL_DISPLAY_SLSMAP_XXX"]
    pub iSLSMapValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the display SLS Offset information.\n\n This structure is used to store the display SLS Offset information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSLSOffset {
    #[doc = " The Adapter Index"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1."]
    pub iSLSMapIndex: ::std::os::raw::c_int,
    #[doc = " The Display ID."]
    pub displayID: ADLDisplayID,
    #[doc = " SLS Bezel Mode Index"]
    pub iBezelModeIndex: ::std::os::raw::c_int,
    #[doc = " SLS Bezel Offset X"]
    pub iBezelOffsetX: ::std::os::raw::c_int,
    #[doc = " SLS Bezel Offset Y"]
    pub iBezelOffsetY: ::std::os::raw::c_int,
    #[doc = " SLS Display Width"]
    pub iDisplayWidth: ::std::os::raw::c_int,
    #[doc = " SLS Display Height"]
    pub iDisplayHeight: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the number of bits Offset is currently using."]
    pub iBezelOffsetMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the display status."]
    pub iBezelffsetValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the display SLS Mode information.\n\n This structure is used to store the display SLS Mode information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSLSMode {
    #[doc = " The Adapter Index"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1."]
    pub iSLSMapIndex: ::std::os::raw::c_int,
    #[doc = " The mode index"]
    pub iSLSModeIndex: ::std::os::raw::c_int,
    #[doc = " The mode for this map."]
    pub displayMode: ADLMode,
    #[doc = " The bit mask identifies the number of bits Mode is currently using."]
    pub iSLSNativeModeMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the display status."]
    pub iSLSNativeModeValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the display Possible SLS Map information.\n\n This structure is used to store the display Possible SLS Map information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPossibleSLSMap {
    #[doc = " The current display map index. It is the OS Desktop index.\n For example, OS Index 1 showing clone mode. The Display Map will be 1."]
    pub iSLSMapIndex: ::std::os::raw::c_int,
    #[doc = " Number of display map to be validated."]
    pub iNumSLSMap: ::std::os::raw::c_int,
    #[doc = " The display map list for validation"]
    pub lpSLSMap: *mut ADLSLSMap,
    #[doc = " the number of display map config to be validated."]
    pub iNumSLSTarget: ::std::os::raw::c_int,
    #[doc = " The display target list for validation."]
    pub lpDisplayTarget: *mut ADLDisplayTarget,
}
#[doc = "\n\\brief Structure containing information about the SLS targets.\n\n This structure is used to store the SLS targets information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSLSTarget {
    #[doc = " the logic adapter index"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The SLS map index"]
    pub iSLSMapIndex: ::std::os::raw::c_int,
    #[doc = " The target ID"]
    pub displayTarget: ADLDisplayTarget,
    #[doc = " Target postion X in SLS grid"]
    pub iSLSGridPositionX: ::std::os::raw::c_int,
    #[doc = " Target postion Y in SLS grid"]
    pub iSLSGridPositionY: ::std::os::raw::c_int,
    #[doc = " The view size width, height and rotation angle per SLS Target"]
    pub viewSize: ADLMode,
    #[doc = " The bit mask identifies the bits in iSLSTargetValue are currently used"]
    pub iSLSTargetMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies status info. It is for function extension purpose"]
    pub iSLSTargetValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the Adapter offset stepping size.\n\n This structure is used to store the Adapter offset stepping size information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLBezelOffsetSteppingSize {
    #[doc = " the logic adapter index"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The SLS map index"]
    pub iSLSMapIndex: ::std::os::raw::c_int,
    #[doc = " Bezel X stepping size offset"]
    pub iBezelOffsetSteppingSizeX: ::std::os::raw::c_int,
    #[doc = " Bezel Y stepping size offset"]
    pub iBezelOffsetSteppingSizeY: ::std::os::raw::c_int,
    #[doc = " Identifies the bits this structure is currently using. It will be the total OR of all the bit definitions."]
    pub iBezelOffsetSteppingSizeMask: ::std::os::raw::c_int,
    #[doc = " Bit mask identifies the display status."]
    pub iBezelOffsetSteppingSizeValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the overlap offset info for all the displays for each SLS mode.\n\n This structure is used to store the no. of overlapped modes for each SLS Mode once user finishes the configuration from Overlap Widget\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSLSOverlappedMode {
    #[doc = " the SLS mode for which the overlap is configured"]
    pub SLSMode: ADLMode,
    #[doc = " the number of target displays in SLS."]
    pub iNumSLSTarget: ::std::os::raw::c_int,
    #[doc = " the first target array index in the target array"]
    pub iFirstTargetArrayIndex: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about the overlap offset info for all the displays for each SLS mode.\n\n This structure is used to store the no. of overlapped modes for each SLS Mode once user finishes the configuration from Overlap Widget\n \\nosubgrouping\n"]
pub type ADLSLSTargetOverlap = ADLSLSOverlappedMode;
#[doc = "\n\\brief Structure containing information about driver supported PowerExpress Config Caps\n\n This structure is used to store the driver supported PowerExpress Config Caps\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPXConfigCaps {
    #[doc = " The Persistent logical Adapter Index."]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the number of bits PowerExpress Config Caps is currently using. It is the sum of all the bit definitions defined in ADL_PX_CONFIGCAPS_XXXX /ref define_powerxpress_constants."]
    pub iPXConfigCapMask: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the PowerExpress Config Caps value. The detailed definition is in ADL_PX_CONFIGCAPS_XXXX /ref define_powerxpress_constants."]
    pub iPXConfigCapValue: ::std::os::raw::c_int,
}
impl ADLPxType {
    pub const ADL_PX_NONE: ADLPxType = ADLPxType(0);
}
impl ADLPxType {
    pub const ADL_SWITCHABLE_AMDAMD: ADLPxType = ADLPxType(1);
}
impl ADLPxType {
    pub const ADL_HG_AMDAMD: ADLPxType = ADLPxType(2);
}
impl ADLPxType {
    pub const ADL_SWITCHABLE_AMDOTHER: ADLPxType = ADLPxType(3);
}
impl ADLPxType {
    pub const ADL_HG_AMDOTHER: ADLPxType = ADLPxType(4);
}
#[repr(transparent)]
#[doc = "\n\\brief Enum containing PX or HG type\n\n This enum is used to get PX or hG type\n\n \\nosubgrouping\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLPxType(pub ::std::os::raw::c_int);
#[doc = "\n\\brief Structure containing information about an application\n\n This structure is used to store basic information of an application\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLApplicationData {
    #[doc = " Path Name"]
    pub strPathName: [::std::os::raw::c_char; 256usize],
    #[doc = " File Name"]
    pub strFileName: [::std::os::raw::c_char; 256usize],
    #[doc = " Creation timestamp"]
    pub strTimeStamp: [::std::os::raw::c_char; 32usize],
    #[doc = " Version"]
    pub strVersion: [::std::os::raw::c_char; 32usize],
}
#[doc = "\n\\brief Structure containing information about an application\n\n This structure is used to store basic information of an application\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLApplicationDataX2 {
    #[doc = " Path Name"]
    pub strPathName: [u16; 256usize],
    #[doc = " File Name"]
    pub strFileName: [u16; 256usize],
    #[doc = " Creation timestamp"]
    pub strTimeStamp: [u16; 32usize],
    #[doc = " Version"]
    pub strVersion: [u16; 32usize],
}
#[doc = "\n\\brief Structure containing information about an application\n\n This structure is used to store basic information of an application including process id\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLApplicationDataX3 {
    #[doc = " Path Name"]
    pub strPathName: [u16; 256usize],
    #[doc = " File Name"]
    pub strFileName: [u16; 256usize],
    #[doc = " Creation timestamp"]
    pub strTimeStamp: [u16; 32usize],
    #[doc = " Version"]
    pub strVersion: [u16; 32usize],
    pub iProcessId: ::std::os::raw::c_uint,
}
#[doc = "\n\\brief Structure containing information of a property of an application profile\n\n This structure is used to store property information of an application profile\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PropertyRecord {
    #[doc = " Property Name"]
    pub strName: [::std::os::raw::c_char; 64usize],
    #[doc = " Property Type"]
    pub eType: ADLProfilePropertyType,
    #[doc = " Data Size in bytes"]
    pub iDataSize: ::std::os::raw::c_int,
    #[doc = " Property Value, can be any data type"]
    pub uData: [::std::os::raw::c_uchar; 1usize],
}
#[doc = "\n\\brief Structure containing information about an application profile\n\n This structure is used to store information of an application profile\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLApplicationProfile {
    #[doc = " Number of properties"]
    pub iCount: ::std::os::raw::c_int,
    #[doc = " Buffer to store all property records"]
    pub record: [PropertyRecord; 1usize],
}
#[doc = "\n\\brief Structure containing information about an OD5 Power Control feature\n\n This structure is used to store information of an Power Control feature\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPowerControlInfo {
    #[doc = " Minimum value."]
    pub iMinValue: ::std::os::raw::c_int,
    #[doc = " Maximum value."]
    pub iMaxValue: ::std::os::raw::c_int,
    #[doc = " The minimum change in between minValue and maxValue."]
    pub iStepValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about an controller mode\n\n This structure is used to store information of an controller mode\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLControllerMode {
    #[doc = " This flag indicates actions that will be applied by set viewport\n The value can be a combination of ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_POSITION,\n ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_PANLOCK and ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_SIZE"]
    pub iModifiers: ::std::os::raw::c_int,
    #[doc = " Horizontal view starting position"]
    pub iViewPositionCx: ::std::os::raw::c_int,
    #[doc = " Vertical view starting position"]
    pub iViewPositionCy: ::std::os::raw::c_int,
    #[doc = " Horizontal left panlock position"]
    pub iViewPanLockLeft: ::std::os::raw::c_int,
    #[doc = " Horizontal right panlock position"]
    pub iViewPanLockRight: ::std::os::raw::c_int,
    #[doc = " Vertical top panlock position"]
    pub iViewPanLockTop: ::std::os::raw::c_int,
    #[doc = " Vertical bottom panlock position"]
    pub iViewPanLockBottom: ::std::os::raw::c_int,
    #[doc = " View resolution in pixels (width)"]
    pub iViewResolutionCx: ::std::os::raw::c_int,
    #[doc = " View resolution in pixels (hight)"]
    pub iViewResolutionCy: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about a display\n\n This structure is used to store information about a display\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayIdentifier {
    #[doc = " ADL display index"]
    pub ulDisplayIndex: ::std::os::raw::c_long,
    #[doc = " manufacturer ID of the display"]
    pub ulManufacturerId: ::std::os::raw::c_long,
    #[doc = " product ID of the display"]
    pub ulProductId: ::std::os::raw::c_long,
    #[doc = " serial number of the display"]
    pub ulSerialNo: ::std::os::raw::c_long,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 clock range\n\n This structure is used to store information about Overdrive 6 clock range\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6ParameterRange {
    #[doc = " The starting value of the clock range"]
    pub iMin: ::std::os::raw::c_int,
    #[doc = " The ending value of the clock range"]
    pub iMax: ::std::os::raw::c_int,
    #[doc = " The minimum increment between clock values"]
    pub iStep: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 capabilities\n\n This structure is used to store information about Overdrive 6 capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6Capabilities {
    #[doc = " Contains a bitmap of the OD6 capability flags.  Possible values: \\ref ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION,\n \\ref ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION, \\ref ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR"]
    pub iCapabilities: ::std::os::raw::c_int,
    #[doc = " Contains a bitmap indicating the power states\n supported by OD6.  Currently only the performance state\n is supported. Possible Values: \\ref ADL_OD6_SUPPORTEDSTATE_PERFORMANCE"]
    pub iSupportedStates: ::std::os::raw::c_int,
    #[doc = " Number of levels. OD6 will always use 2 levels, which describe\n the minimum to maximum clock ranges.\n The 1st level indicates the minimum clocks, and the 2nd level\n indicates the maximum clocks."]
    pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
    #[doc = " Contains the hard limits of the sclk range.  Overdrive\n clocks cannot be set outside this range."]
    pub sEngineClockRange: ADLOD6ParameterRange,
    #[doc = " Contains the hard limits of the mclk range.  Overdrive\n clocks cannot be set outside this range."]
    pub sMemoryClockRange: ADLOD6ParameterRange,
    #[doc = " Value for future extension"]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Mask for future extension"]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 clock values.\n\n This structure is used to store information about Overdrive 6 clock values.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6PerformanceLevel {
    #[doc = " Engine (core) clock."]
    pub iEngineClock: ::std::os::raw::c_int,
    #[doc = " Memory clock."]
    pub iMemoryClock: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 clocks.\n\n This structure is used to store information about Overdrive 6 clocks.  This is a\n variable-sized structure.  iNumberOfPerformanceLevels indicate how many elements\n are contained in the aLevels array.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6StateInfo {
    #[doc = " Number of levels.  OD6 uses clock ranges instead of discrete performance levels.\n iNumberOfPerformanceLevels is always 2.  The 1st level indicates the minimum clocks\n in the range.  The 2nd level indicates the maximum clocks in the range."]
    pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
    #[doc = " Value for future extension"]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Mask for future extension"]
    pub iExtMask: ::std::os::raw::c_int,
    #[doc = " Variable-sized array of levels.\n The number of elements in the array is specified by iNumberofPerformanceLevels."]
    pub aLevels: [ADLOD6PerformanceLevel; 1usize],
}
#[doc = "\n\\brief Structure containing information about current Overdrive 6 performance status.\n\n This structure is used to store information about current Overdrive 6 performance status.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6CurrentStatus {
    #[doc = " Current engine clock in 10 KHz."]
    pub iEngineClock: ::std::os::raw::c_int,
    #[doc = " Current memory clock in 10 KHz."]
    pub iMemoryClock: ::std::os::raw::c_int,
    #[doc = " Current GPU activity in percent.  This\n indicates how \"busy\" the GPU is."]
    pub iActivityPercent: ::std::os::raw::c_int,
    #[doc = " Not used.  Reserved for future use."]
    pub iCurrentPerformanceLevel: ::std::os::raw::c_int,
    #[doc = " Current PCI-E bus speed"]
    pub iCurrentBusSpeed: ::std::os::raw::c_int,
    #[doc = " Current PCI-E bus # of lanes"]
    pub iCurrentBusLanes: ::std::os::raw::c_int,
    #[doc = " Maximum possible PCI-E bus # of lanes"]
    pub iMaximumBusLanes: ::std::os::raw::c_int,
    #[doc = " Value for future extension"]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Mask for future extension"]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 thermal controller capabilities\n\n This structure is used to store information about Overdrive 6 thermal controller capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6ThermalControllerCaps {
    #[doc = " Contains a bitmap of thermal controller capability flags. Possible values: \\ref ADL_OD6_TCCAPS_THERMAL_CONTROLLER, \\ref ADL_OD6_TCCAPS_FANSPEED_CONTROL,\n \\ref ADL_OD6_TCCAPS_FANSPEED_PERCENT_READ, \\ref ADL_OD6_TCCAPS_FANSPEED_PERCENT_WRITE, \\ref ADL_OD6_TCCAPS_FANSPEED_RPM_READ, \\ref ADL_OD6_TCCAPS_FANSPEED_RPM_WRITE"]
    pub iCapabilities: ::std::os::raw::c_int,
    #[doc = " Minimum fan speed expressed as a percentage"]
    pub iFanMinPercent: ::std::os::raw::c_int,
    #[doc = " Maximum fan speed expressed as a percentage"]
    pub iFanMaxPercent: ::std::os::raw::c_int,
    #[doc = " Minimum fan speed expressed in revolutions-per-minute"]
    pub iFanMinRPM: ::std::os::raw::c_int,
    #[doc = " Maximum fan speed expressed in revolutions-per-minute"]
    pub iFanMaxRPM: ::std::os::raw::c_int,
    #[doc = " Value for future extension"]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Mask for future extension"]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 fan speed information\n\n This structure is used to store information about Overdrive 6 fan speed information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6FanSpeedInfo {
    #[doc = " Contains a bitmap of the valid fan speed type flags.  Possible values: \\ref ADL_OD6_FANSPEED_TYPE_PERCENT, \\ref ADL_OD6_FANSPEED_TYPE_RPM, \\ref ADL_OD6_FANSPEED_USER_DEFINED"]
    pub iSpeedType: ::std::os::raw::c_int,
    #[doc = " Contains current fan speed in percent (if valid flag exists in iSpeedType)"]
    pub iFanSpeedPercent: ::std::os::raw::c_int,
    #[doc = " Contains current fan speed in RPM (if valid flag exists in iSpeedType)"]
    pub iFanSpeedRPM: ::std::os::raw::c_int,
    #[doc = " Value for future extension"]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Mask for future extension"]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 fan speed value\n\n This structure is used to store information about Overdrive 6 fan speed value\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6FanSpeedValue {
    #[doc = " Indicates the units of the fan speed.  Possible values: \\ref ADL_OD6_FANSPEED_TYPE_PERCENT, \\ref ADL_OD6_FANSPEED_TYPE_RPM"]
    pub iSpeedType: ::std::os::raw::c_int,
    #[doc = " Fan speed value (units as indicated above)"]
    pub iFanSpeed: ::std::os::raw::c_int,
    #[doc = " Value for future extension"]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Mask for future extension"]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 PowerControl settings.\n\n This structure is used to store information about Overdrive 6 PowerControl settings.\n PowerControl is the feature which allows the performance characteristics of the GPU\n to be adjusted by changing the PowerTune power limits.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6PowerControlInfo {
    #[doc = " The minimum PowerControl adjustment value"]
    pub iMinValue: ::std::os::raw::c_int,
    #[doc = " The maximum PowerControl adjustment value"]
    pub iMaxValue: ::std::os::raw::c_int,
    #[doc = " The minimum difference between PowerControl adjustment values"]
    pub iStepValue: ::std::os::raw::c_int,
    #[doc = " Value for future extension"]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Mask for future extension"]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 PowerControl settings.\n\n This structure is used to store information about Overdrive 6 PowerControl settings.\n PowerControl is the feature which allows the performance characteristics of the GPU\n to be adjusted by changing the PowerTune power limits.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6VoltageControlInfo {
    #[doc = " The minimum VoltageControl adjustment value"]
    pub iMinValue: ::std::os::raw::c_int,
    #[doc = " The maximum VoltageControl adjustment value"]
    pub iMaxValue: ::std::os::raw::c_int,
    #[doc = " The minimum difference between VoltageControl adjustment values"]
    pub iStepValue: ::std::os::raw::c_int,
    #[doc = " Value for future extension"]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Mask for future extension"]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing ECC statistics namely SEC counts and DED counts\n Single error count - count of errors that can be corrected\n Doubt Error Detect -  count of errors that cannot be corrected\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLECCData {
    pub iSec: ::std::os::raw::c_int,
    pub iDed: ::std::os::raw::c_int,
}
#[doc = " \\brief Handle to ADL client context.\n\n  ADL clients obtain context handle from initial call to \\ref ADL2_Main_Control_Create.\n  Clients have to pass the handle to each subsequent ADL call and finally destroy\n  the context with call to \\ref ADL2_Main_Control_Destroy\n \\nosubgrouping"]
pub type ADL_CONTEXT_HANDLE = *mut ::std::os::raw::c_void;
#[doc = " \\brief Handle to ADL Frame Monitor Token.\n\n  Frame Monitor clients obtain handle from initial call to \\ref ADL2_Adapter_FrameMetrics_FrameDuration_Enable\n  Clients have to pass the handle to each subsequent ADL call to \\ref ADL2_Adapter_FrameMetrics_FrameDuration_Get\n  and finally destroy the token with call to \\ref ADL2_Adapter_FrameMetrics_FrameDuration_Disable\n \\nosubgrouping"]
pub type ADL_FRAME_DURATION_HANDLE = *mut ::std::os::raw::c_void;
#[doc = "\n\\brief Structure containing the display mode definition used per controller.\n\n This structure is used to store the display mode definition used per controller.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayModeX2 {
    #[doc = " Horizontal resolution (in pixels)."]
    pub iWidth: ::std::os::raw::c_int,
    #[doc = " Vertical resolution (in lines)."]
    pub iHeight: ::std::os::raw::c_int,
    #[doc = " Interlaced/Progressive. The value will be set for Interlaced as ADL_DL_TIMINGFLAG_INTERLACED. If not set it is progressive. Refer define_detailed_timing_flags."]
    pub iScanType: ::std::os::raw::c_int,
    #[doc = " Refresh rate."]
    pub iRefreshRate: ::std::os::raw::c_int,
    #[doc = " Timing Standard. Refer define_modetiming_standard."]
    pub iTimingStandard: ::std::os::raw::c_int,
}
impl ADLAppProcessState {
    pub const APP_PROC_INVALID: ADLAppProcessState = ADLAppProcessState(0);
}
impl ADLAppProcessState {
    pub const APP_PROC_PREMPTION: ADLAppProcessState = ADLAppProcessState(1);
}
impl ADLAppProcessState {
    pub const APP_PROC_CREATION: ADLAppProcessState = ADLAppProcessState(2);
}
impl ADLAppProcessState {
    pub const APP_PROC_READ: ADLAppProcessState = ADLAppProcessState(3);
}
impl ADLAppProcessState {
    pub const APP_PROC_WAIT: ADLAppProcessState = ADLAppProcessState(4);
}
impl ADLAppProcessState {
    pub const APP_PROC_RUNNING: ADLAppProcessState = ADLAppProcessState(5);
}
impl ADLAppProcessState {
    pub const APP_PROC_TERMINATE: ADLAppProcessState = ADLAppProcessState(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLAppProcessState(pub ::std::os::raw::c_int);
impl ADLAppInterceptionListType {
    pub const ADL_INVALID_FORMAT: ADLAppInterceptionListType = ADLAppInterceptionListType(0);
}
impl ADLAppInterceptionListType {
    pub const ADL_IMAGEFILEFORMAT: ADLAppInterceptionListType = ADLAppInterceptionListType(1);
}
impl ADLAppInterceptionListType {
    pub const ADL_ENVVAR: ADLAppInterceptionListType = ADLAppInterceptionListType(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLAppInterceptionListType(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAppInterceptionInfo {
    pub AppName: [u16; 256usize],
    pub ProcessId: ::std::os::raw::c_uint,
    pub AppFormat: ADLAppInterceptionListType,
    pub AppState: ADLAppProcessState,
}
impl ADL_AP_DATABASE {
    pub const ADL_AP_DATABASE__SYSTEM: ADL_AP_DATABASE = ADL_AP_DATABASE(0);
}
impl ADL_AP_DATABASE {
    pub const ADL_AP_DATABASE__USER: ADL_AP_DATABASE = ADL_AP_DATABASE(1);
}
impl ADL_AP_DATABASE {
    pub const ADL_AP_DATABASE__OEM: ADL_AP_DATABASE = ADL_AP_DATABASE(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_AP_DATABASE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAppInterceptionInfoX2 {
    pub AppName: [u16; 256usize],
    pub ProcessId: ::std::os::raw::c_uint,
    pub WaitForResumeNeeded: ::std::os::raw::c_uint,
    pub CommandLine: [u16; 256usize],
    pub AppFormat: ADLAppInterceptionListType,
    pub AppState: ADLAppProcessState,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAppInterceptionInfoX3 {
    pub AppName: [u16; 256usize],
    pub ProcessId: ::std::os::raw::c_uint,
    pub WaitForResumeNeeded: ::std::os::raw::c_uint,
    pub RayTracingStatus: ::std::os::raw::c_uint,
    pub CommandLine: [u16; 256usize],
    pub AppFormat: ADLAppInterceptionListType,
    pub AppState: ADLAppProcessState,
}
#[doc = "\n\\brief Structure containing information info for a property record in a profile\n\n This structure is used to store info for a property record in a profile\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPropertyRecordCreate {
    #[doc = " Name of the property"]
    pub strPropertyName: *mut u16,
    #[doc = " Data type of the property"]
    pub eType: ADLProfilePropertyType,
    pub strPropertyValue: *mut u16,
}
#[doc = "\n\\brief Structure containing information info for an application record\n\n This structure is used to store info for an application record\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLApplicationRecord {
    #[doc = " Title of the application"]
    pub strTitle: *mut u16,
    #[doc = " File path of the application"]
    pub strPathName: *mut u16,
    #[doc = " File name of the application"]
    pub strFileName: *mut u16,
    #[doc = " File versin the application"]
    pub strVersion: *mut u16,
    #[doc = " Nostes on the application"]
    pub strNotes: *mut u16,
    #[doc = " Driver area which the application uses"]
    pub strArea: *mut u16,
    #[doc = " Name of profile assigned to the application"]
    pub strProfileName: *mut u16,
    pub recordSource: ADL_AP_DATABASE,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 extension capabilities\n\n This structure is used to store information about Overdrive 6 extension capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6CapabilitiesEx {
    #[doc = " Contains a bitmap of the OD6 extension capability flags.  Possible values: \\ref ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION,\n \\ref ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION, \\ref ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR,\n \\ref ADL_OD6_CAPABILITY_POWER_CONTROL, \\ref ADL_OD6_CAPABILITY_VOLTAGE_CONTROL, \\ref ADL_OD6_CAPABILITY_PERCENT_ADJUSTMENT,\n \\ref ADL_OD6_CAPABILITY_THERMAL_LIMIT_UNLOCK"]
    pub iCapabilities: ::std::os::raw::c_int,
    #[doc = " The Power states that support clock and power customization.  Only performance state is currently supported.\n Possible Values: \\ref ADL_OD6_SUPPORTEDSTATE_PERFORMANCE"]
    pub iSupportedStates: ::std::os::raw::c_int,
    #[doc = " Returns the hard limits of the SCLK overdrive adjustment range.  Overdrive clocks should not be adjusted outside of this range.  The values are specified as +/- percentages."]
    pub sEngineClockPercent: ADLOD6ParameterRange,
    #[doc = " Returns the hard limits of the MCLK overdrive adjustment range.  Overdrive clocks should not be adjusted outside of this range.  The values are specified as +/- percentages."]
    pub sMemoryClockPercent: ADLOD6ParameterRange,
    #[doc = " Returns the hard limits of the Power Limit adjustment range.  Power limit should not be adjusted outside this range.  The values are specified as +/- percentages."]
    pub sPowerControlPercent: ADLOD6ParameterRange,
    #[doc = " Reserved for future expansion of the structure."]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Reserved for future expansion of the structure."]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 extension state information\n\n This structure is used to store information about Overdrive 6 extension state information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6StateEx {
    #[doc = " The current engine clock adjustment value, specified as a +/- percent."]
    pub iEngineClockPercent: ::std::os::raw::c_int,
    #[doc = " The current memory clock adjustment value, specified as a +/- percent."]
    pub iMemoryClockPercent: ::std::os::raw::c_int,
    #[doc = " The current power control adjustment value, specified as a +/- percent."]
    pub iPowerControlPercent: ::std::os::raw::c_int,
    #[doc = " Reserved for future expansion of the structure."]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Reserved for future expansion of the structure."]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive 6 extension recommended maximum clock adjustment values\n\n This structure is used to store information about Overdrive 6 extension recommended maximum clock adjustment values\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD6MaxClockAdjust {
    #[doc = " The recommended maximum engine clock adjustment in percent, for the specified power limit value."]
    pub iEngineClockMax: ::std::os::raw::c_int,
    #[doc = " The recommended maximum memory clock adjustment in percent, for the specified power limit value.\n Currently the memory is independent of the Power Limit setting, so iMemoryClockMax will always return the maximum\n possible adjustment value.  This field is here for future enhancement in case we add a dependency between Memory Clock\n adjustment and Power Limit setting."]
    pub iMemoryClockMax: ::std::os::raw::c_int,
    #[doc = " Reserved for future expansion of the structure."]
    pub iExtValue: ::std::os::raw::c_int,
    #[doc = " Reserved for future expansion of the structure."]
    pub iExtMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing the Connector information\n\n this structure is used to get the connector information like length, positions & etc.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLConnectorInfo {
    #[doc = "index of the connector(0-based)"]
    pub iConnectorIndex: ::std::os::raw::c_int,
    #[doc = "used for display identification/ordering"]
    pub iConnectorId: ::std::os::raw::c_int,
    #[doc = "index of the slot, 0-based index."]
    pub iSlotIndex: ::std::os::raw::c_int,
    #[doc = "Type of the connector. \\ref define_connector_types"]
    pub iType: ::std::os::raw::c_int,
    #[doc = "Position of the connector(in millimeters), from the right side of the slot."]
    pub iOffset: ::std::os::raw::c_int,
    #[doc = "Length of the connector(in millimeters)."]
    pub iLength: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing the slot information\n\n this structure is used to get the slot information like length of the slot, no of connectors on the slot & etc.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLBracketSlotInfo {
    #[doc = "index of the slot, 0-based index."]
    pub iSlotIndex: ::std::os::raw::c_int,
    #[doc = "length of the slot(in millimeters)."]
    pub iLength: ::std::os::raw::c_int,
    #[doc = "width of the slot(in millimeters)."]
    pub iWidth: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing MST branch information\n\n this structure is used to store the MST branch information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMSTRad {
    #[doc = "depth of the link."]
    pub iLinkNumber: ::std::os::raw::c_int,
    #[doc = " Relative address, address scheme starts from source side"]
    pub rad: [::std::os::raw::c_char; 15usize],
}
#[doc = "\n\\brief Structure containing port information\n\n this structure is used to get the display or MST branch information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDevicePort {
    #[doc = "index of the connector."]
    pub iConnectorIndex: ::std::os::raw::c_int,
    #[doc = "Relative MST address. If MST RAD contains 0 it means DP or Root of the MST topology. For non DP connectors MST RAD is ignored."]
    pub aMSTRad: ADLMSTRad,
}
#[doc = "\n\\brief Structure containing supported connection types and properties\n\n this structure is used to get the supported connection types and supported properties of given connector\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSupportedConnections {
    #[doc = "Bit vector of supported connections. Bitmask is defined in constants section. \\ref define_connection_types"]
    pub iSupportedConnections: ::std::os::raw::c_int,
    #[doc = "Array of bitvectors. Each bit vector represents supported properties for one connection type. Index of this array is connection type (bit number in mask)."]
    pub iSupportedProperties: [::std::os::raw::c_int; 32usize],
}
#[doc = "\n\\brief Structure containing connection state of the connector\n\n this structure is used to get the current Emulation status and mode of the given connector\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLConnectionState {
    #[doc = "The value is bit vector. Each bit represents status. See masks constants for details. \\ref define_emulation_status"]
    pub iEmulationStatus: ::std::os::raw::c_int,
    #[doc = "It contains information about current emulation mode. See constants for details. \\ref define_emulation_mode"]
    pub iEmulationMode: ::std::os::raw::c_int,
    #[doc = "If connection is active it will contain display id, otherwise CWDDEDI_INVALID_DISPLAY_INDEX"]
    pub iDisplayIndex: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing connection properties information\n\n this structure is used to retrieve the properties of connection type\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLConnectionProperties {
    pub iValidProperties: ::std::os::raw::c_int,
    pub iBitrate: ::std::os::raw::c_int,
    pub iNumberOfLanes: ::std::os::raw::c_int,
    pub iColorDepth: ::std::os::raw::c_int,
    pub iStereo3DCaps: ::std::os::raw::c_int,
    #[doc = "Output Bandwidth. Could be used for MST branch, DP or DP Active dongle. \\ref define_linkrate_constants"]
    pub iOutputBandwidth: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing connection information\n\n this structure is used to retrieve the data from driver which includes\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLConnectionData {
    #[doc = "Connection type. based on the connection type either iNumberofPorts or IDataSize,EDIDdata is valid, \\ref define_connection_types"]
    pub iConnectionType: ::std::os::raw::c_int,
    #[doc = "Specifies the connection properties."]
    pub aConnectionProperties: ADLConnectionProperties,
    #[doc = "Number of ports"]
    pub iNumberofPorts: ::std::os::raw::c_int,
    #[doc = "Number of Active Connections"]
    pub iActiveConnections: ::std::os::raw::c_int,
    #[doc = "actual size of EDID data block size."]
    pub iDataSize: ::std::os::raw::c_int,
    #[doc = "EDID Data"]
    pub EdidData: [::std::os::raw::c_char; 1024usize],
}
#[doc = "\n\\brief Structure containing information about an controller mode including Number of Connectors\n\n This structure is used to store information of an controller mode\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLAdapterCapsX2 {
    #[doc = " AdapterID for this adapter"]
    pub iAdapterID: ::std::os::raw::c_int,
    #[doc = " Number of controllers for this adapter"]
    pub iNumControllers: ::std::os::raw::c_int,
    #[doc = " Number of displays for this adapter"]
    pub iNumDisplays: ::std::os::raw::c_int,
    #[doc = " Number of overlays for this adapter"]
    pub iNumOverlays: ::std::os::raw::c_int,
    #[doc = " Number of GLSyncConnectors"]
    pub iNumOfGLSyncConnectors: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the adapter caps"]
    pub iCapsMask: ::std::os::raw::c_int,
    #[doc = " The bit identifies the adapter caps \\ref define_adapter_caps"]
    pub iCapsValue: ::std::os::raw::c_int,
    #[doc = " Number of Connectors for this adapter"]
    pub iNumConnectors: ::std::os::raw::c_int,
}
impl ADL_ERROR_RECORD_SEVERITY {
    pub const ADL_GLOBALLY_UNCORRECTED: ADL_ERROR_RECORD_SEVERITY = ADL_ERROR_RECORD_SEVERITY(1);
}
impl ADL_ERROR_RECORD_SEVERITY {
    pub const ADL_LOCALLY_UNCORRECTED: ADL_ERROR_RECORD_SEVERITY = ADL_ERROR_RECORD_SEVERITY(2);
}
impl ADL_ERROR_RECORD_SEVERITY {
    pub const ADL_DEFERRED: ADL_ERROR_RECORD_SEVERITY = ADL_ERROR_RECORD_SEVERITY(3);
}
impl ADL_ERROR_RECORD_SEVERITY {
    pub const ADL_CORRECTED: ADL_ERROR_RECORD_SEVERITY = ADL_ERROR_RECORD_SEVERITY(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_ERROR_RECORD_SEVERITY(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ADL_ECC_EDC_FLAG {
    pub bits: _ADL_ECC_EDC_FLAG__bindgen_ty_1,
    pub u32All: ::std::os::raw::c_uint,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct _ADL_ECC_EDC_FLAG__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _ADL_ECC_EDC_FLAG__bindgen_ty_1 {
    #[inline]
    pub fn isEccAccessing(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isEccAccessing(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isEccAccessing: ::std::os::raw::c_uint,
        reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isEccAccessing: u32 = unsafe { ::std::mem::transmute(isEccAccessing) };
            isEccAccessing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ADL_ECC_EDC_FLAG = _ADL_ECC_EDC_FLAG;
#[doc = "\n\\brief Structure containing information about EDC Error Record\n\n This structure is used to store EDC Error Record\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLErrorRecord {
    pub Severity: ADL_ERROR_RECORD_SEVERITY,
    pub countValid: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_uint,
    pub locationValid: ::std::os::raw::c_int,
    pub CU: ::std::os::raw::c_uint,
    pub StructureName: [::std::os::raw::c_char; 32usize],
    pub tiestamp: [::std::os::raw::c_char; 32usize],
    pub padding: [::std::os::raw::c_uint; 3usize],
}
impl ADL_EDC_BLOCK_ID {
    pub const ADL_EDC_BLOCK_ID_SQCIS: ADL_EDC_BLOCK_ID = ADL_EDC_BLOCK_ID(1);
}
impl ADL_EDC_BLOCK_ID {
    pub const ADL_EDC_BLOCK_ID_SQCDS: ADL_EDC_BLOCK_ID = ADL_EDC_BLOCK_ID(2);
}
impl ADL_EDC_BLOCK_ID {
    pub const ADL_EDC_BLOCK_ID_SGPR: ADL_EDC_BLOCK_ID = ADL_EDC_BLOCK_ID(3);
}
impl ADL_EDC_BLOCK_ID {
    pub const ADL_EDC_BLOCK_ID_VGPR: ADL_EDC_BLOCK_ID = ADL_EDC_BLOCK_ID(4);
}
impl ADL_EDC_BLOCK_ID {
    pub const ADL_EDC_BLOCK_ID_LDS: ADL_EDC_BLOCK_ID = ADL_EDC_BLOCK_ID(5);
}
impl ADL_EDC_BLOCK_ID {
    pub const ADL_EDC_BLOCK_ID_GDS: ADL_EDC_BLOCK_ID = ADL_EDC_BLOCK_ID(6);
}
impl ADL_EDC_BLOCK_ID {
    pub const ADL_EDC_BLOCK_ID_TCL1: ADL_EDC_BLOCK_ID = ADL_EDC_BLOCK_ID(7);
}
impl ADL_EDC_BLOCK_ID {
    pub const ADL_EDC_BLOCK_ID_TCL2: ADL_EDC_BLOCK_ID = ADL_EDC_BLOCK_ID(8);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_EDC_BLOCK_ID(pub ::std::os::raw::c_int);
impl ADL_ERROR_INJECTION_MODE {
    pub const ADL_ERROR_INJECTION_MODE_SINGLE: ADL_ERROR_INJECTION_MODE =
        ADL_ERROR_INJECTION_MODE(1);
}
impl ADL_ERROR_INJECTION_MODE {
    pub const ADL_ERROR_INJECTION_MODE_MULTIPLE: ADL_ERROR_INJECTION_MODE =
        ADL_ERROR_INJECTION_MODE(2);
}
impl ADL_ERROR_INJECTION_MODE {
    pub const ADL_ERROR_INJECTION_MODE_ADDRESS: ADL_ERROR_INJECTION_MODE =
        ADL_ERROR_INJECTION_MODE(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADL_ERROR_INJECTION_MODE(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ADL_ERROR_PATTERN {
    pub bits: _ADL_ERROR_PATTERN__bindgen_ty_1,
    pub u64Value: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct _ADL_ERROR_PATTERN__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
impl _ADL_ERROR_PATTERN__bindgen_ty_1 {
    #[inline]
    pub fn EccInjVector(&self) -> ::std::os::raw::c_ulong {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_EccInjVector(&mut self, val: ::std::os::raw::c_ulong) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn EccInjEn(&self) -> ::std::os::raw::c_ulong {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_EccInjEn(&mut self, val: ::std::os::raw::c_ulong) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn EccBeatEn(&self) -> ::std::os::raw::c_ulong {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EccBeatEn(&mut self, val: ::std::os::raw::c_ulong) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn EccChEn(&self) -> ::std::os::raw::c_ulong {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EccChEn(&mut self, val: ::std::os::raw::c_ulong) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_ulong {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_ulong) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EccInjVector: ::std::os::raw::c_ulong,
        EccInjEn: ::std::os::raw::c_ulong,
        EccBeatEn: ::std::os::raw::c_ulong,
        EccChEn: ::std::os::raw::c_ulong,
        reserved: ::std::os::raw::c_ulong,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let EccInjVector: u32 = unsafe { ::std::mem::transmute(EccInjVector) };
            EccInjVector as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let EccInjEn: u32 = unsafe { ::std::mem::transmute(EccInjEn) };
            EccInjEn as u64
        });
        __bindgen_bitfield_unit.set(25usize, 4u8, {
            let EccBeatEn: u32 = unsafe { ::std::mem::transmute(EccBeatEn) };
            EccBeatEn as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let EccChEn: u32 = unsafe { ::std::mem::transmute(EccChEn) };
            EccChEn as u64
        });
        __bindgen_bitfield_unit.set(64usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ADL_ERROR_PATTERN = _ADL_ERROR_PATTERN;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_ERROR_INJECTION_DATA {
    pub errorAddress: ::std::os::raw::c_ulonglong,
    pub errorPattern: ADL_ERROR_PATTERN,
}
#[doc = "\n\\brief Structure containing information about EDC Error Injection\n\n This structure is used to store EDC Error Injection\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLErrorInjection {
    pub blockId: ADL_EDC_BLOCK_ID,
    pub errorInjectionMode: ADL_ERROR_INJECTION_MODE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLErrorInjectionX2 {
    pub blockId: ADL_EDC_BLOCK_ID,
    pub errorInjectionMode: ADL_ERROR_INJECTION_MODE,
    pub errorInjectionData: ADL_ERROR_INJECTION_DATA,
}
#[doc = "\n\\brief Structure containing per display FreeSync capability information.\n\n This structure is used to store the FreeSync capability of both the display and\n the GPU the display is connected to.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLFreeSyncCap {
    #[doc = " FreeSync capability flags. \\ref define_freesync_caps"]
    pub iCaps: ::std::os::raw::c_int,
    #[doc = " Reports minimum FreeSync refresh rate supported by the display in micro hertz"]
    pub iMinRefreshRateInMicroHz: ::std::os::raw::c_int,
    #[doc = " Reports maximum FreeSync refresh rate supported by the display in micro hertz"]
    pub iMaxRefreshRateInMicroHz: ::std::os::raw::c_int,
    #[doc = " Index of FreeSync Label to use:  ADL_FREESYNC_LABEL_*"]
    pub ucLabelIndex: ::std::os::raw::c_uchar,
    #[doc = " Reserved"]
    pub cReserved: [::std::os::raw::c_char; 3usize],
    pub iReserved: [::std::os::raw::c_int; 4usize],
}
#[doc = "\n\\brief Structure containing per display Display Connectivity Experience Settings\n\n This structure is used to store the Display Connectivity Experience settings of a\n display\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDceSettings {
    pub type_: DceSettingsType,
    pub Settings: ADLDceSettings__bindgen_ty_1,
    pub iReserved: [::std::os::raw::c_int; 15usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADLDceSettings__bindgen_ty_1 {
    pub HdmiLq: ADLDceSettings__bindgen_ty_1__bindgen_ty_1,
    pub DpLink: ADLDceSettings__bindgen_ty_1__bindgen_ty_2,
    pub Protection: ADLDceSettings__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDceSettings__bindgen_ty_1__bindgen_ty_1 {
    pub qualityDetectionEnabled: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDceSettings__bindgen_ty_1__bindgen_ty_2 {
    pub linkRate: DpLinkRate,
    pub numberOfActiveLanes: ::std::os::raw::c_uint,
    pub numberofTotalLanes: ::std::os::raw::c_uint,
    pub relativePreEmphasis: ::std::os::raw::c_int,
    pub relativeVoltageSwing: ::std::os::raw::c_int,
    pub persistFlag: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDceSettings__bindgen_ty_1__bindgen_ty_3 {
    pub linkProtectionEnabled: bool,
}
#[doc = "\n\\brief Structure containing information about Graphic Core\n\n This structure is used to get Graphic Core Info\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGraphicCoreInfo {
    #[doc = " indicate the graphic core generation"]
    pub iGCGen: ::std::os::raw::c_int,
    pub __bindgen_anon_1: ADLGraphicCoreInfo__bindgen_ty_1,
    pub __bindgen_anon_2: ADLGraphicCoreInfo__bindgen_ty_2,
    #[doc = " Total number of SIMDs. Valid for Pre GCN (iGCGen == Pre-GCN)"]
    pub iNumSIMDs: ::std::os::raw::c_int,
    #[doc = " Total number of ROPs. Valid for both GCN and Pre GCN"]
    pub iNumROPs: ::std::os::raw::c_int,
    #[doc = " reserved for future use"]
    pub iReserved: [::std::os::raw::c_int; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADLGraphicCoreInfo__bindgen_ty_1 {
    #[doc = " Total number of CUs. Valid for GCN (iGCGen == GCN)"]
    pub iNumCUs: ::std::os::raw::c_int,
    #[doc = " Total number of WGPs. Valid for RDNA (iGCGen == RDNA)"]
    pub iNumWGPs: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADLGraphicCoreInfo__bindgen_ty_2 {
    #[doc = " Number of processing elements per CU. Valid for GCN (iGCGen == GCN)"]
    pub iNumPEsPerCU: ::std::os::raw::c_int,
    #[doc = " Number of processing elements per WGP. Valid for RDNA (iGCGen == RDNA)"]
    pub iNumPEsPerWGP: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive N clock range\n\n This structure is used to store information about Overdrive N clock range\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNParameterRange {
    #[doc = " The starting value of the clock range"]
    pub iMode: ::std::os::raw::c_int,
    #[doc = " The starting value of the clock range"]
    pub iMin: ::std::os::raw::c_int,
    #[doc = " The ending value of the clock range"]
    pub iMax: ::std::os::raw::c_int,
    #[doc = " The minimum increment between clock values"]
    pub iStep: ::std::os::raw::c_int,
    #[doc = " The default clock values"]
    pub iDefault: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive N capabilities\n\n This structure is used to store information about Overdrive N capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNCapabilities {
    #[doc = " Number of levels which describe the minimum to maximum clock ranges.\n The 1st level indicates the minimum clocks, and the 2nd level\n indicates the maximum clocks."]
    pub iMaximumNumberOfPerformanceLevels: ::std::os::raw::c_int,
    #[doc = " Contains the hard limits of the sclk range.  Overdrive\n clocks cannot be set outside this range."]
    pub sEngineClockRange: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the mclk range.  Overdrive\n clocks cannot be set outside this range."]
    pub sMemoryClockRange: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the vddc range.  Overdrive\n clocks cannot be set outside this range."]
    pub svddcRange: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the power range.  Overdrive\n clocks cannot be set outside this range."]
    pub power: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the power range.  Overdrive\n clocks cannot be set outside this range."]
    pub powerTuneTemperature: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the Temperature range.  Overdrive\n clocks cannot be set outside this range."]
    pub fanTemperature: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the Fan range.  Overdrive\n clocks cannot be set outside this range."]
    pub fanSpeed: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the Fan range.  Overdrive\n clocks cannot be set outside this range."]
    pub minimumPerformanceClock: ADLODNParameterRange,
}
#[doc = "\n\\brief Structure containing information about Overdrive N capabilities\n\n This structure is used to store information about Overdrive N capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNCapabilitiesX2 {
    #[doc = " Number of levels which describe the minimum to maximum clock ranges.\n The 1st level indicates the minimum clocks, and the 2nd level\n indicates the maximum clocks."]
    pub iMaximumNumberOfPerformanceLevels: ::std::os::raw::c_int,
    #[doc = " bit vector, which tells what are the features are supported.\n \\ref: ADLODNFEATURECONTROL"]
    pub iFlags: ::std::os::raw::c_int,
    #[doc = " Contains the hard limits of the sclk range.  Overdrive\n clocks cannot be set outside this range."]
    pub sEngineClockRange: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the mclk range.  Overdrive\n clocks cannot be set outside this range."]
    pub sMemoryClockRange: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the vddc range.  Overdrive\n clocks cannot be set outside this range."]
    pub svddcRange: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the power range.  Overdrive\n clocks cannot be set outside this range."]
    pub power: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the power range.  Overdrive\n clocks cannot be set outside this range."]
    pub powerTuneTemperature: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the Temperature range.  Overdrive\n clocks cannot be set outside this range."]
    pub fanTemperature: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the Fan range.  Overdrive\n clocks cannot be set outside this range."]
    pub fanSpeed: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the Fan range.  Overdrive\n clocks cannot be set outside this range."]
    pub minimumPerformanceClock: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the throttleNotification"]
    pub throttleNotificaion: ADLODNParameterRange,
    #[doc = " Contains the hard limits of the Auto Systemclock"]
    pub autoSystemClock: ADLODNParameterRange,
}
#[doc = "\n\\brief Structure containing information about Overdrive level.\n\n This structure is used to store information about Overdrive level.\n This structure is used by ADLODPerformanceLevels.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNPerformanceLevel {
    #[doc = " clock."]
    pub iClock: ::std::os::raw::c_int,
    #[doc = " VDCC."]
    pub iVddc: ::std::os::raw::c_int,
    #[doc = " enabled"]
    pub iEnabled: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive N performance levels.\n\n This structure is used to store information about Overdrive performance levels.\n This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNPerformanceLevels {
    pub iSize: ::std::os::raw::c_int,
    pub iMode: ::std::os::raw::c_int,
    #[doc = " Must be set to sizeof( \\ref ADLODPerformanceLevels ) + sizeof( \\ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)"]
    pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
    #[doc = " Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements."]
    pub aLevels: [ADLODNPerformanceLevel; 1usize],
}
#[doc = "\n\\brief Structure containing information about Overdrive N Fan Speed.\n\n This structure is used to store information about Overdrive Fan control .\n This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNFanControl {
    pub iMode: ::std::os::raw::c_int,
    pub iFanControlMode: ::std::os::raw::c_int,
    pub iCurrentFanSpeedMode: ::std::os::raw::c_int,
    pub iCurrentFanSpeed: ::std::os::raw::c_int,
    pub iTargetFanSpeed: ::std::os::raw::c_int,
    pub iTargetTemperature: ::std::os::raw::c_int,
    pub iMinPerformanceClock: ::std::os::raw::c_int,
    pub iMinFanLimit: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive N power limit.\n\n This structure is used to store information about Overdrive power limit.\n This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNPowerLimitSetting {
    pub iMode: ::std::os::raw::c_int,
    pub iTDPLimit: ::std::os::raw::c_int,
    pub iMaxOperatingTemperature: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNPerformanceStatus {
    pub iCoreClock: ::std::os::raw::c_int,
    pub iMemoryClock: ::std::os::raw::c_int,
    pub iDCEFClock: ::std::os::raw::c_int,
    pub iGFXClock: ::std::os::raw::c_int,
    pub iUVDClock: ::std::os::raw::c_int,
    pub iVCEClock: ::std::os::raw::c_int,
    pub iGPUActivityPercent: ::std::os::raw::c_int,
    pub iCurrentCorePerformanceLevel: ::std::os::raw::c_int,
    pub iCurrentMemoryPerformanceLevel: ::std::os::raw::c_int,
    pub iCurrentDCEFPerformanceLevel: ::std::os::raw::c_int,
    pub iCurrentGFXPerformanceLevel: ::std::os::raw::c_int,
    pub iUVDPerformanceLevel: ::std::os::raw::c_int,
    pub iVCEPerformanceLevel: ::std::os::raw::c_int,
    pub iCurrentBusSpeed: ::std::os::raw::c_int,
    pub iCurrentBusLanes: ::std::os::raw::c_int,
    pub iMaximumBusLanes: ::std::os::raw::c_int,
    pub iVDDC: ::std::os::raw::c_int,
    pub iVDDCI: ::std::os::raw::c_int,
}
#[doc = "\\brief Structure containing information about Overdrive level.\n\n This structure is used to store information about Overdrive level.\n This structure is used by ADLODPerformanceLevels.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNPerformanceLevelX2 {
    #[doc = " clock."]
    pub iClock: ::std::os::raw::c_int,
    #[doc = " VDCC."]
    pub iVddc: ::std::os::raw::c_int,
    #[doc = " enabled"]
    pub iEnabled: ::std::os::raw::c_int,
    #[doc = " MASK"]
    pub iControl: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive N performance levels.\n\n This structure is used to store information about Overdrive performance levels.\n This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNPerformanceLevelsX2 {
    pub iSize: ::std::os::raw::c_int,
    pub iMode: ::std::os::raw::c_int,
    #[doc = " Must be set to sizeof( \\ref ADLODPerformanceLevels ) + sizeof( \\ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)"]
    pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
    #[doc = " Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements."]
    pub aLevels: [ADLODNPerformanceLevelX2; 1usize],
}
impl ADLODNCurrentPowerType {
    pub const ODN_GPU_TOTAL_POWER: ADLODNCurrentPowerType = ADLODNCurrentPowerType(0);
}
impl ADLODNCurrentPowerType {
    pub const ODN_GPU_PPT_POWER: ADLODNCurrentPowerType = ADLODNCurrentPowerType(1);
}
impl ADLODNCurrentPowerType {
    pub const ODN_GPU_SOCKET_POWER: ADLODNCurrentPowerType = ADLODNCurrentPowerType(2);
}
impl ADLODNCurrentPowerType {
    pub const ODN_GPU_CHIP_POWER: ADLODNCurrentPowerType = ADLODNCurrentPowerType(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLODNCurrentPowerType(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNCurrentPowerParameters {
    pub size: ::std::os::raw::c_int,
    pub powerType: ADLODNCurrentPowerType,
    pub currentPower: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLODNExtSingleInitSetting {
    pub mode: ::std::os::raw::c_int,
    pub minValue: ::std::os::raw::c_int,
    pub maxValue: ::std::os::raw::c_int,
    pub step: ::std::os::raw::c_int,
    pub defaultValue: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD8SingleInitSetting {
    pub featureID: ::std::os::raw::c_int,
    pub minValue: ::std::os::raw::c_int,
    pub maxValue: ::std::os::raw::c_int,
    pub defaultValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Overdrive8 initial setting\n\n This structure is used to store information about Overdrive8 initial setting\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD8InitSetting {
    pub count: ::std::os::raw::c_int,
    pub overdrive8Capabilities: ::std::os::raw::c_int,
    pub od8SettingTable: [ADLOD8SingleInitSetting; 52usize],
}
#[doc = "\n\\brief Structure containing information about Overdrive8 current setting\n\n This structure is used to store information about Overdrive8 current setting\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD8CurrentSetting {
    pub count: ::std::os::raw::c_int,
    pub Od8SettingTable: [::std::os::raw::c_int; 52usize],
}
#[doc = "\n\\brief Structure containing information about Overdrive8 set setting\n\n This structure is used to store information about Overdrive8 set setting\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD8SingleSetSetting {
    pub value: ::std::os::raw::c_int,
    pub requested: ::std::os::raw::c_int,
    pub reset: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLOD8SetSetting {
    pub count: ::std::os::raw::c_int,
    pub od8SettingTable: [ADLOD8SingleSetSetting; 52usize],
}
#[doc = "\n\\brief Structure containing information about Performance Metrics data\n\n This structure is used to store information about Performance Metrics data output\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSingleSensorData {
    pub supported: ::std::os::raw::c_int,
    pub value: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPMLogDataOutput {
    pub size: ::std::os::raw::c_int,
    pub sensors: [ADLSingleSensorData; 256usize],
}
#[doc = "\n\\brief Structure containing information about PPLog settings.\n\n This structure is used to store information about PPLog settings.\n This structure is used by the ADL2_PPLogSettings_Set() and ADL2_PPLogSettings_Get() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPPLogSettings {
    pub BreakOnAssert: ::std::os::raw::c_int,
    pub BreakOnWarn: ::std::os::raw::c_int,
    pub LogEnabled: ::std::os::raw::c_int,
    pub LogFieldMask: ::std::os::raw::c_int,
    pub LogDestinations: ::std::os::raw::c_int,
    pub LogSeverityEnabled: ::std::os::raw::c_int,
    pub LogSourceMask: ::std::os::raw::c_int,
    pub PowerProfilingEnabled: ::std::os::raw::c_int,
    pub PowerProfilingTimeInterval: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information related Frames Per Second for AC and DC.\n\n This structure is used to store information related AC and DC Frames Per Second settings\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLFPSSettingsOutput {
    #[doc = " size"]
    pub ulSize: ::std::os::raw::c_int,
    #[doc = " FPS Monitor is enabled in the AC state if 1"]
    pub bACFPSEnabled: ::std::os::raw::c_int,
    #[doc = " FPS Monitor is enabled in the DC state if 1"]
    pub bDCFPSEnabled: ::std::os::raw::c_int,
    #[doc = " Current Value of FPS Monitor in AC state"]
    pub ulACFPSCurrent: ::std::os::raw::c_int,
    #[doc = " Current Value of FPS Monitor in DC state"]
    pub ulDCFPSCurrent: ::std::os::raw::c_int,
    #[doc = " Maximum FPS Threshold allowed in PPLib for AC"]
    pub ulACFPSMaximum: ::std::os::raw::c_int,
    #[doc = " Minimum FPS Threshold allowed in PPLib for AC"]
    pub ulACFPSMinimum: ::std::os::raw::c_int,
    #[doc = " Maximum FPS Threshold allowed in PPLib for DC"]
    pub ulDCFPSMaximum: ::std::os::raw::c_int,
    #[doc = " Minimum FPS Threshold allowed in PPLib for DC"]
    pub ulDCFPSMinimum: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information related Frames Per Second for AC and DC.\n\n This structure is used to store information related AC and DC Frames Per Second settings\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLFPSSettingsInput {
    #[doc = " size"]
    pub ulSize: ::std::os::raw::c_int,
    #[doc = " Settings are for Global FPS (used by CCC)"]
    pub bGlobalSettings: ::std::os::raw::c_int,
    #[doc = " Current Value of FPS Monitor in AC state"]
    pub ulACFPSCurrent: ::std::os::raw::c_int,
    #[doc = " Current Value of FPS Monitor in DC state"]
    pub ulDCFPSCurrent: ::std::os::raw::c_int,
    #[doc = " Reserved"]
    pub ulReserved: [::std::os::raw::c_int; 6usize],
}
pub const ADL_PMLOG_MAX_SUPPORTED_SENSORS: _bindgen_ty_1 = _bindgen_ty_1(256);
#[repr(transparent)]
#[doc = "\n\\brief Structure containing information related power management logging.\n\n This structure is used to store support information for power management logging.\n \\nosubgrouping\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_1(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPMLogSupportInfo {
    #[doc = " list of sensors defined by ADL_PMLOG_SENSORS"]
    pub usSensors: [::std::os::raw::c_ushort; 256usize],
    #[doc = " Reserved"]
    pub ulReserved: [::std::os::raw::c_int; 16usize],
}
#[doc = "\n\\brief Structure containing information to start power management logging.\n\n This structure is used as input to ADL2_Adapter_PMLog_Start\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPMLogStartInput {
    #[doc = " list of sensors defined by ADL_PMLOG_SENSORS"]
    pub usSensors: [::std::os::raw::c_ushort; 256usize],
    #[doc = " Sample rate in milliseconds"]
    pub ulSampleRate: ::std::os::raw::c_ulong,
    #[doc = " Reserved"]
    pub ulReserved: [::std::os::raw::c_int; 15usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPMLogData {
    #[doc = " Structure version"]
    pub ulVersion: ::std::os::raw::c_uint,
    #[doc = " Current driver sample rate"]
    pub ulActiveSampleRate: ::std::os::raw::c_uint,
    #[doc = " Timestamp of last update"]
    pub ulLastUpdated: ::std::os::raw::c_ulonglong,
    #[doc = " 2D array of senesor and values"]
    pub ulValues: [[::std::os::raw::c_uint; 2usize]; 256usize],
    #[doc = " Reserved"]
    pub ulReserved: [::std::os::raw::c_uint; 256usize],
}
#[doc = "\n\\brief Structure containing information to start power management logging.\n\n This structure is returned as output from ADL2_Adapter_PMLog_Start\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPMLogStartOutput {
    pub __bindgen_anon_1: ADLPMLogStartOutput__bindgen_ty_1,
    #[doc = " Reserved"]
    pub ulReserved: [::std::os::raw::c_int; 14usize],
}
#[doc = " Pointer to memory address containing logging data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADLPMLogStartOutput__bindgen_ty_1 {
    pub pLoggingAddress: *mut ::std::os::raw::c_void,
    pub ptr_LoggingAddress: ::std::os::raw::c_ulonglong,
}
#[doc = "\n\\brief Structure containing information to query limits of power management logging.\n\n This structure is returned as output from ADL2_Adapter_PMLog_SensorLimits_Get\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPMLogSensorLimits {
    pub SensorLimits: [[::std::os::raw::c_int; 2usize]; 256usize],
}
#[doc = "\n\\brief Structure containing information related RAS Get Error Counts Information\n\n This structure is used to store RAS Error Counts Get Input Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLRASGetErrorCountsInput {
    pub Reserved: [::std::os::raw::c_uint; 16usize],
}
#[doc = "\n\\brief Structure containing information related RAS Get Error Counts Information\n\n This structure is used to store RAS Error Counts Get Output Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLRASGetErrorCountsOutput {
    pub CorrectedErrors: ::std::os::raw::c_uint,
    pub UnCorrectedErrors: ::std::os::raw::c_uint,
    pub Reserved: [::std::os::raw::c_uint; 14usize],
}
#[doc = "\n\\brief Structure containing information related RAS Get Error Counts Information\n\n This structure is used to store RAS Error Counts Get Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLRASGetErrorCounts {
    pub InputSize: ::std::os::raw::c_uint,
    pub Input: ADLRASGetErrorCountsInput,
    pub OutputSize: ::std::os::raw::c_uint,
    pub Output: ADLRASGetErrorCountsOutput,
}
#[doc = "\n\\brief Structure containing information related RAS Error Counts Reset Information\n\n This structure is used to store RAS Error Counts Reset Input Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLRASResetErrorCountsInput {
    pub Reserved: [::std::os::raw::c_uint; 8usize],
}
#[doc = "\n\\brief Structure containing information related RAS Error Counts Reset Information\n\n This structure is used to store RAS Error Counts Reset Output Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLRASResetErrorCountsOutput {
    pub Reserved: [::std::os::raw::c_uint; 8usize],
}
#[doc = "\n\\brief Structure containing information related RAS Error Counts Reset Information\n\n This structure is used to store RAS Error Counts Reset Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLRASResetErrorCounts {
    pub InputSize: ::std::os::raw::c_uint,
    pub Input: ADLRASResetErrorCountsInput,
    pub OutputSize: ::std::os::raw::c_uint,
    pub Output: ADLRASResetErrorCountsOutput,
}
#[doc = "\n\\brief Structure containing information related RAS Error Injection information\n\n This structure is used to store RAS Error Injection input information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLRASErrorInjectionInput {
    pub Address: ::std::os::raw::c_ulonglong,
    pub Value: ADL_RAS_INJECTION_METHOD,
    pub BlockId: ADL_RAS_BLOCK_ID,
    pub InjectErrorType: ADL_RAS_ERROR_TYPE,
    pub SubBlockIndex: ADL_MEM_SUB_BLOCK_ID,
    pub padding: [::std::os::raw::c_uint; 9usize],
}
#[doc = "\n\\brief Structure containing information related RAS Error Injection information\n\n This structure is used to store RAS Error Injection output information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLRASErrorInjectionOutput {
    pub ErrorInjectionStatus: ::std::os::raw::c_uint,
    pub padding: [::std::os::raw::c_uint; 15usize],
}
#[doc = "\n\\brief Structure containing information related RAS Error Injection information\n\n This structure is used to store RAS Error Injection information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLRASErrorInjection {
    pub InputSize: ::std::os::raw::c_uint,
    pub Input: ADLRASErrorInjectionInput,
    pub OutputSize: ::std::os::raw::c_uint,
    pub Output: ADLRASErrorInjectionOutput,
}
#[doc = "\n\\brief Structure containing information about an application\n\n This structure is used to store basic information of a recently ran or currently running application\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSGApplicationInfo {
    #[doc = " Application file name"]
    pub strFileName: [u16; 256usize],
    #[doc = " Application file path"]
    pub strFilePath: [u16; 256usize],
    #[doc = " Application version"]
    pub strVersion: [u16; 256usize],
    #[doc = " Timestamp at which application has run"]
    pub timeStamp: ::std::os::raw::c_longlong,
    #[doc = " Holds whether the application profile exists or not"]
    pub iProfileExists: ::std::os::raw::c_uint,
    #[doc = " The GPU on which application runs"]
    pub iGPUAffinity: ::std::os::raw::c_uint,
    #[doc = " The BDF of the GPU on which application runs"]
    pub GPUBdf: ADLBdf,
}
pub const ADLPreFlipPostProcessingInfoInvalidLUTIndex: _bindgen_ty_2 = _bindgen_ty_2(-1);
#[repr(transparent)]
#[doc = "\n\\brief Structure containing information related Frames Per Second for AC and DC.\n\n This structure is used to store information related AC and DC Frames Per Second settings\n \\nosubgrouping\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_2(pub ::std::os::raw::c_int);
impl ADLPreFlipPostProcessingLUTAlgorithm {
    pub const ADLPreFlipPostProcessingLUTAlgorithm_Default: ADLPreFlipPostProcessingLUTAlgorithm =
        ADLPreFlipPostProcessingLUTAlgorithm(0);
}
impl ADLPreFlipPostProcessingLUTAlgorithm {
    pub const ADLPreFlipPostProcessingLUTAlgorithm_Full: ADLPreFlipPostProcessingLUTAlgorithm =
        ADLPreFlipPostProcessingLUTAlgorithm(1);
}
impl ADLPreFlipPostProcessingLUTAlgorithm {
    pub const ADLPreFlipPostProcessingLUTAlgorithm_Approximation:
        ADLPreFlipPostProcessingLUTAlgorithm = ADLPreFlipPostProcessingLUTAlgorithm(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ADLPreFlipPostProcessingLUTAlgorithm(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPreFlipPostProcessingInfo {
    #[doc = " size"]
    pub ulSize: ::std::os::raw::c_int,
    #[doc = " Current active state"]
    pub bEnabled: ::std::os::raw::c_int,
    #[doc = " Current selected LUT index.  0xFFFFFFF returned if nothing selected."]
    pub ulSelectedLUTIndex: ::std::os::raw::c_int,
    #[doc = " Current selected LUT Algorithm"]
    pub ulSelectedLUTAlgorithm: ::std::os::raw::c_int,
    #[doc = " Reserved"]
    pub ulReserved: [::std::os::raw::c_int; 12usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_ERROR_REASON {
    pub boost: ::std::os::raw::c_int,
    pub delag: ::std::os::raw::c_int,
    pub chill: ::std::os::raw::c_int,
    pub proVsr: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_ERROR_REASON2 {
    pub boost: ::std::os::raw::c_int,
    pub delag: ::std::os::raw::c_int,
    pub chill: ::std::os::raw::c_int,
    pub proVsr: ::std::os::raw::c_int,
    pub upscale: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about DELAG Settings change reason\n\n  Elements of DELAG settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_DELAG_NOTFICATION_REASON {
    pub HotkeyChanged: ::std::os::raw::c_int,
    pub GlobalEnableChanged: ::std::os::raw::c_int,
    pub GlobalLimitFPSChanged: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about DELAG Settings\n\n  Elements of DELAG settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_DELAG_SETTINGS {
    pub Hotkey: ::std::os::raw::c_int,
    pub GlobalEnable: ::std::os::raw::c_int,
    pub GlobalLimitFPS: ::std::os::raw::c_int,
    pub GlobalLimitFPS_MinLimit: ::std::os::raw::c_int,
    pub GlobalLimitFPS_MaxLimit: ::std::os::raw::c_int,
    pub GlobalLimitFPS_Step: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about BOOST Settings change reason\n\n  Elements of BOOST settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_BOOST_NOTFICATION_REASON {
    pub HotkeyChanged: ::std::os::raw::c_int,
    pub GlobalEnableChanged: ::std::os::raw::c_int,
    pub GlobalMinResChanged: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about BOOST Settings\n\n  Elements of BOOST settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_BOOST_SETTINGS {
    pub Hotkey: ::std::os::raw::c_int,
    pub GlobalEnable: ::std::os::raw::c_int,
    pub GlobalMinRes: ::std::os::raw::c_int,
    pub GlobalMinRes_MinLimit: ::std::os::raw::c_int,
    pub GlobalMinRes_MaxLimit: ::std::os::raw::c_int,
    pub GlobalMinRes_Step: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about ProVSR Settings change reason\n\n  Elements of ProVSR settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_PROVSR_NOTFICATION_REASON {
    pub HotkeyChanged: ::std::os::raw::c_int,
    pub GlobalEnableChanged: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Pro VSR Settings\n\n  Elements of ProVSR settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_PROVSR_SETTINGS {
    pub Hotkey: ::std::os::raw::c_int,
    pub GlobalEnable: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about Image Boost(OGL) Settings change reason\n\n  Elements of Image Boost settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_IMAGE_BOOST_NOTFICATION_REASON {
    pub HotkeyChanged: ::std::os::raw::c_int,
    pub GlobalEnableChanged: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about OGL IMAGE BOOST Settings\n\n  Elements of OGL IMAGE BOOST settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_IMAGE_BOOST_SETTINGS {
    pub Hotkey: ::std::os::raw::c_int,
    pub GlobalEnable: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about RIS Settings change reason\n\n  Elements of RIS settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_RIS_NOTFICATION_REASON {
    pub GlobalEnableChanged: ::std::os::raw::c_uint,
    pub GlobalSharpeningDegreeChanged: ::std::os::raw::c_uint,
}
#[doc = "\n\\brief Structure containing information about RIS Settings\n\n  Elements of RIS settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_RIS_SETTINGS {
    pub GlobalEnable: ::std::os::raw::c_int,
    pub GlobalSharpeningDegree: ::std::os::raw::c_int,
    pub GlobalSharpeningDegree_MinLimit: ::std::os::raw::c_int,
    pub GlobalSharpeningDegree_MaxLimit: ::std::os::raw::c_int,
    pub GlobalSharpeningDegree_Step: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about CHILL Settings change reason\n\n  Elements of Chill settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_CHILL_NOTFICATION_REASON {
    pub HotkeyChanged: ::std::os::raw::c_int,
    pub GlobalEnableChanged: ::std::os::raw::c_int,
    pub GlobalMinFPSChanged: ::std::os::raw::c_int,
    pub GlobalMaxFPSChanged: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about CHILL Settings\n\n  Elements of Chill settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_CHILL_SETTINGS {
    pub Hotkey: ::std::os::raw::c_int,
    pub GlobalEnable: ::std::os::raw::c_int,
    pub GlobalMinFPS: ::std::os::raw::c_int,
    pub GlobalMaxFPS: ::std::os::raw::c_int,
    pub GlobalFPS_MinLimit: ::std::os::raw::c_int,
    pub GlobalFPS_MaxLimit: ::std::os::raw::c_int,
    pub GlobalFPS_Step: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about DRIVERUPSCALE Settings change reason\n\n  Elements of DRIVERUPSCALE settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_DRIVERUPSCALE_NOTFICATION_REASON {
    pub ModeOverrideEnabledChanged: ::std::os::raw::c_int,
    pub GlobalEnabledChanged: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about DRIVERUPSCALE Settings\n\n  Elements of DRIVERUPSCALE settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_DRIVERUPSCALE_SETTINGS {
    pub ModeOverrideEnabled: ::std::os::raw::c_int,
    pub GlobalEnabled: ::std::os::raw::c_int,
}
#[doc = "\n\\brief  Structure Containing R G B values for Radeon USB LED Bar\n\n Elements of RGB Values.\n \\nosubgrouping\n"]
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub struct ADL_RADEON_LED_COLOR_CONFIG {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl ADL_RADEON_LED_COLOR_CONFIG {
    #[inline]
    pub fn R(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_R(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn G(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_G(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn B(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_B(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        R: ::std::os::raw::c_ushort,
        G: ::std::os::raw::c_ushort,
        B: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let R: u16 = unsafe { ::std::mem::transmute(R) };
            R as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let G: u16 = unsafe { ::std::mem::transmute(G) };
            G as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let B: u16 = unsafe { ::std::mem::transmute(B) };
            B as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "\n\\brief Structure Containing All Generic LED configuration for user requested LED pattern. The driver will apply the configuration as requested\n\n  Elements of Radeon USB LED configuration.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_RADEON_LED_PATTERN_CONFIG_GENERIC {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub directionCounterClockWise: bool,
    pub colorConfig: ADL_RADEON_LED_COLOR_CONFIG,
    pub morseCodeText: [::std::os::raw::c_char; 260usize],
    pub morseCodeTextOutPut: [::std::os::raw::c_char; 260usize],
    pub morseCodeTextOutPutLen: ::std::os::raw::c_int,
}
impl ADL_RADEON_LED_PATTERN_CONFIG_GENERIC {
    #[inline]
    pub fn brightness(&self) -> ::std::os::raw::c_short {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_brightness(&mut self, val: ::std::os::raw::c_short) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn speed(&self) -> ::std::os::raw::c_short {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_speed(&mut self, val: ::std::os::raw::c_short) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        brightness: ::std::os::raw::c_short,
        speed: ::std::os::raw::c_short,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let brightness: u16 = unsafe { ::std::mem::transmute(brightness) };
            brightness as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let speed: u16 = unsafe { ::std::mem::transmute(speed) };
            speed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "\n\\brief Structure Containing All custom grid pattern LED configuration for user requested LED grid pattern. The driver will apply the configuration as requested\n\n  Elements of Radeon USB LED custom grid configuration.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_RADEON_LED_CUSTOM_LED_CONFIG {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub colorConfig: [[ADL_RADEON_LED_COLOR_CONFIG; 24usize]; 7usize],
}
impl ADL_RADEON_LED_CUSTOM_LED_CONFIG {
    #[inline]
    pub fn brightness(&self) -> ::std::os::raw::c_short {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_brightness(&mut self, val: ::std::os::raw::c_short) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        brightness: ::std::os::raw::c_short,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let brightness: u16 = unsafe { ::std::mem::transmute(brightness) };
            brightness as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "\n\\brief Structure Containing All custom grid pattern LED configuration for user requested LED grid pattern. The driver will apply the configuration as requested\n\n  Elements of Radeon USB LED custom grid configuration.\n \\nosubgrouping\n"]
pub type ADL_RADEON_LED_CUSTOM_GRID_LED_CONFIG = ADL_RADEON_LED_CUSTOM_LED_CONFIG;
#[doc = "\n\\brief Structure Containing All Radeon USB LED requests and controls.\n\n Elements of Radeon USB LED Controls.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_RADEON_LED_PATTERN_CONFIG {
    pub control: ADL_RADEON_USB_LED_BAR_CONTROLS,
    pub __bindgen_anon_1: ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1 {
    pub genericPararmeters: ADL_RADEON_LED_PATTERN_CONFIG_GENERIC,
    pub customGridConfig: ADL_RADEON_LED_CUSTOM_GRID_LED_CONFIG,
}
#[doc = "\n\\brief Structure containing information about the graphics adapter with extended caps\n\n This structure is used to store various information about the graphics adapter.  This\n information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various settings upon the user's request.\n This AdapterInfoX2 struct extends the AdapterInfo struct in adl_structures.h\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AdapterInfoX2 {
    #[doc = " Size of the structure."]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " The ADL index handle. One GPU may be associated with one or two index handles"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = " The unique device ID associated with this adapter."]
    pub strUDID: [::std::os::raw::c_char; 256usize],
    #[doc = " The BUS number associated with this adapter."]
    pub iBusNumber: ::std::os::raw::c_int,
    #[doc = " The driver number associated with this adapter."]
    pub iDeviceNumber: ::std::os::raw::c_int,
    #[doc = " The function number."]
    pub iFunctionNumber: ::std::os::raw::c_int,
    #[doc = " The vendor ID associated with this adapter."]
    pub iVendorID: ::std::os::raw::c_int,
    #[doc = " Adapter name."]
    pub strAdapterName: [::std::os::raw::c_char; 256usize],
    #[doc = " Display name. For example, \"\\\\\\\\Display0\""]
    pub strDisplayName: [::std::os::raw::c_char; 256usize],
    #[doc = " Present or not; 1 if present and 0 if not present.It the logical adapter is present, the display name such as \\\\\\\\.\\\\Display1 can be found from OS"]
    pub iPresent: ::std::os::raw::c_int,
    #[doc = " Exist or not; 1 is exist and 0 is not present."]
    pub iExist: ::std::os::raw::c_int,
    #[doc = " Driver registry path."]
    pub strDriverPath: [::std::os::raw::c_char; 256usize],
    #[doc = " Driver registry path Ext for."]
    pub strDriverPathExt: [::std::os::raw::c_char; 256usize],
    #[doc = " PNP string from Windows."]
    pub strPNPString: [::std::os::raw::c_char; 256usize],
    #[doc = " It is generated from EnumDisplayDevices."]
    pub iOSDisplayIndex: ::std::os::raw::c_int,
    #[doc = " The bit mask identifies the adapter info"]
    pub iInfoMask: ::std::os::raw::c_int,
    #[doc = " The bit identifies the adapter info \\ref define_adapter_info"]
    pub iInfoValue: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about driver  gamut space , whether it is related to source or to destination, overlay or graphics\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGamutReference {
    #[doc = " mask whether it is related to source or to destination, overlay or graphics"]
    pub iGamutRef: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about driver supported gamut spaces , capability method\n\n This structure is used to get driver all supported gamut spaces\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGamutInfo {
    #[doc = "Any combination of following ADL_GAMUT_SPACE_CCIR_709 - ADL_GAMUT_SPACE_CUSTOM"]
    pub SupportedGamutSpace: ::std::os::raw::c_int,
    #[doc = "Any combination of following ADL_WHITE_POINT_5000K - ADL_WHITE_POINT_CUSTOM"]
    pub SupportedWhitePoint: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about driver point coordinates\n\n This structure is used to store the driver point coordinates for gamut and white point\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPoint {
    #[doc = " x coordinate"]
    pub iX: ::std::os::raw::c_int,
    #[doc = " y coordinate"]
    pub iY: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about driver supported gamut coordinates\n\n This structure is used to store the driver supported supported gamut coordinates\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGamutCoordinates {
    #[doc = " red channel chromasity coordinate"]
    pub Red: ADLPoint,
    #[doc = " green channel chromasity coordinate"]
    pub Green: ADLPoint,
    #[doc = " blue channel chromasity coordinate"]
    pub Blue: ADLPoint,
}
#[doc = "\n\\brief Structure containing information about driver current gamut space , parent struct for ADLGamutCoordinates and ADLWhitePoint\n This structure is used to get/set driver supported gamut space\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGamutData {
    #[doc = "used as mask and could be 4 options\nBIT_0 If flag ADL_GAMUT_REFERENCE_SOURCE is asserted set operation is related to gamut source ,\nif not gamut destination\nBIT_1 If flag ADL_GAMUT_GAMUT_VIDEO_CONTENT is asserted\nBIT_2,BIT_3 used as mask and could be 4 options custom (2) + predefined (2)\n0.  Gamut predefined,        white point predefined -> 0                | 0\n1.  Gamut predefined,        white point custom     -> 0                | ADL_CUSTOM_WHITE_POINT\n2.  White point predefined,  gamut custom           -> 0                | ADL_CUSTOM_GAMUT\n3.  White point custom,      gamut custom           -> ADL_CUSTOM_GAMUT | ADL_CUSTOM_WHITE_POINT"]
    pub iFeature: ::std::os::raw::c_int,
    #[doc = "one of ADL_GAMUT_SPACE_CCIR_709 - ADL_GAMUT_SPACE_CIE_RGB"]
    pub iPredefinedGamut: ::std::os::raw::c_int,
    #[doc = "one of ADL_WHITE_POINT_5000K - ADL_WHITE_POINT_9300K"]
    pub iPredefinedWhitePoint: ::std::os::raw::c_int,
    #[doc = "valid when in mask avails ADL_CUSTOM_WHITE_POINT"]
    pub CustomWhitePoint: ADLPoint,
    #[doc = "valid when in mask avails ADL_CUSTOM_GAMUT"]
    pub CustomGamut: ADLGamutCoordinates,
}
#[doc = "\n\\brief Structure containing detailed timing parameters.\n\n This structure is used to store the detailed timing parameters.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDetailedTimingX2 {
    #[doc = " Size of the structure."]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Timing flags. \\ref define_detailed_timing_flags"]
    pub sTimingFlags: ::std::os::raw::c_int,
    #[doc = " Total width (columns)."]
    pub sHTotal: ::std::os::raw::c_int,
    #[doc = " Displayed width."]
    pub sHDisplay: ::std::os::raw::c_int,
    #[doc = " Horizontal sync signal offset."]
    pub sHSyncStart: ::std::os::raw::c_int,
    #[doc = " Horizontal sync signal width."]
    pub sHSyncWidth: ::std::os::raw::c_int,
    #[doc = " Total height (rows)."]
    pub sVTotal: ::std::os::raw::c_int,
    #[doc = " Displayed height."]
    pub sVDisplay: ::std::os::raw::c_int,
    #[doc = " Vertical sync signal offset."]
    pub sVSyncStart: ::std::os::raw::c_int,
    #[doc = " Vertical sync signal width."]
    pub sVSyncWidth: ::std::os::raw::c_int,
    #[doc = " Pixel clock value."]
    pub sPixelClock: ::std::os::raw::c_int,
    #[doc = " Overscan right."]
    pub sHOverscanRight: ::std::os::raw::c_short,
    #[doc = " Overscan left."]
    pub sHOverscanLeft: ::std::os::raw::c_short,
    #[doc = " Overscan bottom."]
    pub sVOverscanBottom: ::std::os::raw::c_short,
    #[doc = " Overscan top."]
    pub sVOverscanTop: ::std::os::raw::c_short,
    pub sOverscan8B: ::std::os::raw::c_short,
    pub sOverscanGR: ::std::os::raw::c_short,
}
#[doc = "\n\\brief Structure containing display mode information.\n\n This structure is used to store the display mode information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDisplayModeInfoX2 {
    #[doc = " Timing standard of the current mode. \\ref define_modetiming_standard"]
    pub iTimingStandard: ::std::os::raw::c_int,
    #[doc = " Applicable timing standards for the current mode."]
    pub iPossibleStandard: ::std::os::raw::c_int,
    #[doc = " Refresh rate factor."]
    pub iRefreshRate: ::std::os::raw::c_int,
    #[doc = " Num of pixels in a row."]
    pub iPelsWidth: ::std::os::raw::c_int,
    #[doc = " Num of pixels in a column."]
    pub iPelsHeight: ::std::os::raw::c_int,
    #[doc = " Detailed timing parameters."]
    pub sDetailedTiming: ADLDetailedTimingX2,
}
#[doc = "\n\\brief Structure containing information about I2C.\n\n This structure is used to store the I2C information for the current adapter.\n This structure is used by \\ref ADL_Display_WriteAndReadI2CLargePayload\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLI2CLargePayload {
    #[doc = " Size of the structure"]
    pub iSize: ::std::os::raw::c_int,
    #[doc = " Numerical value representing hardware I2C."]
    pub iLine: ::std::os::raw::c_int,
    #[doc = " The 7-bit I2C slave device address."]
    pub iAddress: ::std::os::raw::c_int,
    #[doc = " The offset of the data from the address."]
    pub iOffset: ::std::os::raw::c_int,
    #[doc = " Read from or write to slave device. \\ref ADL_DL_I2C_ACTIONREAD or \\ref ADL_DL_I2C_ACTIONWRITE"]
    pub iAction: ::std::os::raw::c_int,
    #[doc = " I2C clock speed in KHz."]
    pub iSpeed: ::std::os::raw::c_int,
    #[doc = " I2C option flags.  \\ref define_ADLI2CLargePayload"]
    pub iFlags: ::std::os::raw::c_int,
    #[doc = " A numerical value representing the number of bytes to be sent or received on the I2C bus."]
    pub iDataSize: ::std::os::raw::c_int,
    #[doc = " Address of the characters which are to be sent or received on the I2C bus."]
    pub pcData: *mut ::std::os::raw::c_char,
}
#[doc = "\n\\brief Structure containing the Multimedia Feature Name\n\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLFeatureName {
    #[doc = " The Feature Name"]
    pub FeatureName: [::std::os::raw::c_char; 16usize],
}
#[doc = "\n\\brief Structure containing information about MM Feature Capabilities.\n\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLFeatureCaps {
    #[doc = " The Feature Name"]
    pub Name: ADLFeatureName,
    #[doc = " Group ID. All Features in the same group are shown sequentially in the same UI Page."]
    pub iGroupID: ::std::os::raw::c_int,
    #[doc = " Visual ID. Places one or more features in a Group Box. If zero, no Group Box is added."]
    pub iVisualID: ::std::os::raw::c_int,
    #[doc = " Page ID. All Features with the same Page ID value are shown together on the same UI page."]
    pub iPageID: ::std::os::raw::c_int,
    #[doc = " Feature Property Mask. Indicates which are the valid bits for iFeatureProperties."]
    pub iFeatureMask: ::std::os::raw::c_int,
    #[doc = " Feature Property Values. See definitions for ADL_FEATURE_PROPERTIES_XXX"]
    pub iFeatureProperties: ::std::os::raw::c_int,
    #[doc = " Appearance of the User-Controlled Boolean."]
    pub iControlType: ::std::os::raw::c_int,
    #[doc = " Style of the User-Controlled Boolean."]
    pub iControlStyle: ::std::os::raw::c_int,
    #[doc = " Appearance of the Adjustment Controls."]
    pub iAdjustmentType: ::std::os::raw::c_int,
    #[doc = " Style of the Adjustment Controls."]
    pub iAdjustmentStyle: ::std::os::raw::c_int,
    #[doc = " Default user-controlled boolean value. Valid only if ADLFeatureCaps supports user-controlled boolean."]
    pub bDefault: ::std::os::raw::c_int,
    #[doc = " Minimum integer value. Valid only if ADLFeatureCaps indicates support for integers."]
    pub iMin: ::std::os::raw::c_int,
    #[doc = " Maximum integer value. Valid only if ADLFeatureCaps indicates support for integers."]
    pub iMax: ::std::os::raw::c_int,
    #[doc = " Step integer value. Valid only if ADLFeatureCaps indicates support for integers."]
    pub iStep: ::std::os::raw::c_int,
    #[doc = " Default integer value. Valid only if ADLFeatureCaps indicates support for integers."]
    pub iDefault: ::std::os::raw::c_int,
    #[doc = " Minimum float value. Valid only if ADLFeatureCaps indicates support for floats."]
    pub fMin: f32,
    #[doc = " Maximum float value. Valid only if ADLFeatureCaps indicates support for floats."]
    pub fMax: f32,
    #[doc = " Step float value. Valid only if ADLFeatureCaps indicates support for floats."]
    pub fStep: f32,
    #[doc = " Default float value. Valid only if ADLFeatureCaps indicates support for floats."]
    pub fDefault: f32,
    #[doc = " The Mask for available bits for enumerated values.(If ADLFeatureCaps supports ENUM values)"]
    pub EnumMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about MM Feature Values.\n\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLFeatureValues {
    #[doc = " The Feature Name"]
    pub Name: ADLFeatureName,
    #[doc = " User controlled Boolean current value. Valid only if ADLFeatureCaps supports Boolean."]
    pub bCurrent: ::std::os::raw::c_int,
    #[doc = " Current integer value. Valid only if ADLFeatureCaps indicates support for integers."]
    pub iCurrent: ::std::os::raw::c_int,
    #[doc = " Current float value. Valid only if ADLFeatureCaps indicates support for floats."]
    pub fCurrent: f32,
    #[doc = " The States for the available bits for enumerated values."]
    pub EnumStates: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing HDCP Settings info\n\n This structure is used to store the HDCP settings of a\n display\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLHDCPSettings {
    pub iHDCPProtectionVersion: ::std::os::raw::c_int,
    pub iHDCPCaps: ::std::os::raw::c_int,
    pub iAllowAll: ::std::os::raw::c_int,
    pub iHDCPVale: ::std::os::raw::c_int,
    pub iHDCPMask: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing Mantle App  info\n\n This structure is used to store the Mantle Driver information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLMantleAppInfo {
    #[doc = " mantle api version"]
    pub apiVersion: ::std::os::raw::c_int,
    #[doc = " mantle driver version"]
    pub driverVersion: ::std::os::raw::c_long,
    #[doc = " mantle vendroe id"]
    pub vendorId: ::std::os::raw::c_long,
    #[doc = " mantle device id"]
    pub deviceId: ::std::os::raw::c_long,
    #[doc = " mantle gpu type;"]
    pub gpuType: ::std::os::raw::c_int,
    #[doc = " gpu name"]
    pub gpuName: [::std::os::raw::c_char; 256usize],
    #[doc = " mem size"]
    pub maxMemRefsPerSubmission: ::std::os::raw::c_int,
    #[doc = " virtual mem size"]
    pub virtualMemPageSize: ::std::os::raw::c_longlong,
    #[doc = " mem update"]
    pub maxInlineMemoryUpdateSize: ::std::os::raw::c_longlong,
    #[doc = " bound descriptor"]
    pub maxBoundDescriptorSets: ::std::os::raw::c_long,
    #[doc = " thread group size"]
    pub maxThreadGroupSize: ::std::os::raw::c_long,
    #[doc = " time stamp frequency"]
    pub timestampFrequency: ::std::os::raw::c_longlong,
    #[doc = " color target"]
    pub multiColorTargetClears: ::std::os::raw::c_long,
}
#[doc = "\n\\brief Structure containing information about SDIData\nThis structure is used to store information about the state of the SDI whether it is on\nor off and the current size of the segment or aperture size.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSDIData {
    #[doc = " The SDI state, ADL_SDI_ON or ADL_SDI_OFF, for the current SDI mode"]
    pub iSDIState: ::std::os::raw::c_int,
    #[doc = " Size of the memory segment for SDI (in MB)."]
    pub iSizeofSDISegment: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information about FRTCPRO Settings\n\n  Elements of FRTCPRO settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_FRTCPRO_Settings {
    pub DefaultState: ::std::os::raw::c_int,
    pub CurrentState: ::std::os::raw::c_int,
    pub DefaultValue: ::std::os::raw::c_uint,
    pub CurrentValue: ::std::os::raw::c_uint,
    pub maxSupportedFps: ::std::os::raw::c_uint,
    pub minSupportedFps: ::std::os::raw::c_uint,
}
#[doc = "\n\\brief Structure containing information about FRTCPRO Settings changed reason\n\n  Reason of FRTCPRO changed.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_FRTCPRO_CHANGED_REASON {
    pub StateChanged: ::std::os::raw::c_int,
    pub ValueChanged: ::std::os::raw::c_int,
}
#[doc = "\n \\brief Structure containing the display mode definition used per controller.\n\n This structure is used to store the display mode definition used per controller.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_DL_DISPLAY_MODE {
    pub iPelsHeight: ::std::os::raw::c_int,
    pub iPelsWidth: ::std::os::raw::c_int,
    pub iBitsPerPel: ::std::os::raw::c_int,
    pub iDisplayFrequency: ::std::os::raw::c_int,
}
#[doc = "\n\\brief Structure containing information related DCE support\n\n This structure is used to store a bit vector of possible DCE support\n\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ADLDCESupport {
    pub bits: _ADLDCESupport__bindgen_ty_1,
    pub u32All: ::std::os::raw::c_uint,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct _ADLDCESupport__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _ADLDCESupport__bindgen_ty_1 {
    #[inline]
    pub fn PrePhasis(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PrePhasis(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn voltageSwing(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_voltageSwing(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PrePhasis: ::std::os::raw::c_uint,
        voltageSwing: ::std::os::raw::c_uint,
        reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PrePhasis: u32 = unsafe { ::std::mem::transmute(PrePhasis) };
            PrePhasis as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let voltageSwing: u32 = unsafe { ::std::mem::transmute(voltageSwing) };
            voltageSwing as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "\n\\brief Structure containing information related DCE support\n\n This structure is used to store a bit vector of possible DCE support\n\n \\nosubgrouping\n"]
pub type ADLDCESupport = _ADLDCESupport;
#[doc = "\n \\brief Structure for Smart shift 2.0 settings\n\n This structure is used to return the smart shift settings\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLSmartShiftSettings {
    pub iMinRange: ::std::os::raw::c_int,
    pub iMaxRange: ::std::os::raw::c_int,
    pub iDefaultMode: ::std::os::raw::c_int,
    pub iDefaultValue: ::std::os::raw::c_int,
    pub iCurrentMode: ::std::os::raw::c_int,
    pub iCurrentValue: ::std::os::raw::c_int,
    pub iFlags: ::std::os::raw::c_int,
}
#[doc = " Memory Allocation Call back"]
pub type ADL_MAIN_MALLOC_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn ADL2_Adapter_ObservedClockInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCoreClock: *mut ::std::os::raw::c_int,
        lpMemoryClock: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Active_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStatus: ::std::os::raw::c_int,
        lpNewlyActivate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Active_SetPrefer(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStatus: ::std::os::raw::c_int,
        iNumPreferTarget: ::std::os::raw::c_int,
        lpPreferTarget: *mut ADLDisplayTarget,
        lpNewlyActivate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Primary_Get(
        context: ADL_CONTEXT_HANDLE,
        lpPrimaryAdapterIndex: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Primary_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ModeSwitch(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Active_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpStatus: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Aspects_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpAspects: *mut ::std::os::raw::c_char,
        iSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_NumberOfAdapters_Get(
        context: ADL_CONTEXT_HANDLE,
        lpNumAdapters: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Flush_Driver_Data(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_AdapterInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        lpInfo: LPAdapterInfo,
        iInputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_VerndorID_Int_get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_AdapterInfoX2_Get(
        context: ADL_CONTEXT_HANDLE,
        lppAdapterInfo: *mut *mut AdapterInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_RegValueString_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDriverPathOption: ::std::os::raw::c_int,
        szSubKey: *mut ::std::os::raw::c_char,
        szKeyName: *mut ::std::os::raw::c_char,
        iSize: ::std::os::raw::c_int,
        lpKeyValue: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_RegValueString_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDriverPathOption: ::std::os::raw::c_int,
        szSubKey: *mut ::std::os::raw::c_char,
        szKeyName: *mut ::std::os::raw::c_char,
        iSize: ::std::os::raw::c_int,
        lpKeyValue: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_RegValueInt_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDriverPathOption: ::std::os::raw::c_int,
        szSubKey: *mut ::std::os::raw::c_char,
        szKeyName: *mut ::std::os::raw::c_char,
        lpKeyValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_RegValueInt_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDriverPathOption: ::std::os::raw::c_int,
        szSubKey: *mut ::std::os::raw::c_char,
        szKeyName: *mut ::std::os::raw::c_char,
        iKeyValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ASICFamilyType_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpAsicTypes: *mut ::std::os::raw::c_int,
        lpValids: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Speed_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCaps: *mut ::std::os::raw::c_int,
        lpValid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Speed_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Speed_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iSpeed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Accessibility_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpAccessibility: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_VideoBiosInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpBiosInfo: *mut ADLBiosInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ID_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpAdapterID: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_AdapterX2_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        adapterCaps: *mut ADLAdapterCapsX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Stress_Test_Cap(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iSupported: *mut ::std::os::raw::c_int,
        iEnabled: *mut ::std::os::raw::c_int,
        iVersion: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Throttle_Notification_Cap(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iSupported: *mut ::std::os::raw::c_int,
        iEnabled: *mut ::std::os::raw::c_int,
        iVersion: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_AceDefaults_Restore(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_AdapterInfoX4_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        numAdapters: *mut ::std::os::raw::c_int,
        lppAdapterInfoX2: *mut *mut AdapterInfoX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_AdapterInfoX3_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        numAdapters: *mut ::std::os::raw::c_int,
        lppAdapterInfo: *mut *mut AdapterInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_AdapterList_Disable(
        context: ADL_CONTEXT_HANDLE,
        iNumAdapters: ::std::os::raw::c_int,
        lpAdapterIndexList: *mut ::std::os::raw::c_int,
        isSkipSaveDB: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_BigSw_Info_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpBigSwSupportMajor: *mut ::std::os::raw::c_int,
        lpBigSwSupportMinor: *mut ::std::os::raw::c_int,
        lpRedStoneSupport: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        adapterCaps: *mut ADLAdapterCaps,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ChipSetInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpChipSetInfo: *mut ADLChipSetInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Feature_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iFeatureID: ADL_UIFEATURES_GROUP,
        iIsFeatureSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_HBC_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpHbcCapable: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Headless_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpHeadless: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_IsGamingDriver_Info_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCwgSupport: *mut ::std::os::raw::c_int,
        lpIsGamingMode: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_MemoryInfo2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpMemoryInfo2: *mut ADLMemoryInfo2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_TRNG_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iTRNGSize: ::std::os::raw::c_int,
        iTRNGBufferSize: ::std::os::raw::c_int,
        lpTRNGBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Modes_ReEnumerate(context: ADL_CONTEXT_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Feature_Settings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iFeatureID: ADL_UIFEATURES_GROUP,
        iCurrent: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Feature_Settings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iFeatureID: ADL_UIFEATURES_GROUP,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_GcnAsicInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        gcnInfo: *mut ADLGcnInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_GPUVMPageSize_Info_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iVMPageSizeSupport: *mut ::std::os::raw::c_int,
        iVMPageSizeType: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_GPUVMPageSize_Info_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iVMPageSizeType: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_VRAMUsage_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iVRAMUsageInMB: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_DedicatedVRAMUsage_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iVRAMUsageInMB: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_VideoTheaterModeInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOverlayDisplayMode: *mut ::std::os::raw::c_int,
        lpSavedSettings: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_VideoTheaterModeInfo_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iOverlayDisplayMode: ::std::os::raw::c_int,
        iSavedSettings: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_MMD_Features_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lppFeatureCaps: *mut *mut ADLFeatureCaps,
        lpFeatureCount: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_MMD_FeatureValues_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lppFeatureValues: *mut *mut ADLFeatureValues,
        lpFeatureCount: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_MMD_FeatureValues_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpFeatureValues: *mut ADLFeatureValues,
        iFeatureCount: ::std::os::raw::c_int,
        ClientID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PageMigration_Settings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpVirtualSegSettings: *mut ADLVirtualSegmentSettingsOutput,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PageMigration_Settings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iEnabled: ::std::os::raw::c_int,
        iNewSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Crossfire_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpPreferred: *mut ::std::os::raw::c_int,
        lpNumComb: *mut ::std::os::raw::c_int,
        ppCrossfireComb: *mut *mut ADLCrossfireComb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Crossfire_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCrossfireComb: *mut ADLCrossfireComb,
        lpCrossfireInfo: *mut ADLCrossfireInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_Crossfire_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCrossfireComb: *mut ADLCrossfireComb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_MVPU_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iState: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_CrossfireX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCrossfireComb: *mut ADLCrossfireComb,
        lpCrossfireInfo: *mut ADLCrossfireInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_BoardLayout_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpValidFlags: *mut ::std::os::raw::c_int,
        lpNumberSlots: *mut ::std::os::raw::c_int,
        lppBracketSlot: *mut *mut ADLBracketSlotInfo,
        lpNumberConnector: *mut ::std::os::raw::c_int,
        lppConnector: *mut *mut ADLConnectorInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_SupportedConnections_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        devicePort: ADLDevicePort,
        lpADLSupportedConnections: *mut ADLSupportedConnections,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ConnectionState_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        devicePort: ADLDevicePort,
        lpADLConnectionState: *mut ADLConnectionState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_EmulationMode_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        devicePort: ADLDevicePort,
        iEmulationMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ConnectionData_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        devicePort: ADLDevicePort,
        ConnectionData: ADLConnectionData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ConnectionData_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        devicePort: ADLDevicePort,
        iQueryType: ::std::os::raw::c_int,
        lpConnectionData: *mut ADLConnectionData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ConnectionData_Remove(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        devicePort: ADLDevicePort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_EDIDManagement_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Workstation_GlobalEDIDPersistence_Get(
        context: ADL_CONTEXT_HANDLE,
        lpCurResultValue: *mut ::std::os::raw::c_int,
        lpDefResultValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Workstation_GlobalEDIDPersistence_Set(
        context: ADL_CONTEXT_HANDLE,
        iCurState: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_ElmCompatibilityMode_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_ElmCompatibilityMode_Status_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_ElmCompatibilityMode_Status_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_FPS_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
        lpVersion: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_FPS_Settings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpFPSSettings: *mut ADLFPSSettingsOutput,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_FPS_Settings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpFPSSettings: ADLFPSSettingsInput,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_FPS_Settings_Reset(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_RIS_Settings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: ADL_RIS_SETTINGS,
        changeReason: ADL_RIS_NOTFICATION_REASON,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_RIS_Settings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: *mut ADL_RIS_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_CHILL_SettingsX2_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: ADL_CHILL_SETTINGS,
        changeReason: ADL_CHILL_NOTFICATION_REASON,
        errorReason: *mut ADL_ERROR_REASON,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_CHILL_SettingsX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: *mut ADL_CHILL_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DELAG_Settings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: ADL_DELAG_SETTINGS,
        changeReason: ADL_DELAG_NOTFICATION_REASON,
        errorReason: *mut ADL_ERROR_REASON,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DELAG_Settings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: *mut ADL_DELAG_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_BOOST_Settings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: ADL_BOOST_SETTINGS,
        changeReason: ADL_BOOST_NOTFICATION_REASON,
        errorReason: *mut ADL_ERROR_REASON,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_BOOST_Settings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: *mut ADL_BOOST_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PROVSR_Settings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: ADL_PROVSR_SETTINGS,
        changeReason: ADL_PROVSR_NOTFICATION_REASON,
        errorReason: *mut ADL_ERROR_REASON,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PROVSR_Settings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        settings: *mut ADL_PROVSR_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Chill_Settings_Notify(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iChanged: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Chill_Settings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iEnabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Chill_Settings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpEnabled: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Chill_Caps_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iSupported: *mut ::std::os::raw::c_int,
        iCheckCaps: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PerformanceTuning_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PerfTuning_Status_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpPTuningValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PerfTuning_Status_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpPTuningValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PPW_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PPW_Status_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpFPWValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PPW_Status_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iFPWValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_FrameMetrics_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iIsFrameMonitorSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_FrameMetrics_Start(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        VidPnSourceId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_FrameMetrics_Stop(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        VidPnSourceId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_FrameMetrics_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        VidPnSourceId: ::std::os::raw::c_int,
        iFramesPerSecond: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_FrameMetrics_FrameDuration_Enable(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        frameDurationHandle: *mut ADL_FRAME_DURATION_HANDLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_FrameMetrics_FrameDuration_Disable(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        frameDurationHandle: *mut ADL_FRAME_DURATION_HANDLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_FrameMetrics_FrameDuration_Start(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        VidPnSourceId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_FrameMetrics_FrameDuration_Stop(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        VidPnSourceId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_FrameMetrics_FrameDuration_Get(
        context: ADL_CONTEXT_HANDLE,
        frameDurationHandle: ADL_FRAME_DURATION_HANDLE,
        pFrameDurationsArr: *mut ::std::os::raw::c_ulonglong,
        frameDurationsArrSize: ::std::os::raw::c_uint,
        elementsCopied: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ClockInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpClockInfo: *mut ADLClockInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_AdapterID_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpAdapterID: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_EDC_ErrorRecords_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        pErrorrecordCount: *mut ::std::os::raw::c_int,
        errorRecords: *mut ADLErrorRecord,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_EDC_ErrorInjection_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        errorInjection: *mut ADLErrorInjection,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_VirtualType_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iVirtualType: *mut ADL_VIRTUALDISPLAY_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_WriteAndReadI2CLargePayload(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        plI2C: *mut ADLI2CLargePayload,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_HDCP_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpHDCPSettings: *mut ADLHDCPSettings,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_HDCP_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iSetToDefault: ::std::os::raw::c_int,
        iEnable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_HDRState_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        displayID: ADLDisplayID,
        iSupport: *mut ::std::os::raw::c_int,
        iEnable: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_HDRState_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        displayID: ADLDisplayID,
        iEnable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Limits_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpMaxHRes: *mut ::std::os::raw::c_int,
        lpMaxVRes: *mut ::std::os::raw::c_int,
        lpMaxRefresh: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_PreferredMode_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpNumModes: *mut ::std::os::raw::c_int,
        lppModes: *mut *mut ADLMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DisplayInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpNumDisplays: *mut ::std::os::raw::c_int,
        lppInfo: *mut *mut ADLDisplayInfo,
        iForceDetect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DpMstInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpNumDisplays: *mut ::std::os::raw::c_int,
        lppDisplayDPMstInfo: *mut *mut ADLDisplayDPMSTInfo,
        iForceDetect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_NumberOfDisplays_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpNumDisplays: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_PreservedAspectRatio_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_PreservedAspectRatio_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ImageExpansion_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ImageExpansion_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Position_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpX: *mut ::std::os::raw::c_int,
        lpY: *mut ::std::os::raw::c_int,
        lpXDefault: *mut ::std::os::raw::c_int,
        lpYDefault: *mut ::std::os::raw::c_int,
        lpMinX: *mut ::std::os::raw::c_int,
        lpMinY: *mut ::std::os::raw::c_int,
        lpMaxX: *mut ::std::os::raw::c_int,
        lpMaxY: *mut ::std::os::raw::c_int,
        lpStepX: *mut ::std::os::raw::c_int,
        lpStepY: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Position_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iX: ::std::os::raw::c_int,
        iY: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Size_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpWidth: *mut ::std::os::raw::c_int,
        lpHeight: *mut ::std::os::raw::c_int,
        lpDefaultWidth: *mut ::std::os::raw::c_int,
        lpDefaultHeight: *mut ::std::os::raw::c_int,
        lpMinWidth: *mut ::std::os::raw::c_int,
        lpMinHeight: *mut ::std::os::raw::c_int,
        lpMaxWidth: *mut ::std::os::raw::c_int,
        lpMaxHeight: *mut ::std::os::raw::c_int,
        lpStepWidth: *mut ::std::os::raw::c_int,
        lpStepHeight: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Size_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iWidth: ::std::os::raw::c_int,
        iHeight: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_AdjustCaps_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpInfo: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Capabilities_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpNumberOfControllers: *mut ::std::os::raw::c_int,
        lpNumberOfDisplays: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ConnectedDisplays_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpConnections: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DeviceConfig_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpDisplayConfig: *mut ADLDisplayConfig,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Property_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpDisplayProperty: *mut ADLDisplayProperty,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Property_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpDisplayProperty: *mut ADLDisplayProperty,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_SwitchingCapability_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpResult: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DitherState_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpDitherState: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DitherState_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iDitherState: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_SupportedPixelFormat_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpPixelFormat: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_PixelFormat_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpPixelFormat: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_PixelFormatDefault_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpDefPixelFormat: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_PixelFormat_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iPixelFormat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_SupportedColorDepth_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpColorDepth: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ColorDepth_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpColorDepth: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ColorDepth_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iColorDepth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ODClockInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOdClockInfo: *mut ADLAdapterODClockInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ODClockConfig_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOdClockConfig: *mut ADLAdapterODClockConfig,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_AdjustmentCoherent_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpAdjustmentCoherentCurrent: *mut ::std::os::raw::c_int,
        lpAdjustmentCoherentDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_AdjustmentCoherent_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iAdjustmentCoherent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ReducedBlanking_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpReducedBlankingCurrent: *mut ::std::os::raw::c_int,
        lpReducedBlankingDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ReducedBlanking_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iReducedBlanking: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_FormatsOverride_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpSettingsSupported: *mut ::std::os::raw::c_int,
        lpSettingsSupportedEx: *mut ::std::os::raw::c_int,
        lpCurSettings: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_FormatsOverride_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iOverrideSettings: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_MVPUCaps_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpMvpuCaps: *mut ADLMVPUCaps,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_MVPUStatus_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpMvpuStatus: *mut ADLMVPUStatus,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DummyVirtual_Get(
        context: ADL_CONTEXT_HANDLE,
        iVirtualDisplayType: ::std::os::raw::c_int,
        iTargetID: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DummyVirtual_Destroy(
        context: ADL_CONTEXT_HANDLE,
        iTargetID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_VariBright_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iSupported: *mut ::std::os::raw::c_int,
        iEnabled: *mut ::std::os::raw::c_int,
        iVersion: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_VariBrightEnable_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iEnabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_VariBrightLevel_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDefaultLevel: *mut ::std::os::raw::c_int,
        iNumberOfLevels: *mut ::std::os::raw::c_int,
        iStep: *mut ::std::os::raw::c_int,
        iCurrentLevel: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_VariBrightLevel_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iCurrentLevel: ::std::os::raw::c_int,
        iApplyImmediately: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ControllerOverlayAdjustmentCaps_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOverlayInput: *mut ADLControllerOverlayInput,
        lpCapsInfo: *mut ADLControllerOverlayInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ControllerOverlayAdjustmentData_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOverlay: *mut ADLControllerOverlayInput,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ControllerOverlayAdjustmentData_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOverlay: *mut ADLControllerOverlayInput,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ViewPort_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpControllerMode: *mut ADLControllerMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ViewPort_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpControllerMode: *mut ADLControllerMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ViewPort_Cap(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_WriteAndReadI2CRev_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpMajor: *mut ::std::os::raw::c_int,
        lpMinor: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_WriteAndReadI2C(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        plI2C: *mut ADLI2C,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DDCBlockAccess_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iOption: ::std::os::raw::c_int,
        iCommandIndex: ::std::os::raw::c_int,
        iSendMsgLen: ::std::os::raw::c_int,
        lpucSendMsgBuf: *mut ::std::os::raw::c_char,
        lpulRecvMsgLen: *mut ::std::os::raw::c_int,
        lpucRecvMsgBuf: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DDCInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpInfo: *mut ADLDDCInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DDCInfo2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpInfo: *mut ADLDDCInfo2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_EdidData_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpEDIDData: *mut ADLDisplayEDIDData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ColorCaps_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCaps: *mut ::std::os::raw::c_int,
        lpValids: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Color_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iColorType: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Color_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iColorType: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
        lpMin: *mut ::std::os::raw::c_int,
        lpMax: *mut ::std::os::raw::c_int,
        lpStep: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ColorTemperatureSource_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpTempSource: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ColorTemperatureSourceDefault_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpTempSourceDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ColorTemperatureSource_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iTempSource: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Gamut_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        gamut: ADLGamutReference,
        lpCap: *mut ADLGamutInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Gamut_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        gamut: ADLGamutReference,
        lpSource: *mut ADLGamutData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Gamut_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        gamut: ADLGamutReference,
        lpSource: *const ADLGamutData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ModeTimingOverride_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpModeIn: *mut ADLDisplayMode,
        lpModeInfoOut: *mut ADLDisplayModeInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ModeTimingOverride_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpMode: *mut ADLDisplayModeInfo,
        iForceUpdate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ModeTimingOverrideList_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iMaxNumOfOverrides: ::std::os::raw::c_int,
        lpModeInfoList: *mut ADLDisplayModeInfo,
        lpNumOfOverrides: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ModeTimingOverrideX2_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpMode: *mut ADLDisplayModeInfoX2,
        iForceUpdate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ModeTimingOverrideX3_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        displayID: ADLDisplayID,
        lpModeIn: *mut ADLDisplayModeX2,
        lpModeInfoOut: *mut ADLDisplayModeInfoX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ModeTimingOverrideListX3_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        displayID: ADLDisplayID,
        lpNumOfModes: *mut ::std::os::raw::c_int,
        lpModeInfoList: *mut *mut ADLDisplayModeInfoX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_ModeTimingOverride_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ModeTimingOverrideX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        displayID: ADLDisplayID,
        lpModeIn: *mut ADLDisplayModeX2,
        lpModeInfoOut: *mut ADLDisplayModeInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ModeTimingOverrideListX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        displayID: ADLDisplayID,
        lpNumOfModes: *mut ::std::os::raw::c_int,
        lpModeInfoList: *mut *mut ADLDisplayModeInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_ModeTimingOverride_Delete(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        displayID: ADLDisplayID,
        lpMode: *mut ADLDisplayModeX2,
        iForceUpdate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_CustomizedModeListNum_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpListNum: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_CustomizedModeList_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCustomModeList: *mut ADLCustomMode,
        iBuffSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_CustomizedMode_Add(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        customMode: ADLCustomMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_CustomizedMode_Delete(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_CustomizedMode_Validate(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        customMode: ADLCustomMode,
        lpValid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_UnderscanSupport_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_UnderscanState_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_UnderscanState_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iUnderscanEnabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Underscan_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Underscan_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
        lpMin: *mut ::std::os::raw::c_int,
        lpMax: *mut ::std::os::raw::c_int,
        lpStep: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Overscan_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Overscan_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
        lpMin: *mut ::std::os::raw::c_int,
        lpMax: *mut ::std::os::raw::c_int,
        lpStep: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_BaseAudioSupport_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_HDMISupport_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_MVPUAnalogSupport_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_PixelFormat_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpValidBits: *mut ::std::os::raw::c_int,
        lpValidCaps: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_PixelFormat_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCurState: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_PixelFormat_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iState: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_GPUScalingEnable_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_GPUScalingEnable_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_AllowOnlyCETimings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_DFP_AllowOnlyCETimings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_TVCaps_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpcaps: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_TV_Standard_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_TV_Standard_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
        lpSupportedStandards: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_CV_DongleSettings_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpDongleSetting: *mut ::std::os::raw::c_int,
        lpOverrideSettingsSupported: *mut ::std::os::raw::c_int,
        lpCurOverrideSettings: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_CV_DongleSettings_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iOverrideSettings: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_CV_DongleSettings_Reset(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_UnderScan_Auto_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
        lpMin: *mut ::std::os::raw::c_int,
        lpMax: *mut ::std::os::raw::c_int,
        lpStep: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_UnderScan_Auto_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Deflicker_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
        lpMin: *mut ::std::os::raw::c_int,
        lpMax: *mut ::std::os::raw::c_int,
        lpStep: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Deflicker_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayindex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_FilterSVideo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
        lpMin: *mut ::std::os::raw::c_int,
        lpMax: *mut ::std::os::raw::c_int,
        lpStep: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_FilterSVideo_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DisplayContent_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iContent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DisplayContent_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        piContent: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DisplayContent_Cap(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        pCapContent: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_TargetTiming_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        displayID: ADLDisplayID,
        lpModeInfoOut: *mut ADLDisplayModeInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_TargetTimingX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        displayID: ADLDisplayID,
        lpModeInfoOut: *mut ADLDisplayModeInfoX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_Downscaling_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayID: ::std::os::raw::c_int,
        lpCaps: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_FreeSyncState_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
        lpMinRefreshRateInMicroHz: *mut ::std::os::raw::c_int,
        lpMaxRefreshRateInMicroHz: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_FreeSyncState_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        iSetting: ::std::os::raw::c_int,
        iRefreshRateInMicroHz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DCE_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpADLDceSettings: *mut ADLDceSettings,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_DCE_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpADLDceSettings: *mut ADLDceSettings,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Display_FreeSync_Cap(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDisplayIndex: ::std::os::raw::c_int,
        lpFreeSyncCaps: *mut ADLFreeSyncCap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_CDS_UnsafeMode_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        unsafeMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_TurboSyncSupport_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iTurboSyncSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_User_Settings_Notify(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iSetting: ADL_USER_SETTINGS,
        iChanged: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Main_ControlX2_Create(
        callback: ADL_MAIN_MALLOC_CALLBACK,
        iEnumConnectedAdapters: ::std::os::raw::c_int,
        context: *mut ADL_CONTEXT_HANDLE,
        threadingModel: ADLThreadingModel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Main_ControlX3_Create(
        callback: ADL_MAIN_MALLOC_CALLBACK,
        iEnumConnectedAdapters: ::std::os::raw::c_int,
        context: *mut ADL_CONTEXT_HANDLE,
        threadingModel: ADLThreadingModel,
        adlCreateOptions: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Main_Control_Create(
        callback: ADL_MAIN_MALLOC_CALLBACK,
        iEnumConnectedAdapters: ::std::os::raw::c_int,
        context: *mut ADL_CONTEXT_HANDLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Main_Control_Refresh(context: ADL_CONTEXT_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Main_Control_Destroy(context: ADL_CONTEXT_HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Main_Control_GetProcAddress(
        context: ADL_CONTEXT_HANDLE,
        lpModule: *mut ::std::os::raw::c_void,
        lpProcName: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ADL2_RegisterEvent(
        context: ADL_CONTEXT_HANDLE,
        eventID: ::std::os::raw::c_int,
        eventHandle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_UnRegisterEvent(
        context: ADL_CONTEXT_HANDLE,
        eventID: ::std::os::raw::c_int,
        eventHandle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_RegisterEventX2(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        clientID: ::std::os::raw::c_int,
        eventID: ::std::os::raw::c_int,
        eventHandle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_UnRegisterEventX2(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        clientID: ::std::os::raw::c_int,
        eventID: ::std::os::raw::c_int,
        eventHandle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PerGPU_GDEvent_Register(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        clientID: ::std::os::raw::c_int,
        eventID: ::std::os::raw::c_int,
        eventHandle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_PerGPU_GDEvent_UnRegister(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        clientID: ::std::os::raw::c_int,
        eventID: ::std::os::raw::c_int,
        eventHandle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_CurrentActivity_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpActivity: *mut ADLPMActivity,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_ThermalDevices_Enum(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iThermalControllerIndex: ::std::os::raw::c_int,
        lpThermalControllerInfo: *mut ADLThermalControllerInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_Temperature_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iThermalControllerIndex: ::std::os::raw::c_int,
        lpTemperature: *mut ADLTemperature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_FanSpeedInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iThermalControllerIndex: ::std::os::raw::c_int,
        lpFanSpeedInfo: *mut ADLFanSpeedInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_FanSpeed_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iThermalControllerIndex: ::std::os::raw::c_int,
        lpFanSpeedValue: *mut ADLFanSpeedValue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_FanSpeed_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iThermalControllerIndex: ::std::os::raw::c_int,
        lpFanSpeedValue: *mut ADLFanSpeedValue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_FanSpeedToDefault_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iThermalControllerIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_ODParameters_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOdParameters: *mut ADLODParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_ODPerformanceLevels_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iDefault: ::std::os::raw::c_int,
        lpOdPerformanceLevels: *mut ADLODPerformanceLevels,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_ODPerformanceLevels_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOdPerformanceLevels: *mut ADLODPerformanceLevels,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_PowerControl_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_PowerControlInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpPowerControlInfo: *mut ADLPowerControlInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_PowerControl_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCurrentValue: *mut ::std::os::raw::c_int,
        lpDefaultValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive5_PowerControl_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iSupported: *mut ::std::os::raw::c_int,
        iEnabled: *mut ::std::os::raw::c_int,
        iVersion: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_Capabilities_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODCapabilities: *mut ADLOD6Capabilities,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_StateInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStateType: ::std::os::raw::c_int,
        lpStateInfo: *mut ADLOD6StateInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_State_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStateType: ::std::os::raw::c_int,
        lpStateInfo: *mut ADLOD6StateInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_State_Reset(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStateType: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_CurrentStatus_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCurrentStatus: *mut ADLOD6CurrentStatus,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_ThermalController_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpThermalControllerCaps: *mut ADLOD6ThermalControllerCaps,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_Temperature_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpTemperature: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_FanSpeed_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpFanSpeedInfo: *mut ADLOD6FanSpeedInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_FanSpeed_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpFanSpeedValue: *mut ADLOD6FanSpeedValue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_FanSpeed_Reset(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_PowerControl_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_PowerControlInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpPowerControlInfo: *mut ADLOD6PowerControlInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_PowerControl_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCurrentValue: *mut ::std::os::raw::c_int,
        lpDefaultValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_PowerControl_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_VoltageControlInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpVoltageControlInfo: *mut ADLOD6VoltageControlInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_VoltageControl_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCurrentValue: *mut ::std::os::raw::c_int,
        lpDefaultValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_VoltageControl_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_CapabilitiesEx_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODCapabilities: *mut ADLOD6CapabilitiesEx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_StateEx_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStateType: ::std::os::raw::c_int,
        lpODState: *mut ADLOD6StateEx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_StateEx_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStateType: ::std::os::raw::c_int,
        lpODState: *mut ADLOD6StateEx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_ThermalLimitUnlock_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStateType: ::std::os::raw::c_int,
        iEnable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_ThermalLimitUnlock_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStateType: ::std::os::raw::c_int,
        pEnabled: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_AdvancedFan_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_TargetTemperatureRangeInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpTargetTemperatureInfo: *mut ADLOD6ParameterRange,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_TargetTemperatureData_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCurrentValue: *mut ::std::os::raw::c_int,
        lpDefaultValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_TargetTemperatureData_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iCurrentValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_FanPWMLimitRangeInfo_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpFanPWMLimitInfo: *mut ADLOD6ParameterRange,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_FanPWMLimitData_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCurrentValue: *mut ::std::os::raw::c_int,
        lpDefaultValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_FanPWMLimitData_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iCurrentValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_CurrentPower_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iPowerType: ::std::os::raw::c_int,
        lpCurrentValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_ControlI2C(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iControl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive6_FuzzyController_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_Capabilities_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODCapabilities: *mut ADLODNCapabilities,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_CapabilitiesX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODCapabilities: *mut ADLODNCapabilitiesX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_SystemClocks_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPerformanceLevels: *mut ADLODNPerformanceLevels,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_SystemClocks_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPerformanceLevels: *mut ADLODNPerformanceLevels,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_SystemClocksX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPerformanceLevels: *mut ADLODNPerformanceLevelsX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_SystemClocksX2_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPerformanceLevels: *mut ADLODNPerformanceLevelsX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_MemoryClocksX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPerformanceLevels: *mut ADLODNPerformanceLevelsX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_MemoryClocksX2_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPerformanceLevels: *mut ADLODNPerformanceLevelsX2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_MemoryClocks_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPerformanceLevels: *mut ADLODNPerformanceLevels,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_MemoryClocks_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPerformanceLevels: *mut ADLODNPerformanceLevels,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_FanControl_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODFanSpeed: *mut ADLODNFanControl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_FanControl_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODFanControl: *mut ADLODNFanControl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_PowerLimit_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPowerLimit: *mut ADLODNPowerLimitSetting,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_PowerLimit_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPowerLimit: *mut ADLODNPowerLimitSetting,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_Temperature_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iTemperatureType: ::std::os::raw::c_int,
        iTemperature: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_PerformanceStatus_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODPerformanceStatus: *mut ADLODNPerformanceStatus,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_CustomFan_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_CustomFan_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODFanControl: *mut ADLODNFanControl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_CustomFan_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpODFanControl: *mut ADLODNFanControl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_MemoryTimingLevel_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
        lpCurrentValue: *mut ::std::os::raw::c_int,
        lpDefaultValue: *mut ::std::os::raw::c_int,
        lpNumberLevels: *mut ::std::os::raw::c_int,
        lppLevelList: *mut *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_MemoryTimingLevel_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        currentValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_ZeroRPMFan_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupport: *mut ::std::os::raw::c_int,
        lpCurrentValue: *mut ::std::os::raw::c_int,
        lpDefaultValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_ZeroRPMFan_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        currentValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_SettingsExt_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOverdriveNExtCapabilities: *mut ::std::os::raw::c_int,
        lpNumberOfODNExtFeatures: *mut ::std::os::raw::c_int,
        lppInitSettingList: *mut *mut ADLODNExtSingleInitSetting,
        lppCurrentSettingList: *mut *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_SettingsExt_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iNumberOfODNExtFeatures: ::std::os::raw::c_int,
        itemValueValidList: *mut ::std::os::raw::c_int,
        lpItemValueList: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_AutoWattman_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
        lpDefault: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_AutoWattman_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCurrent: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_AutoWattman_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iCurrent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_CountOfEvents_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        eventcounterType: ::std::os::raw::c_int,
        eventCount: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_SCLKAutoOverClock_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpStatus: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_SCLKAutoOverClock_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iStatus: ::std::os::raw::c_int,
        iFlags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_Test_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iEnabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_OverdriveN_ThrottleNotification_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpStatus: *mut ::std::os::raw::c_int,
        lpThrottleFlags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_Init_Setting_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpInitSetting: *mut ADLOD8InitSetting,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_Current_Setting_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpCurrentSetting: *mut ADLOD8CurrentSetting,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_Setting_Set(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSetSetting: *mut ADLOD8SetSetting,
        lpCurrentSetting: *mut ADLOD8CurrentSetting,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_New_QueryPMLogData_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpDataOutput: *mut ADLPMLogDataOutput,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_Init_SettingX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpOverdrive8Capabilities: *mut ::std::os::raw::c_int,
        lpNumberOfFeatures: *mut ::std::os::raw::c_int,
        lppInitSettingList: *mut *mut ADLOD8SingleInitSetting,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_Current_SettingX2_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpNumberOfFeatures: *mut ::std::os::raw::c_int,
        lppCurrentSettingList: *mut *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_AutoTuningResult_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpDataOutput: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_PMLogSenorRange_Caps(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpNumberOfSupportedSensorRange: *mut ::std::os::raw::c_int,
        lppSenorRangeCapsList: *mut *mut ADLOD8SingleInitSetting,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_PMLogSenorType_Support_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpNumOfSupportedSensorType: *mut ::std::os::raw::c_int,
        lppSenroTypesList: *mut *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_PMLog_ShareMemory_Support(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpSupported: *mut ::std::os::raw::c_int,
        option: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_PMLog_ShareMemory_Start(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iSampleRate: ::std::os::raw::c_int,
        iNumofPMLogSendorList: ::std::os::raw::c_int,
        lpPMLogSendorList: *mut ::std::os::raw::c_int,
        lpHDevice: *mut ADL_D3DKMT_HANDLE,
        lppSharedMemory: *mut *mut ::std::os::raw::c_void,
        iOption: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_PMLog_ShareMemory_Read(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        iNumSensor: ::std::os::raw::c_int,
        lpSensorList: *mut ::std::os::raw::c_int,
        lppSharedMemory: *mut *mut ::std::os::raw::c_void,
        lpDataOutput: *mut ADLPMLogDataOutput,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_PMLog_ShareMemory_Stop(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpHDevice: *mut ADL_D3DKMT_HANDLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Device_PMLog_Device_Create(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        pDevice: *mut ADL_D3DKMT_HANDLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Device_PMLog_Device_Destroy(
        context: ADL_CONTEXT_HANDLE,
        hDevice: ADL_D3DKMT_HANDLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Overdrive8_Current_SettingX3_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpFeatureNotAdjustableBits: *mut ::std::os::raw::c_int,
        lpNumberOfSettings: *mut ::std::os::raw::c_int,
        lppCurrentSettingList: *mut *mut ::std::os::raw::c_int,
        iOption: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_PMLog_Support_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        pPMLogSupportInfo: *mut ADLPMLogSupportInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_PMLog_Start(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        pPMLogStartInput: *mut ADLPMLogStartInput,
        pPMLogStartOutput: *mut ADLPMLogStartOutput,
        hDevice: ADL_D3DKMT_HANDLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_PMLog_Stop(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        hDevice: ADL_D3DKMT_HANDLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ADL2_Adapter_PMLog_SensorLimits_Get(
        context: ADL_CONTEXT_HANDLE,
        iAdapterIndex: ::std::os::raw::c_int,
        lpDataOutput: *mut ADLPMLogSensorLimits,
    ) -> ::std::os::raw::c_int;
}
